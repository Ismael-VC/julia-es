# 
msgid ""
msgstr ""
"Project-Id-Version: Julia Language 0.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-12-24 16:27-0600\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../manual/arrays.rst:7
msgid "Multi-dimensional Arrays"
msgstr ""

#: ../../manual/arrays.rst:9
msgid ""
"Julia, like most technical computing languages, provides a first-class array"
" implementation. Most technical computing languages pay a lot of attention "
"to their array implementation at the expense of other containers. Julia does"
" not treat arrays in any special way. The array library is implemented "
"almost completely in Julia itself, and derives its performance from the "
"compiler, just like any other code written in Julia."
msgstr ""

#: ../../manual/arrays.rst:17
msgid ""
"An array is a collection of objects stored in a multi-dimensional grid.  In "
"the most general case, an array may contain objects of type ``Any``.  For "
"most computational purposes, arrays should contain objects of a more "
"specific type, such as ``Float64`` or ``Int32``."
msgstr ""

#: ../../manual/arrays.rst:22
msgid ""
"In general, unlike many other technical computing languages, Julia does not "
"expect programs to be written in a vectorized style for performance. Julia's"
" compiler uses type inference and generates optimized code for scalar array "
"indexing, allowing programs to be written in a style that is convenient and "
"readable, without sacrificing performance, and using less memory at times."
msgstr ""

#: ../../manual/arrays.rst:29
msgid ""
"In Julia, all arguments to functions are passed by reference. Some technical"
" computing languages pass arrays by value, and this is convenient in many "
"cases. In Julia, modifications made to input arrays within a function will "
"be visible in the parent function. The entire Julia array library ensures "
"that inputs are not modified by library functions. User code, if it needs to"
" exhibit similar behavior, should take care to create a copy of inputs that "
"it may modify."
msgstr ""

#: ../../manual/arrays.rst:38
msgid "Arrays"
msgstr ""

#: ../../manual/arrays.rst:41
msgid "Basic Functions"
msgstr ""

#: ../../manual/arrays.rst:44 ../../manual/arrays.rst:64
#: ../../manual/arrays.rst:106
#: ../../manual/integers-and-floating-point-numbers.rst:732
#: ../../manual/mathematical-operations.rst:234
#: ../../manual/mathematical-operations.rst:363
#: ../../manual/mathematical-operations.rst:379
#: ../../manual/mathematical-operations.rst:396
#: ../../manual/mathematical-operations.rst:410
#: ../../manual/mathematical-operations.rst:466
msgid "Function"
msgstr ""

#: ../../manual/arrays.rst:44 ../../manual/arrays.rst:64
#: ../../manual/arrays.rst:106 ../../manual/arrays.rst:678
#: ../../manual/integers-and-floating-point-numbers.rst:355
#: ../../manual/integers-and-floating-point-numbers.rst:732
#: ../../manual/mathematical-operations.rst:20
#: ../../manual/mathematical-operations.rst:36
#: ../../manual/mathematical-operations.rst:363
#: ../../manual/mathematical-operations.rst:379
#: ../../manual/mathematical-operations.rst:396
#: ../../manual/mathematical-operations.rst:410
#: ../../manual/mathematical-operations.rst:466
msgid "Description"
msgstr ""

#: ../../manual/arrays.rst:46
msgid ":func:`eltype(A) <eltype>`"
msgstr ""

#: ../../manual/arrays.rst:46
msgid "the type of the elements contained in A"
msgstr ""

#: ../../manual/arrays.rst:47
msgid ":func:`length(A) <length>`"
msgstr ""

#: ../../manual/arrays.rst:47
msgid "the number of elements in A"
msgstr ""

#: ../../manual/arrays.rst:48
msgid ":func:`ndims(A) <ndims>`"
msgstr ""

#: ../../manual/arrays.rst:48
msgid "the number of dimensions of A"
msgstr ""

#: ../../manual/arrays.rst:49
msgid ":func:`size(A) <size>`"
msgstr ""

#: ../../manual/arrays.rst:49
msgid "a tuple containing the dimensions of A"
msgstr ""

#: ../../manual/arrays.rst:50
msgid ":func:`size(A,n) <size>`"
msgstr ""

#: ../../manual/arrays.rst:50
msgid "the size of A in a particular dimension"
msgstr ""

#: ../../manual/arrays.rst:51
msgid ":func:`stride(A,k) <stride>`"
msgstr ""

#: ../../manual/arrays.rst:51
msgid ""
"the stride (linear index distance between adjacent elements) along dimension"
" k"
msgstr ""

#: ../../manual/arrays.rst:52
msgid ":func:`strides(A) <strides>`"
msgstr ""

#: ../../manual/arrays.rst:52
msgid "a tuple of the strides in each dimension"
msgstr ""

#: ../../manual/arrays.rst:56
msgid "Construction and Initialization"
msgstr ""

#: ../../manual/arrays.rst:58
msgid ""
"Many functions for constructing and initializing arrays are provided. In the"
" following list of such functions, calls with a ``dims...`` argument can "
"either take a single tuple of dimension sizes or a series of dimension sizes"
" passed as a variable number of arguments."
msgstr ""

#: ../../manual/arrays.rst:66
msgid ":func:`Array(type, dims...) <Array>`"
msgstr ""

#: ../../manual/arrays.rst:66
msgid "an uninitialized dense array"
msgstr ""

#: ../../manual/arrays.rst:67
msgid ":func:`cell(dims...) <cell>`"
msgstr ""

#: ../../manual/arrays.rst:67
msgid "an uninitialized cell array (heterogeneous array)"
msgstr ""

#: ../../manual/arrays.rst:68
msgid ":func:`zeros(type, dims...) <zeros>`"
msgstr ""

#: ../../manual/arrays.rst:68
msgid ""
"an array of all zeros of specified type, defaults to ``Float64`` if ``type``"
" not specified"
msgstr ""

#: ../../manual/arrays.rst:70
msgid ":func:`zeros(A) <zeros>`"
msgstr ""

#: ../../manual/arrays.rst:70
msgid "an array of all zeros of same element type and shape of ``A``"
msgstr ""

#: ../../manual/arrays.rst:71
msgid ":func:`ones(type, dims...) <ones>`"
msgstr ""

#: ../../manual/arrays.rst:71
msgid ""
"an array of all ones of specified type, defaults to ``Float64`` if ``type`` "
"not specified"
msgstr ""

#: ../../manual/arrays.rst:73
msgid ":func:`ones(A) <ones>`"
msgstr ""

#: ../../manual/arrays.rst:73
msgid "an array of all ones of same element type and shape of ``A``"
msgstr ""

#: ../../manual/arrays.rst:74
msgid ":func:`trues(dims...) <trues>`"
msgstr ""

#: ../../manual/arrays.rst:74
msgid "a ``Bool`` array with all values ``true``"
msgstr ""

#: ../../manual/arrays.rst:75
msgid ":func:`falses(dims...) <falses>`"
msgstr ""

#: ../../manual/arrays.rst:75
msgid "a ``Bool`` array with all values ``false``"
msgstr ""

#: ../../manual/arrays.rst:76
msgid ":func:`reshape(A, dims...) <reshape>`"
msgstr ""

#: ../../manual/arrays.rst:76
msgid ""
"an array with the same data as the given array, but with different "
"dimensions."
msgstr ""

#: ../../manual/arrays.rst:78
msgid ":func:`copy(A) <copy>`"
msgstr ""

#: ../../manual/arrays.rst:78
msgid "copy ``A``"
msgstr ""

#: ../../manual/arrays.rst:79
msgid ":func:`deepcopy(A) <deepcopy>`"
msgstr ""

#: ../../manual/arrays.rst:79
msgid "copy ``A``, recursively copying its elements"
msgstr ""

#: ../../manual/arrays.rst:80
msgid ":func:`similar(A, element_type, dims...) <similar>`"
msgstr ""

#: ../../manual/arrays.rst:80
msgid ""
"an uninitialized array of the same type as the given array (dense, sparse, "
"etc.), but with the specified element type and dimensions. The second and "
"third arguments are both optional, defaulting to the element type and "
"dimensions of ``A`` if omitted."
msgstr ""

#: ../../manual/arrays.rst:84
msgid ":func:`reinterpret(type, A) <reinterpret>`"
msgstr ""

#: ../../manual/arrays.rst:84
msgid ""
"an array with the same binary data as the given array, but with the "
"specified element type"
msgstr ""

#: ../../manual/arrays.rst:86
msgid ":func:`rand(dims) <rand>`"
msgstr ""

#: ../../manual/arrays.rst:86
msgid ""
"``Array`` of ``Float64``\\ s with random, iid[#]_ and uniformly distributed "
"values in [0,1)"
msgstr ""

#: ../../manual/arrays.rst:88
msgid ":func:`randn(dims) <randn>`"
msgstr ""

#: ../../manual/arrays.rst:88
msgid ""
"``Array`` of ``Float64``\\ s with random, iid and standard normally "
"distributed random values"
msgstr ""

#: ../../manual/arrays.rst:90 ../../manual/arrays.rst:687
msgid ":func:`eye(n) <eye>`"
msgstr ""

#: ../../manual/arrays.rst:90
msgid "``n``-by-``n`` identity matrix"
msgstr ""

#: ../../manual/arrays.rst:91
msgid ":func:`eye(m, n) <eye>`"
msgstr ""

#: ../../manual/arrays.rst:91
msgid "``m``-by-``n`` identity matrix"
msgstr ""

#: ../../manual/arrays.rst:92
msgid ":func:`linspace(start, stop, n) <linspace>`"
msgstr ""

#: ../../manual/arrays.rst:92
msgid "vector of ``n`` linearly-spaced elements from ``start`` to ``stop``"
msgstr ""

#: ../../manual/arrays.rst:93
msgid ":func:`fill!(A, x) <fill!>`"
msgstr ""

#: ../../manual/arrays.rst:93
msgid "fill the array ``A`` with the value ``x``"
msgstr ""

#: ../../manual/arrays.rst:94
msgid ":func:`fill(x, dims) <fill>`"
msgstr ""

#: ../../manual/arrays.rst:94
msgid "create an array filled with the value ``x``"
msgstr ""

#: ../../manual/arrays.rst:97
msgid "*iid*, independently and identically distributed."
msgstr ""

#: ../../manual/arrays.rst:100
msgid "Concatenation"
msgstr ""

#: ../../manual/arrays.rst:102
msgid ""
"Arrays can be constructed and also concatenated using the following "
"functions:"
msgstr ""

#: ../../manual/arrays.rst:108
msgid ":func:`cat(k, A...) <cat>`"
msgstr ""

#: ../../manual/arrays.rst:108
msgid "concatenate input n-d arrays along the dimension ``k``"
msgstr ""

#: ../../manual/arrays.rst:109
msgid ":func:`vcat(A...) <vcat>`"
msgstr ""

#: ../../manual/arrays.rst:109
msgid "shorthand for ``cat(1, A...)``"
msgstr ""

#: ../../manual/arrays.rst:110
msgid ":func:`hcat(A...) <hcat>`"
msgstr ""

#: ../../manual/arrays.rst:110
msgid "shorthand for ``cat(2, A...)``"
msgstr ""

#: ../../manual/arrays.rst:113
msgid ""
"Scalar values passed to these functions are treated as 1-element arrays."
msgstr ""

#: ../../manual/arrays.rst:115
msgid ""
"The concatenation functions are used so often that they have special syntax:"
msgstr ""

#: ../../manual/arrays.rst:118 ../../manual/functions.rst:186
#: ../../manual/mathematical-operations.rst:20
#: ../../manual/mathematical-operations.rst:36
#: ../../manual/mathematical-operations.rst:69
msgid "Expression"
msgstr ""

#: ../../manual/arrays.rst:118 ../../manual/functions.rst:186
msgid "Calls"
msgstr ""

#: ../../manual/arrays.rst:120 ../../manual/functions.rst:188
msgid "``[A B C ...]``"
msgstr ""

#: ../../manual/arrays.rst:120
msgid ":func:`hcat`"
msgstr ""

#: ../../manual/arrays.rst:121 ../../manual/functions.rst:189
msgid "``[A, B, C, ...]``"
msgstr ""

#: ../../manual/arrays.rst:121
msgid ":func:`vcat`"
msgstr ""

#: ../../manual/arrays.rst:122 ../../manual/functions.rst:190
msgid "``[A B; C D; ...]``"
msgstr ""

#: ../../manual/arrays.rst:122
msgid ":func:`hvcat`"
msgstr ""

#: ../../manual/arrays.rst:125
msgid ""
":func:`hvcat` concatenates in both dimension 1 (with semicolons) and "
"dimension 2 (with spaces)."
msgstr ""

#: ../../manual/arrays.rst:129
msgid "Typed array initializers"
msgstr ""

#: ../../manual/arrays.rst:131
msgid ""
"An array with a specific element type can be constructed using the syntax "
"``T[A, B, C, ...]``. This will construct a 1-d array with element type "
"``T``, initialized to contain elements ``A``, ``B``, ``C``, etc."
msgstr ""

#: ../../manual/arrays.rst:135
msgid ""
"An array constructed with an explicit type annotation does not automatically"
" concatenate its arguments."
msgstr ""

#: ../../manual/arrays.rst:160
msgid "Comprehensions"
msgstr ""

#: ../../manual/arrays.rst:162
msgid ""
"Comprehensions provide a general and powerful way to construct arrays. "
"Comprehension syntax is similar to set construction notation in "
"mathematics::"
msgstr ""

#: ../../manual/arrays.rst:168
msgid ""
"The meaning of this form is that ``F(x,y,...)`` is evaluated with the "
"variables ``x``, ``y``, etc. taking on each value in their given list of "
"values. Values can be specified as any iterable object, but will commonly be"
" ranges like ``1:n`` or ``2:(n-1)``, or explicit arrays of values like "
"``[1.2, 3.4, 5.7]``. The result is an N-d dense array with dimensions that "
"are the concatenation of the dimensions of the variable ranges ``rx``, "
"``ry``, etc. and each ``F(x,y,...)`` evaluation returns a scalar."
msgstr ""

#: ../../manual/arrays.rst:177
msgid ""
"The following example computes a weighted average of the current element and"
" its left and right neighbor along a 1-d grid. :"
msgstr ""

#: ../../manual/arrays.rst:206
msgid ""
"In the above example, ``x`` is declared as constant because type inference "
"in Julia does not work as well on non-constant global variables."
msgstr ""

#: ../../manual/arrays.rst:210
msgid ""
"The resulting array type is inferred from the expression; in order to "
"control the type explicitly, the type can be prepended to the comprehension."
" For example, in the above example we could have avoided declaring ``x`` as "
"constant, and ensured that the result is of type ``Float64`` by writing::"
msgstr ""

#: ../../manual/arrays.rst:220
msgid "Indexing"
msgstr ""

#: ../../manual/arrays.rst:222
msgid "The general syntax for indexing into an n-dimensional array A is::"
msgstr ""

#: ../../manual/arrays.rst:226 ../../manual/arrays.rst:280
msgid "where each I\\_k may be:"
msgstr ""

#: ../../manual/arrays.rst:228 ../../manual/arrays.rst:282
msgid "A scalar value"
msgstr ""

#: ../../manual/arrays.rst:229 ../../manual/arrays.rst:283
msgid "A ``Range`` of the form ``:``, ``a:b``, or ``a:b:c``"
msgstr ""

#: ../../manual/arrays.rst:230 ../../manual/arrays.rst:284
msgid "An arbitrary integer vector, including the empty vector ``[]``"
msgstr ""

#: ../../manual/arrays.rst:231 ../../manual/arrays.rst:285
msgid "A boolean vector"
msgstr ""

#: ../../manual/arrays.rst:233
msgid ""
"The result X generally has dimensions ``(length(I_1), length(I_2), ..., "
"length(I_n))``, with location ``(i_1, i_2, ..., i_n)`` of X containing the "
"value ``A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]``. Trailing dimensions indexed "
"with scalars are dropped. For example, the dimensions of ``A[I, 1]`` will be"
" ``(length(I),)``. Boolean vectors are first transformed with ``find``; the "
"size of a dimension indexed by a boolean vector will be the number of true "
"values in the vector."
msgstr ""

#: ../../manual/arrays.rst:241
msgid "Indexing syntax is equivalent to a call to ``getindex``::"
msgstr ""

#: ../../manual/arrays.rst:245 ../../manual/arrays.rst:299
msgid "Example:"
msgstr ""

#: ../../manual/arrays.rst:261
msgid ""
"Empty ranges of the form ``n:n-1`` are sometimes used to indicate the inter-"
"index location between ``n-1`` and ``n``.  For example, the "
":func:`searchsorted` function uses this convention to indicate the insertion"
" point of a value not found in a sorted array:"
msgstr ""

#: ../../manual/arrays.rst:274
msgid "Assignment"
msgstr ""

#: ../../manual/arrays.rst:276
msgid ""
"The general syntax for assigning values in an n-dimensional array A is::"
msgstr ""

#: ../../manual/arrays.rst:287
msgid ""
"If ``X`` is an array, its size must be ``(length(I_1), length(I_2), ..., "
"length(I_n))``, and the value in location ``i_1, i_2, ..., i_n`` of ``A`` is"
" overwritten with the value ``X[I_1[i_1], I_2[i_2], ..., I_n[i_n]]``. If "
"``X`` is not an array, its value is written to all referenced locations of "
"``A``."
msgstr ""

#: ../../manual/arrays.rst:292
msgid ""
"A boolean vector used as an index behaves as in :func:`getindex` (it is "
"first transformed with :func:`find`)."
msgstr ""

#: ../../manual/arrays.rst:295
msgid "Index assignment syntax is equivalent to a call to :func:`setindex!`::"
msgstr ""

#: ../../manual/arrays.rst:319
msgid "Vectorized Operators and Functions"
msgstr ""

#: ../../manual/arrays.rst:321
msgid ""
"The following operators are supported for arrays. The dot version of a "
"binary operator should be used for elementwise operations."
msgstr ""

#: ../../manual/arrays.rst:324
msgid "Unary arithmetic — ``-``, ``+``, ``!``"
msgstr ""

#: ../../manual/arrays.rst:325
msgid ""
"Binary arithmetic — ``+``, ``-``, ``*``, ``.*``, ``/``, ``./``, ``\\``, "
"``.\\``, ``^``, ``.^``, ``div``, ``mod``"
msgstr ""

#: ../../manual/arrays.rst:327
msgid "Comparison — ``.==``, ``.!=``, ``.<``, ``.<=``, ``.>``, ``.>=``"
msgstr ""

#: ../../manual/arrays.rst:328
msgid "Unary Boolean or bitwise — ``~``"
msgstr ""

#: ../../manual/arrays.rst:329
msgid "Binary Boolean or bitwise — ``&``, ``|``, ``$``"
msgstr ""

#: ../../manual/arrays.rst:331
msgid ""
"Some operators without dots operate elementwise anyway when one argument is "
"a scalar. These operators are ``*``, ``+``, ``-``, and the bitwise "
"operators. The operators ``/`` and ``\\`` operate elementwise when the "
"denominator is a scalar."
msgstr ""

#: ../../manual/arrays.rst:335
msgid ""
"Note that comparisons such as ``==`` operate on whole arrays, giving a "
"single boolean answer. Use dot operators for elementwise comparisons."
msgstr ""

#: ../../manual/arrays.rst:338
msgid ""
"The following built-in functions are also vectorized, whereby the functions "
"act elementwise::"
msgstr ""

#: ../../manual/arrays.rst:361
msgid ""
"Note that there is a difference between :func:`min` and :func:`max`, which "
"operate elementwise over multiple array arguments, and :func:`minimum` and "
":func:`maximum`, which find the smallest and largest values within an array."
msgstr ""

#: ../../manual/arrays.rst:365
msgid ""
"Julia provides the :func:`@vectorize_1arg` and :func:`@vectorize_2arg` "
"macros to automatically vectorize any function of one or two arguments "
"respectively.  Each of these takes two arguments, namely the ``Type`` of "
"argument (which is usually chosen to be the most general possible) and the "
"name of the function to vectorize. Here is a simple example:"
msgstr ""

#: ../../manual/arrays.rst:392
msgid "Broadcasting"
msgstr ""

#: ../../manual/arrays.rst:394
msgid ""
"It is sometimes useful to perform element-by-element binary operations on "
"arrays of different sizes, such as adding a vector to each column of a "
"matrix.  An inefficient way to do this would be to replicate the vector to "
"the size of the matrix:"
msgstr ""

#: ../../manual/arrays.rst:408
msgid ""
"This is wasteful when dimensions get large, so Julia offers "
":func:`broadcast`, which expands singleton dimensions in array arguments to "
"match the corresponding dimension in the other array without using extra "
"memory, and applies the given function elementwise:"
msgstr ""

#: ../../manual/arrays.rst:430
msgid ""
"Elementwise operators such as ``.+`` and ``.*`` perform broadcasting if "
"necessary. There is also a :func:`broadcast!` function to specify an "
"explicit destination, and :func:`broadcast_getindex` and "
":func:`broadcast_setindex!` that broadcast the indices before indexing."
msgstr ""

#: ../../manual/arrays.rst:433
msgid "Implementation"
msgstr ""

#: ../../manual/arrays.rst:435
msgid ""
"The base array type in Julia is the abstract type ``AbstractArray{T,N}``. It"
" is parametrized by the number of dimensions ``N`` and the element type "
"``T``. ``AbstractVector`` and ``AbstractMatrix`` are aliases for the 1-d and"
" 2-d cases. Operations on ``AbstractArray`` objects are defined using higher"
" level operators and functions, in a way that is independent of the "
"underlying storage. These operations generally work correctly as a fallback "
"for any specific array implementation."
msgstr ""

#: ../../manual/arrays.rst:444
msgid ""
"The ``AbstractArray`` type includes anything vaguely array-like, and "
"implementations of it might be quite different from conventional arrays. For"
" example, elements might be computed on request rather than stored.  "
"However, any concrete ``AbstractArray{T,N}`` type should generally implement"
" at least :func:`size(A) <size>` (returing an ``Int`` tuple), "
":func:`getindex(A,i) <getindex>` and :func:`getindex(A,i1,...,iN) "
"<getindex>` (returning an element of type ``T``); mutable arrays should also"
" implement :func:`setindex!`.  It is recommended that these operations have "
"nearly constant time complexity, or technically Õ(1) complexity, as "
"otherwise some array functions may be unexpectedly slow.   Concrete types "
"should also typically provide a :func:`similar(A,T=eltype(A),dims=size(A)) "
"<similar>` method, which is used to allocate a similar array for "
":func:`copy` and other out-of-place operations."
msgstr ""

#: ../../manual/arrays.rst:457
msgid ""
"``DenseArray`` is an abstract subtype of ``AbstractArray`` intended to "
"include all arrays that are laid out at regular offsets in memory, and which"
" can therefore be passed to external C and Fortran functions expecting this "
"memory layout.  Subtypes should provide a method :func:`stride(A,k) "
"<stride>` that returns the \"stride\" of dimension ``k``: increasing the "
"index of dimension ``k`` by ``1`` should increase the index ``i`` of "
":func:`getindex(A,i) <getindex>` by :func:`stride(A,k) <stride>`.  If a "
"pointer conversion method :func:`convert(Ptr{T}, A) <convert>` is provided, "
"the memory layout should correspond in the same way to these strides."
msgstr ""

#: ../../manual/arrays.rst:467
msgid ""
"The ``Array{T,N}`` type is a specific instance of ``DenseArray`` where "
"elements are stored in column-major order (see additional notes in :ref"
":`man-performance-tips`). ``Vector`` and ``Matrix`` are aliases for the 1-d "
"and 2-d cases. Specific operations such as scalar indexing, assignment, and "
"a few other basic storage-specific operations are all that have to be "
"implemented for ``Array``, so that the rest of the array library can be "
"implemented in a generic manner."
msgstr ""

#: ../../manual/arrays.rst:475
msgid ""
"``SubArray`` is a specialization of ``AbstractArray`` that performs indexing"
" by reference rather than by copying. A ``SubArray`` is created with the "
":func:`sub` function, which is called the same way as :func:`getindex` (with"
" an array and a series of index arguments). The result of :func:`sub` looks "
"the same as the result of :func:`getindex`, except the data is left in "
"place. :func:`sub` stores the input index vectors in a ``SubArray`` object, "
"which can later be used to index the original array indirectly."
msgstr ""

#: ../../manual/arrays.rst:483
msgid ""
"``StridedVector`` and ``StridedMatrix`` are convenient aliases defined to "
"make it possible for Julia to call a wider range of BLAS and LAPACK "
"functions by passing them either ``Array`` or ``SubArray`` objects, and thus"
" saving inefficiencies from memory allocation and copying."
msgstr ""

#: ../../manual/arrays.rst:488
msgid ""
"The following example computes the QR decomposition of a small section of a "
"larger array, without creating any temporaries, and by calling the "
"appropriate LAPACK function with the right leading dimension size and stride"
" parameters."
msgstr ""

#: ../../manual/arrays.rst:530
msgid "Sparse Matrices"
msgstr ""

#: ../../manual/arrays.rst:532
msgid ""
"`Sparse matrices <http://en.wikipedia.org/wiki/Sparse_matrix>`_ are matrices"
" that contain enough zeros that storing them in a special data structure "
"leads to savings in space and execution time. Sparse matrices may be used "
"when operations on the sparse representation of a matrix lead to "
"considerable gains in either time or space when compared to performing the "
"same operations on a dense matrix."
msgstr ""

#: ../../manual/arrays.rst:540
msgid "Compressed Sparse Column (CSC) Storage"
msgstr ""

#: ../../manual/arrays.rst:542
msgid ""
"In Julia, sparse matrices are stored in the `Compressed Sparse Column (CSC) "
"format "
"<http://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_.28CSC_or_CCS.29>`_."
" Julia sparse matrices have the type ``SparseMatrixCSC{Tv,Ti}``, where "
"``Tv`` is the type of the nonzero values, and ``Ti`` is the integer type for"
" storing column pointers and row indices.::"
msgstr ""

#: ../../manual/arrays.rst:557
msgid ""
"The compressed sparse column storage makes it easy and quick to access the "
"elements in the column of a sparse matrix, whereas accessing the sparse "
"matrix by rows is considerably slower. Operations such as insertion of "
"nonzero values one at a time in the CSC structure tend to be slow. This is "
"because all elements of the sparse matrix that are beyond the point of "
"insertion have to be moved one place over."
msgstr ""

#: ../../manual/arrays.rst:564
msgid ""
"All operations on sparse matrices are carefully implemented to exploit the "
"CSC data structure for performance, and to avoid expensive operations."
msgstr ""

#: ../../manual/arrays.rst:567
msgid ""
"If you have data in CSC format from a different application or library, and "
"wish to import it in Julia, make sure that you use 1-based indexing. The row"
" indices in every column need to be sorted. If your `SparseMatrixCSC` object"
" contains unsorted row indices, one quick way to sort them is by doing a "
"double transpose."
msgstr ""

#: ../../manual/arrays.rst:573
msgid ""
"In some applications, it is convenient to store explicit zero values in a "
"`SparseMatrixCSC`. These *are* accepted by functions in ``Base`` (but there "
"is no guarantee that they will be preserved in mutating operations).  Such "
"explicitly stored zeros are treated as structural nonzeros by many routines."
"  The :func:`nnz` function returns the number of elements explicitly stored "
"in the sparse data structure, including structural nonzeros. In order to "
"count the exact number of actual values that are nonzero, use "
":func:`countnz`, which inspects every stored element of a sparse matrix."
msgstr ""

#: ../../manual/arrays.rst:584
msgid "Sparse matrix constructors"
msgstr ""

#: ../../manual/arrays.rst:586
msgid ""
"The simplest way to create sparse matrices is to use functions equivalent to"
" the :func:`zeros` and :func:`eye` functions that Julia provides for working"
" with dense matrices. To produce sparse matrices instead, you can use the "
"same names with an ``sp`` prefix:"
msgstr ""

#: ../../manual/arrays.rst:602
msgid ""
"The :func:`sparse` function is often a handy way to construct sparse "
"matrices. It takes as its input a vector ``I`` of row indices, a vector "
"``J`` of column indices, and a vector ``V`` of nonzero values. "
"``sparse(I,J,V)`` constructs a sparse matrix such that ``S[I[k], J[k]] = "
"V[k]``."
msgstr ""

#: ../../manual/arrays.rst:619
msgid ""
"The inverse of the :func:`sparse` function is :func:`findn`, which retrieves"
" the inputs used to create the sparse matrix."
msgstr ""

#: ../../manual/arrays.rst:630
msgid ""
"Another way to create sparse matrices is to convert a dense matrix into a "
"sparse matrix using the :func:`sparse` function:"
msgstr ""

#: ../../manual/arrays.rst:643
msgid ""
"You can go in the other direction using the :func:`full` function. The "
":func:`issparse` function can be used to query if a matrix is sparse."
msgstr ""

#: ../../manual/arrays.rst:652
msgid "Sparse matrix operations"
msgstr ""

#: ../../manual/arrays.rst:654
msgid ""
"Arithmetic operations on sparse matrices also work as they do on dense "
"matrices. Indexing of, assignment into, and concatenation of sparse matrices"
" work in the same way as dense matrices. Indexing operations, especially "
"assignment, are expensive, when carried out one element at a time. In many "
"cases it may be better to convert the sparse matrix into ``(I,J,V)`` format "
"using :func:`findnz`, manipulate the non-zeroes or the structure in the "
"dense vectors ``(I,J,V)``, and then reconstruct the sparse matrix."
msgstr ""

#: ../../manual/arrays.rst:664
msgid "Correspondence of dense and sparse methods"
msgstr ""

#: ../../manual/arrays.rst:665
msgid ""
"The following table gives a correspondence between built-in methods on "
"sparse matrices and their corresponding methods on dense matrix types. In "
"general, methods that generate sparse matrices differ from their dense "
"counterparts in that the resulting matrix follows the same sparsity pattern "
"as a given sparse matrix ``S``, or that the resulting sparse matrix has "
"density ``d``, i.e. each matrix element has a probability ``d`` of being "
"non-zero."
msgstr ""

#: ../../manual/arrays.rst:672
msgid ""
"Details can be found in the :ref:`stdlib-sparse` section of the standard "
"library reference."
msgstr ""

#: ../../manual/arrays.rst:678
msgid "Sparse"
msgstr ""

#: ../../manual/arrays.rst:678
msgid "Dense"
msgstr ""

#: ../../manual/arrays.rst:680
msgid ":func:`spzeros(m,n) <spzeros>`"
msgstr ""

#: ../../manual/arrays.rst:680
msgid ":func:`zeros(m,n) <zeros>`"
msgstr ""

#: ../../manual/arrays.rst:680
msgid ""
"Creates a *m*-by-*n* matrix of zeros. (:func:`spzeros(m,n) <spzeros>` is "
"empty.)"
msgstr ""

#: ../../manual/arrays.rst:683
msgid ":func:`spones(S) <spones>`"
msgstr ""

#: ../../manual/arrays.rst:683
msgid ":func:`ones(m,n) <ones>`"
msgstr ""

#: ../../manual/arrays.rst:683
msgid ""
"Creates a matrix filled with ones. Unlike the dense version, :func:`spones` "
"has the same sparsity pattern as *S*."
msgstr ""

#: ../../manual/arrays.rst:687
msgid ":func:`speye(n) <speye>`"
msgstr ""

#: ../../manual/arrays.rst:687
msgid "Creates a *n*-by-*n* identity matrix."
msgstr ""

#: ../../manual/arrays.rst:689
msgid ":func:`full(S) <full>`"
msgstr ""

#: ../../manual/arrays.rst:689
msgid ":func:`sparse(A) <sparse>`"
msgstr ""

#: ../../manual/arrays.rst:689
msgid "Interconverts between dense and sparse formats."
msgstr ""

#: ../../manual/arrays.rst:692
msgid ":func:`sprand(m,n,d) <sprand>`"
msgstr ""

#: ../../manual/arrays.rst:692
msgid ":func:`rand(m,n) <rand>`"
msgstr ""

#: ../../manual/arrays.rst:692
msgid ""
"Creates a *m*-by-*n* random matrix (of density *d*) with iid non-zero "
"elements distributed uniformly on the interval [0, 1]."
msgstr ""

#: ../../manual/arrays.rst:697
msgid ":func:`sprandn(m,n,d) <sprandn>`"
msgstr ""

#: ../../manual/arrays.rst:697
msgid ":func:`randn(m,n) <randn>`"
msgstr ""

#: ../../manual/arrays.rst:697
msgid ""
"Creates a *m*-by-*n* random matrix (of density *d*) with iid non-zero "
"elements distributed according to the standard normal (Gaussian) "
"distribution."
msgstr ""

#: ../../manual/arrays.rst:702
msgid ":func:`sprandn(m,n,d,X) <sprandn>`"
msgstr ""

#: ../../manual/arrays.rst:702
msgid ":func:`randn(m,n,X) <randn>`"
msgstr ""

#: ../../manual/arrays.rst:702
msgid ""
"Creates a *m*-by-*n* random matrix (of density *d*) with iid non-zero "
"elements distributed according to the *X* distribution. (Requires the "
"``Distributions`` package.)"
msgstr ""

#: ../../manual/arrays.rst:708
msgid ":func:`sprandbool(m,n,d) <sprandbool>`"
msgstr ""

#: ../../manual/arrays.rst:708
msgid ":func:`randbool(m,n) <randbool>`"
msgstr ""

#: ../../manual/arrays.rst:708
msgid ""
"Creates a *m*-by-*n* random matrix (of density *d*) with non-zero  ``Bool`` "
"elements with probability *d* (*d* =0.5 for :func:`randbool`.)"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:5
msgid "Calling C and Fortran Code"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:7
msgid ""
"Though most code can be written in Julia, there are many high-quality, "
"mature libraries for numerical computing already written in C and Fortran. "
"To allow easy use of this existing code, Julia makes it simple and efficient"
" to call C and Fortran functions. Julia has a \"no boilerplate\" philosophy:"
" functions can be called directly from Julia without any \"glue\" code, code"
" generation, or compilation — even from the interactive prompt. This is "
"accomplished just by making an appropriate call with ``ccall`` syntax, which"
" looks like an ordinary function call."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:16
msgid ""
"The code to be called must be available as a shared library. Most C and "
"Fortran libraries ship compiled as shared libraries already, but if you are "
"compiling the code yourself using GCC (or Clang), you will need to use the "
"``-shared`` and ``-fPIC`` options. The machine instructions generated by "
"Julia's JIT are the same as a native C call would be, so the resulting "
"overhead is the same as calling a library function from C code. (Non-library"
" function calls in both C and Julia can be inlined and thus may have even "
"less overhead than calls to shared library functions. When both libraries "
"and executables are generated by LLVM, it is possible to perform whole-"
"program optimizations that can even optimize across this boundary, but Julia"
" does not yet support that. In the future, however, it may do so, yielding "
"even greater performance gains.)"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:29
msgid ""
"Shared libraries and functions are referenced by a tuple of the form "
"``(:function, \"library\")`` or ``(\"function\", \"library\")`` where "
"``function`` is the C-exported function name. ``library`` refers to the "
"shared library name: shared libraries available in the (platform-specific) "
"load path will be resolved by name, and if necessary a direct path may be "
"specified."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:35
msgid ""
"A function name may be used alone in place of the tuple (just ``:function`` "
"or ``\"function\"``). In this case the name is resolved within the current "
"process. This form can be used to call C library functions, functions in the"
" Julia runtime, or functions in an application linked to Julia."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:41
msgid ""
"By default, Fortran compilers `generate mangled names "
"<http://en.wikipedia.org/wiki/Name_mangling#Name_mangling_in_Fortran>`_ (for"
" example, converting function names to lowercase or uppercase, often "
"appending an underscore), and so to call a Fortran function via ``ccall`` "
"you must pass the mangled identifier corresponding to the rule followed by "
"your Fortran compiler.  Also, when calling a Fortran function, all inputs "
"must be passed by reference."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:49
msgid ""
"Finally, you can use ``ccall`` to actually generate a call to the library "
"function. Arguments to ``ccall`` are as follows:"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:52
msgid "(:function, \"library\") pair (must be a constant, but see below)."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:53
msgid ""
"Return type, which may be any bits type, including ``Int32``, ``Int64``, "
"``Float64``, or ``Ptr{T}`` for any type parameter ``T``, indicating a "
"pointer to values of type ``T``, or ``Ptr{Void}`` for ``void*`` \"untyped "
"pointer\" values."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:57
msgid ""
"A tuple of input types, like those allowed for the return type. The input "
"types must be written as a literal tuple, not a tuple-valued variable or "
"expression."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:60
msgid ""
"The following arguments, if any, are the actual argument values passed to "
"the function."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:63
msgid ""
"As a complete but simple example, the following calls the ``clock`` function"
" from the standard C library::"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:75
msgid ""
"``clock`` takes no arguments and returns an ``Int32``. One common gotcha is "
"that a 1-tuple must be written with a trailing comma. For example, to call "
"the ``getenv`` function to get a pointer to the value of an environment "
"variable, one makes a call like this::"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:86
msgid ""
"Note that the argument type tuple must be written as ``(Ptr{UInt8},)``, "
"rather than ``(Ptr{UInt8})``. This is because ``(Ptr{UInt8})`` is just "
"``Ptr{UInt8}``, rather than a 1-tuple containing ``Ptr{UInt8}``::"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:96
msgid ""
"In practice, especially when providing reusable functionality, one generally"
" wraps ``ccall`` uses in Julia functions that set up arguments and then "
"check for errors in whatever manner the C or Fortran function indicates "
"them, propagating to the Julia caller as exceptions. This is especially "
"important since C and Fortran APIs are notoriously inconsistent about how "
"they indicate error conditions. For example, the ``getenv`` C library "
"function is wrapped in the following Julia function in `env.jl "
"<https://github.com/JuliaLang/julia/blob/master/base/env.jl>`_::"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:115
msgid ""
"The C ``getenv`` function indicates an error by returning ``NULL``, but "
"other standard C functions indicate errors in various different ways, "
"including by returning -1, 0, 1 and other special values. This wrapper "
"throws an exception clearly indicating the problem if the caller tries to "
"get a non-existent environment variable::"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:127
msgid ""
"Here is a slightly more complex example that discovers the local machine's "
"hostname::"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:138
msgid ""
"This example first allocates an array of bytes, then calls the C library "
"function ``gethostname`` to fill the array in with the hostname, takes a "
"pointer to the hostname buffer, and converts the pointer to a Julia string, "
"assuming that it is a NUL-terminated C string. It is common for C libraries "
"to use this pattern of requiring the caller to allocate memory to be passed "
"to the callee and filled in. Allocation of memory from Julia like this is "
"generally accomplished by creating an uninitialized array and passing a "
"pointer to its data to the C function."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:147
msgid ""
"A prefix ``&`` is used to indicate that a pointer to a scalar argument "
"should be passed instead of the scalar value itself (required for all "
"Fortran function arguments, as noted above). The following example computes "
"a dot product using a BLAS function."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:165
msgid ""
"The meaning of prefix ``&`` is not quite the same as in C. In particular, "
"any changes to the referenced variables will not be visible in Julia. "
"However, it will never cause any harm for called functions to attempt such "
"modifications (that is, writing through the passed pointers). Since this "
"``&`` is not a real address operator, it may be used with any syntax, such "
"as ``&0`` or ``&f(x)``."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:173
msgid ""
"Note that no C header files are used anywhere in the process. Currently, it "
"is not possible to pass structs and other non-primitive types from Julia to "
"C libraries. However, C functions that generate and use opaque struct types "
"by passing pointers to them can return such values to Julia as "
"``Ptr{Void}``, which can then be passed to other C functions as "
"``Ptr{Void}``. Memory allocation and deallocation of such objects must be "
"handled by calls to the appropriate cleanup routines in the libraries being "
"used, just like in any C program."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:183
msgid "Mapping C Types to Julia"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:185
msgid ""
"Julia automatically inserts calls to the ``convert`` function to convert "
"each argument to the specified type. For example, the following call::"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:191
msgid "will behave as if the following were written::"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:196
msgid ""
"When a scalar value is passed with ``&`` as an argument of type ``Ptr{T}``, "
"the value will first be converted to type ``T``."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:200
msgid "Array conversions"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:202
msgid ""
"When an array is passed to C as a ``Ptr{T}`` argument, it is never "
"converted: Julia simply checks that the element type of the array matches "
"``T``, and the address of the first element is passed. This is done in order"
" to avoid copying arrays unnecessarily."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:207
msgid ""
"Therefore, if an ``Array`` contains data in the wrong format, it will have "
"to be explicitly converted using a call such as ``int32(a)``."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:210
msgid ""
"To pass an array ``A`` as a pointer of a different type *without* converting"
" the data beforehand (for example, to pass a ``Float64`` array to a function"
" that operates on uninterpreted bytes), you can either declare the argument "
"as ``Ptr{Void}`` or you can explicitly call ``convert(Ptr{T}, pointer(A))``."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:218
msgid "Type correspondences"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:220
msgid ""
"On all systems we currently support, basic C/C++ value types may be "
"translated to Julia types as follows. Every C type also has a corresponding "
"Julia type with the same name, prefixed by C. This can help for writing "
"portable code (and remembering that an int in C is not the same as an Int in"
" Julia)."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:224
msgid "**System-independent:**"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:227
msgid "``unsigned char``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:227
msgid "``Cuchar``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:227
#: ../../manual/integers-and-floating-point-numbers.rst:33
msgid "``UInt8``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:229
msgid "``short``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:229
msgid "``Cshort``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:229
#: ../../manual/integers-and-floating-point-numbers.rst:34
msgid "``Int16``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:231
msgid "``unsigned short``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:231
msgid "``Cushort``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:231
#: ../../manual/integers-and-floating-point-numbers.rst:35
msgid "``UInt16``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:233
msgid "``int``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:233
msgid "``Cint``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:233
#: ../../manual/integers-and-floating-point-numbers.rst:36
msgid "``Int32``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:235
msgid "``unsigned int``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:235
msgid "``Cuint``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:235
#: ../../manual/integers-and-floating-point-numbers.rst:37
msgid "``UInt32``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:237
msgid "``long long``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:237
msgid "``Clonglong``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:237
#: ../../manual/calling-c-and-fortran-code.rst:241
#: ../../manual/integers-and-floating-point-numbers.rst:38
msgid "``Int64``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:239
msgid "``unsigned long long``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:239
msgid "``Culonglong``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:239
#: ../../manual/calling-c-and-fortran-code.rst:243
#: ../../manual/integers-and-floating-point-numbers.rst:39
msgid "``UInt64``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:241
msgid "``intmax_t``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:241
msgid "``Cintmax_t``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:243
msgid "``uintmax_t``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:243
msgid "``Cuintmax_t``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:245
msgid "``float``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:245
msgid "``Cfloat``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:245
#: ../../manual/integers-and-floating-point-numbers.rst:51
#: ../../manual/integers-and-floating-point-numbers.rst:357
msgid "``Float32``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:247
msgid "``double``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:247
msgid "``Cdouble``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:247
#: ../../manual/integers-and-floating-point-numbers.rst:52
#: ../../manual/integers-and-floating-point-numbers.rst:357
msgid "``Float64``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:249
msgid "``ptrdiff_t``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:249
msgid "``Cptrdiff_t``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:249
#: ../../manual/calling-c-and-fortran-code.rst:251
msgid "``Int``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:251
msgid "``ssize_t``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:251
msgid "``Cssize_t``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:253
msgid "``size_t``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:253
msgid "``Csize_t``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:253
msgid "``UInt``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:255
msgid "``void``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:255
msgid "``Void``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:257
msgid "``void*``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:257
msgid "``Ptr{Void}``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:259
msgid "``char*`` (or ``char[]``, e.g. a string)"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:259
msgid "``Ptr{UInt8}``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:261
msgid "``char**`` (or ``*char[]``)"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:261
msgid "``Ptr{Ptr{UInt8}}``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:263
msgid "``struct T*`` (where T represents an appropriately defined bits type)"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:263
msgid "``Ptr{T}`` (call using &variable_name in the parameter list)"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:267
msgid "``struct T`` (where T represents  an appropriately defined bits type)"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:267
msgid "``T`` (call using &variable_name in the parameter list)"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:271
msgid "``jl_value_t*`` (any Julia Type)"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:271
msgid "``Ptr{Any}``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:274
msgid ""
"Julia's ``Char`` type is 32 bits, which is not the same as the wide "
"character type (``wchar_t`` or ``wint_t``) on all platforms."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:277
msgid ""
"A C function declared to return ``void`` will give ``nothing`` in Julia."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:279
msgid "**System-dependent:**"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:282
msgid "``char``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:282
msgid "``Cchar``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:282
msgid "``Int8`` (x86, x86_64)"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:284
msgid "``UInt8`` (powerpc, arm)"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:285
msgid "``long``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:285
msgid "``Clong``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:285
msgid "``Int`` (UNIX)"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:287
msgid "``Int32`` (Windows)"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:288
msgid "``unsigned long``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:288
msgid "``Culong``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:288
msgid "``UInt`` (UNIX)"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:290
msgid "``UInt32`` (Windows)"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:291
msgid "``wchar_t``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:291
msgid "``Cwchar_t``"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:291
msgid "``Int32`` (UNIX)"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:293
msgid "``UInt16`` (Windows)"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:296
msgid ""
"For string arguments (``char*``) the Julia type should be ``Ptr{UInt8}``, "
"not ``ASCIIString``. C functions that take an argument of the type "
"``char**`` can be called by using a ``Ptr{Ptr{UInt8}}`` type within Julia. "
"For example, C functions of the form::"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:303
msgid "can be called via the following Julia code::"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:308
msgid ""
"For ``wchar_t*`` arguments, the Julia type should be ``Ptr{Wchar_t}``, and "
"data can be converted to/from ordinary Julia strings by the ``wstring(s)`` "
"function (equivalent to either ``utf16(s)`` or ``utf32(s)`` depending upon "
"the width of ``Cwchar_t``.    Note also that ASCII, UTF-8, UTF-16, and "
"UTF-32 string data in Julia is internally NUL-terminated, so it can be "
"passed to C functions expecting NUL-terminated data without making a copy."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:317
msgid "Accessing Data through a Pointer"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:318
msgid ""
"The following methods are described as \"unsafe\" because they can cause "
"Julia to terminate abruptly or corrupt arbitrary process memory due to a bad"
" pointer or type declaration."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:322
msgid ""
"Given a ``Ptr{T}``, the contents of type ``T`` can generally be copied from "
"the referenced memory into a Julia object using ``unsafe_load(ptr, "
"[index])``. The index argument is optional (default is 1), and performs "
"1-based indexing. This function is intentionally similar to the behavior of "
"``getindex()`` and ``setindex!()`` (e.g. ``[]`` access syntax)."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:328
msgid ""
"The return value will be a new object initialized to contain a copy of the "
"contents of the referenced memory. The referenced memory can safely be freed"
" or released."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:332
msgid ""
"If ``T`` is ``Any``, then the memory is assumed to contain a reference to a "
"Julia object (a ``jl_value_t*``), the result will be a reference to this "
"object, and the object will not be copied. You must be careful in this case "
"to ensure that the object was always visible to the garbage collector "
"(pointers do not count, but the new reference does) to ensure the memory is "
"not prematurely freed. Note that if the object was not originally allocated "
"by Julia, the new object will never be finalized by Julia's garbage "
"collector.  If the ``Ptr`` itself is actually a ``jl_value_t*``, it can be "
"converted back to a Julia object reference by "
"``unsafe_pointer_to_objref(ptr)``.  (Julia values ``v`` can be converted to "
"``jl_value_t*`` pointers, as ``Ptr{Void}``, by calling "
"``pointer_from_objref(v)``.)"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:344
msgid ""
"The reverse operation (writing data to a Ptr{T}), can be performed using "
"``unsafe_store!(ptr, value, [index])``.  Currently, this is only supported "
"for bitstypes or other pointer-free (``isbits``) immutable types."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:348
msgid ""
"Any operation that throws an error is probably currently unimplemented and "
"should be posted as a bug so that it can be resolved."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:351
msgid ""
"If the pointer of interest is a plain-data array (bitstype or immutable), "
"the function ``pointer_to_array(ptr,dims,[own])`` may be more useful. The "
"final parameter should be true if Julia should \"take ownership\" of the "
"underlying buffer and call ``free(ptr)`` when the returned ``Array`` object "
"is finalized. If the ``own`` parameter is omitted or false, the caller must "
"ensure the buffer remains in existence until all access is complete."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:358
msgid ""
"Arithmetic on the ``Ptr`` type in Julia (e.g. using ``+``) does not behave "
"the same as C's pointer arithmetic. Adding an integer to a ``Ptr`` in Julia "
"always moves the pointer by some number of *bytes*, not elements. This way, "
"the address values obtained from pointer arithmetic do not depend on the "
"element types of pointers."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:365
msgid "Passing Pointers for Modifying Inputs"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:367
msgid ""
"Because C doesn't support multiple return values, often C functions will "
"take pointers to data that the function will modify. To accomplish this "
"within a ``ccall`` you need to encapsulate the value inside an array of the "
"appropriate type. When you pass the array as an argument with a ``Ptr`` "
"type, julia will automatically pass a C pointer to the encapsulated data::"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:377
msgid ""
"This is used extensively in Julia's LAPACK interface, where an integer "
"``info`` is passed to LAPACK by reference, and on return, includes the "
"success code."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:381
msgid "Garbage Collection Safety"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:382
msgid ""
"When passing data to a ccall, it is best to avoid using the ``pointer()`` "
"function. Instead define a convert method and pass the variables directly to"
" the ccall. ccall automatically arranges that all of its arguments will be "
"preserved from garbage collection until the call returns. If a C API will "
"store a reference to memory allocated by Julia, after the ccall returns, you"
" must arrange that the object remains visible to the garbage collector. The "
"suggested way to handle this is to make a global variable of type "
"``Array{Any,1}`` to hold these values, until C interface notifies you that "
"it is finished with them."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:392
msgid ""
"Whenever you have created a pointer to Julia data, you must ensure the "
"original data exists until you are done with using the pointer. Many methods"
" in Julia such as ``unsafe_load()`` and ``bytestring()`` make copies of data"
" instead of taking ownership of the buffer, so that it is safe to free (or "
"alter) the original data without affecting Julia. A notable exception is "
"``pointer_to_array()`` which, for performance reasons, shares (or can be "
"told to take ownership of) the underlying buffer."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:399
msgid ""
"The garbage collector does not guarantee any order of finalization. That is,"
" if ``a`` contained a reference to ``b`` and both ``a`` and ``b`` are due "
"for garbage collection, there is no guarantee that ``b`` would be finalized "
"after ``a``. If proper finalization of ``a`` depends on ``b`` being valid, "
"it must be handled in other ways."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:407
msgid "Non-constant Function Specifications"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:409
msgid ""
"A ``(name, library)`` function specification must be a constant expression. "
"However, it is possible to use computed values as function names by staging "
"through ``eval`` as follows::"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:415
msgid ""
"This expression constructs a name using ``string``, then substitutes this "
"name into a new ``ccall`` expression, which is then evaluated. Keep in mind "
"that ``eval`` only operates at the top level, so within this expression "
"local variables will not be available (unless their values are substituted "
"with ``$``). For this reason, ``eval`` is typically only used to form top-"
"level definitions, for example when wrapping libraries that contain many "
"similar functions."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:424
msgid "Indirect Calls"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:426
msgid ""
"The first argument to ``ccall`` can also be an expression evaluated at run "
"time. In this case, the expression must evaluate to a ``Ptr``, which will be"
" used as the address of the native function to call. This behavior occurs "
"when the first ``ccall`` argument contains references to non-constants, such"
" as local variables or function arguments."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:433
msgid "Calling Convention"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:435
msgid ""
"The second argument to ``ccall`` can optionally be a calling convention "
"specifier (immediately preceding return type). Without any specifier, the "
"platform-default C calling convention is used. Other supported conventions "
"are: ``stdcall``, ``cdecl``, ``fastcall``, and ``thiscall``. For example "
"(from base/libc.jl)::"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:444
msgid "For more information, please see the `LLVM Language Reference`_."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:449
msgid "Accessing Global Variables"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:451
msgid ""
"Global variables exported by native libraries can be accessed by name using "
"the ``cglobal`` function. The arguments to ``cglobal`` are a symbol "
"specification identical to that used by ``ccall``, and a type describing the"
" value stored in the variable::"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:459
msgid ""
"The result is a pointer giving the address of the value. The value can be "
"manipulated through this pointer using ``unsafe_load`` and ``unsafe_store``."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:463
msgid "Passing Julia Callback Functions to C"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:465
msgid ""
"It is possible to pass Julia functions to native functions that accept "
"function pointer arguments. A classic example is the standard C library "
"``qsort`` function, declared as::"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:472
msgid ""
"The ``base`` argument is a pointer to an array of length ``nmemb``, with "
"elements of ``size`` bytes each. ``compare`` is a callback function which "
"takes pointers to two elements ``a`` and ``b`` and returns an integer "
"less/greater than zero if ``a`` should appear before/after ``b`` (or zero if"
" any order is permitted). Now, suppose that we have a 1d array ``A`` of "
"values in Julia that we want to sort using the ``qsort`` function (rather "
"than Julia’s built-in sort function). Before we worry about calling "
"``qsort`` and passing arguments, we need to write a comparison function that"
" works for some arbitrary type T::"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:487
msgid ""
"Notice that we have to be careful about the return type: ``qsort`` expects a"
" function returning a C ``int``, so we must be sure to return ``Cint`` via a"
" call to ``convert``."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:490
msgid ""
"In order to pass this function to C, we obtain its address using the "
"function ``cfunction``::"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:495
msgid ""
"``cfunction`` accepts three arguments: the Julia function (``mycompare``), "
"the return type (``Cint``), and a tuple of the argument types, in this case "
"to sort an array of ``Cdouble`` (Float64) elements."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:499
msgid "The final call to ``qsort`` looks like this::"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:505
msgid ""
"After this executes, ``A`` is changed to the sorted array ``[ -2.7, 1.3, "
"3.1, 4.4]``. Note that Julia knows how to convert an array into a "
"``Ptr{Cdouble}``, how to compute the size of a type in bytes (identical to "
"C’s ``sizeof`` operator), and so on. For fun, try inserting a "
"``println(\"mycompare($a,$b)\")`` line into ``mycompare``, which will allow "
"you to see the comparisons that ``qsort`` is performing (and to verify that "
"it is really calling the Julia function that you passed to it)."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:513
msgid "Thread-safety"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:515
msgid ""
"Some C libraries execute their callbacks from a different thread, and since "
"Julia isn't thread-safe you'll need to take some extra precautions. In "
"particular, you'll need to set up a two-layered system: the C callback "
"should only *schedule* (via Julia's event loop) the execution of your "
"\"real\" callback. To do this, you pass a function of one argument (the "
"``AsyncWork`` object for which the event was triggered, which you'll "
"probably just ignore) to ``SingleAsyncWork``::"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:525
msgid ""
"The callback you pass to C should only execute a ``ccall`` to "
"``:uv_async_send``, passing ``cb.handle`` as the argument."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:529
msgid "More About Callbacks"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:531
msgid ""
"For more details on how to pass callbacks to C libraries, see this `blog "
"post <http://julialang.org/blog/2013/05/callback/>`_."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:535
msgid "C++"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:537
msgid ""
"Limited support for C++ is provided by the `Cpp "
"<https://github.com/timholy/Cpp.jl>`_ and `Clang "
"<https://github.com/ihnorton/Clang.jl>`_ packages."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:541
msgid "Handling Platform Variations"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:543
msgid ""
"When dealing with platform libraries, it is often necessary to provide "
"special cases for various platforms. The variable ``OS_NAME`` can be used to"
" write these special cases. Additionally, there are several macros intended "
"to make this easier: ``@windows``, ``@unix``, ``@linux``, and ``@osx``. Note"
" that linux and osx are mutually exclusive subsets of unix. Their usage "
"takes the form of a ternary conditional operator, as demonstrated in the "
"following examples."
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:550
msgid "Simple blocks::"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:554
msgid "Complex blocks::"
msgstr ""

#: ../../manual/calling-c-and-fortran-code.rst:565
msgid "Chaining (parentheses optional, but recommended for readability)::"
msgstr ""

#: ../../manual/complex-and-rational-numbers.rst:5
msgid "Complex and Rational Numbers"
msgstr ""

#: ../../manual/complex-and-rational-numbers.rst:7
msgid ""
"Julia ships with predefined types representing both complex and rational "
"numbers, and supports all :ref:`standard mathematical operations <man-"
"mathematical-operations>` on them. :ref:`man-conversion-and-promotion` are "
"defined so that operations on any combination of predefined numeric types, "
"whether primitive or composite, behave as expected."
msgstr ""

#: ../../manual/complex-and-rational-numbers.rst:17
msgid "Complex Numbers"
msgstr ""

#: ../../manual/complex-and-rational-numbers.rst:19
msgid ""
"The global constant ``im`` is bound to the complex number *i*, representing "
"the principal square root of -1. It was deemed harmful to co-opt the name "
"``i`` for a global constant, since it is such a popular index variable name."
" Since Julia allows numeric literals to be :ref:`juxtaposed with identifiers"
" as coefficients <man-numeric-literal-coefficients>`, this binding suffices "
"to provide convenient syntax for complex numbers, similar to the traditional"
" mathematical notation:"
msgstr ""

#: ../../manual/complex-and-rational-numbers.rst:33
msgid ""
"You can perform all the standard arithmetic operations with complex numbers:"
msgstr ""

#: ../../manual/complex-and-rational-numbers.rst:68
msgid ""
"The promotion mechanism ensures that combinations of operands of different "
"types just work:"
msgstr ""

#: ../../manual/complex-and-rational-numbers.rst:100
msgid ""
"Note that ``3/4im == 3/(4*im) == -(3/4*im)``, since a literal coefficient "
"binds more tightly than division."
msgstr ""

#: ../../manual/complex-and-rational-numbers.rst:103
msgid "Standard functions to manipulate complex values are provided:"
msgstr ""

#: ../../manual/complex-and-rational-numbers.rst:125
msgid ""
"As usual, the absolute value (``abs``) of a complex number is its distance "
"from zero. The ``abs2`` function gives the square of the absolute value, and"
" is of particular use for complex numbers where it avoids taking a square "
"root. The ``angle`` function returns the phase angle in radians (also known "
"as the *argument* or *arg* function). The full gamut of other :ref:`man-"
"elementary-functions` is also defined for complex numbers:"
msgstr ""

#: ../../manual/complex-and-rational-numbers.rst:150
msgid ""
"Note that mathematical functions typically return real values when applied "
"to real numbers and complex values when applied to complex numbers. For "
"example, ``sqrt`` behaves differently when applied to ``-1`` versus ``-1 + "
"0im`` even though ``-1 == -1 + 0im``:"
msgstr ""

#: ../../manual/complex-and-rational-numbers.rst:166
msgid ""
"The :ref:`literal numeric coefficient notation <man-numeric-literal-"
"coefficients>` does not work when constructing complex number from "
"variables. Instead, the multiplication must be explicitly written out:"
msgstr ""

#: ../../manual/complex-and-rational-numbers.rst:175
msgid ""
"However, this is *not* recommended; Use the ``complex`` function instead to "
"construct a complex value directly from its real and imaginary parts.:"
msgstr ""

#: ../../manual/complex-and-rational-numbers.rst:183
msgid "This construction avoids the multiplication and addition operations."
msgstr ""

#: ../../manual/complex-and-rational-numbers.rst:185
msgid ""
"``Inf`` and ``NaN`` propagate through complex numbers in the real and "
"imaginary parts of a complex number as described in the :ref:`man-special-"
"floats` section:"
msgstr ""

#: ../../manual/complex-and-rational-numbers.rst:200
msgid "Rational Numbers"
msgstr ""

#: ../../manual/complex-and-rational-numbers.rst:202
msgid ""
"Julia has a rational number type to represent exact ratios of integers. "
"Rationals are constructed using the ``//`` operator:"
msgstr ""

#: ../../manual/complex-and-rational-numbers.rst:210
msgid ""
"If the numerator and denominator of a rational have common factors, they are"
" reduced to lowest terms such that the denominator is non-negative:"
msgstr ""

#: ../../manual/complex-and-rational-numbers.rst:227
msgid ""
"This normalized form for a ratio of integers is unique, so equality of "
"rational values can be tested by checking for equality of the numerator and "
"denominator. The standardized numerator and denominator of a rational value "
"can be extracted using the ``num`` and ``den`` functions:"
msgstr ""

#: ../../manual/complex-and-rational-numbers.rst:240
msgid ""
"Direct comparison of the numerator and denominator is generally not "
"necessary, since the standard arithmetic and comparison operations are "
"defined for rational values:"
msgstr ""

#: ../../manual/complex-and-rational-numbers.rst:270
msgid "Rationals can be easily converted to floating-point numbers:"
msgstr ""

#: ../../manual/complex-and-rational-numbers.rst:277
msgid ""
"Conversion from rational to floating-point respects the following identity "
"for any integral values of ``a`` and ``b``, with the exception of the case "
"``a == 0`` and ``b == 0``:"
msgstr ""

#: ../../manual/complex-and-rational-numbers.rst:286
msgid "Constructing infinite rational values is acceptable:"
msgstr ""

#: ../../manual/complex-and-rational-numbers.rst:299
msgid "Trying to construct a ``NaN`` rational value, however, is not:"
msgstr ""

#: ../../manual/complex-and-rational-numbers.rst:308
msgid ""
"As usual, the promotion system makes interactions with other numeric types "
"effortless:"
msgstr ""

#: ../../manual/constructors.rst:5 ../../manual/dates.rst:14
msgid "Constructors"
msgstr ""

#: ../../manual/constructors.rst:7
msgid ""
"Constructors [#]_ are functions that create new objects — specifically, "
"instances of :ref:`man-composite-types`. In Julia, type objects also serve "
"as constructor functions: they create new instances of themselves when "
"applied to an argument tuple as a function. This much was already mentioned "
"briefly when composite types were introduced. For example::"
msgstr ""

#: ../../manual/constructors.rst:28
msgid ""
"For many types, forming new objects by binding their field values together "
"is all that is ever needed to create instances. There are, however, cases "
"where more functionality is required when creating composite objects. "
"Sometimes invariants must be enforced, either by checking arguments or by "
"transforming them. `Recursive data structures "
"<http://en.wikipedia.org/wiki/Recursion_%28computer_science%29#Recursive_data_structures_.28structural_recursion.29>`_,"
" especially those that may be self-referential, often cannot be constructed "
"cleanly without first being created in an incomplete state and then altered "
"programmatically to be made whole, as a separate step from object creation. "
"Sometimes, it's just convenient to be able to construct objects with fewer "
"or different types of parameters than they have fields. Julia's system for "
"object construction addresses all of these cases and more."
msgstr ""

#: ../../manual/constructors.rst:42
msgid ""
"Nomenclature: while the term “constructor” generally refers to the entire "
"function which constructs objects of a type, it is common to abuse "
"terminology slightly and refer to specific constructor methods as "
"“constructors”. In such situations, it is generally clear from context that "
"the term is used to mean “constructor method” rather than “constructor "
"function”, especially as it is often used in the sense of singling out a "
"particular method of the constructor from all of the others."
msgstr ""

#: ../../manual/constructors.rst:52
msgid "Outer Constructor Methods"
msgstr ""

#: ../../manual/constructors.rst:54
msgid ""
"A constructor is just like any other function in Julia in that its overall "
"behavior is defined by the combined behavior of its methods. Accordingly, "
"you can add functionality to a constructor by simply defining new methods. "
"For example, let's say you want to add a constructor method for ``Foo`` "
"objects that takes only one argument and uses the given value for both the "
"``bar`` and ``baz`` fields. This is simple::"
msgstr ""

#: ../../manual/constructors.rst:67
msgid ""
"You could also add a zero-argument ``Foo`` constructor method that supplies "
"default values for both of the ``bar`` and ``baz`` fields::"
msgstr ""

#: ../../manual/constructors.rst:75
msgid ""
"Here the zero-argument constructor method calls the single-argument "
"constructor method, which in turn calls the automatically provided two-"
"argument constructor method. For reasons that will become clear very "
"shortly, additional constructor methods declared as normal methods like this"
" are called *outer* constructor methods. Outer constructor methods can only "
"ever create a new instance by calling another constructor method, such as "
"the automatically provided default ones."
msgstr ""

#: ../../manual/constructors.rst:84
msgid "Inner Constructor Methods"
msgstr ""

#: ../../manual/constructors.rst:86
msgid ""
"While outer constructor methods succeed in addressing the problem of "
"providing additional convenience methods for constructing objects, they fail"
" to address the other two use cases mentioned in the introduction of this "
"chapter: enforcing invariants, and allowing construction of self-referential"
" objects. For these problems, one needs *inner* constructor methods. An "
"inner constructor method is much like an outer constructor method, with two "
"differences:"
msgstr ""

#: ../../manual/constructors.rst:94
msgid ""
"It is declared inside the block of a type declaration, rather than outside "
"of it like normal methods."
msgstr ""

#: ../../manual/constructors.rst:96
msgid ""
"It has access to a special locally existent function called ``new`` that "
"creates objects of the block's type."
msgstr ""

#: ../../manual/constructors.rst:99
msgid ""
"For example, suppose one wants to declare a type that holds a pair of real "
"numbers, subject to the constraint that the first number is not greater than"
" the second one. One could declare it like this:"
msgstr ""

#: ../../manual/constructors.rst:112
msgid ""
"Now ``OrderedPair`` objects can only be constructed such that ``x <= y``:"
msgstr ""

#: ../../manual/constructors.rst:124
msgid ""
"You can still reach in and directly change the field values to violate this "
"invariant, but messing around with an object's internals uninvited is "
"considered poor form. You (or someone else) can also provide additional "
"outer constructor methods at any later point, but once a type is declared, "
"there is no way to add more inner constructor methods. Since outer "
"constructor methods can only create objects by calling other constructor "
"methods, ultimately, some inner constructor must be called to create an "
"object. This guarantees that all objects of the declared type must come into"
" existence by a call to one of the inner constructor methods provided with "
"the type, thereby giving some degree of enforcement of a type's invariants."
msgstr ""

#: ../../manual/constructors.rst:136
msgid ""
"Of course, if the type is declared as ``immutable``, then its constructor-"
"provided invariants are fully enforced. This is an important consideration "
"when deciding whether a type should be immutable."
msgstr ""

#: ../../manual/constructors.rst:140
msgid ""
"If any inner constructor method is defined, no default constructor method is"
" provided: it is presumed that you have supplied yourself with all the inner"
" constructors you need. The default constructor is equivalent to writing "
"your own inner constructor method that takes all of the object's fields as "
"parameters (constrained to be of the correct type, if the corresponding "
"field has a type), and passes them to ``new``, returning the resulting "
"object::"
msgstr ""

#: ../../manual/constructors.rst:155
msgid ""
"This declaration has the same effect as the earlier definition of the "
"``Foo`` type without an explicit inner constructor method. The following two"
" types are equivalent — one with a default constructor, the other with an "
"explicit constructor::"
msgstr ""

#: ../../manual/constructors.rst:181
msgid ""
"It is considered good form to provide as few inner constructor methods as "
"possible: only those taking all arguments explicitly and enforcing essential"
" error checking and transformation. Additional convenience constructor "
"methods, supplying default values or auxiliary transformations, should be "
"provided as outer constructors that call the inner constructors to do the "
"heavy lifting. This separation is typically quite natural."
msgstr ""

#: ../../manual/constructors.rst:190
msgid "Incomplete Initialization"
msgstr ""

#: ../../manual/constructors.rst:192
msgid ""
"The final problem which has still not been addressed is construction of "
"self-referential objects, or more generally, recursive data structures. "
"Since the fundamental difficulty may not be immediately obvious, let us "
"briefly explain it. Consider the following recursive type declaration::"
msgstr ""

#: ../../manual/constructors.rst:201
msgid ""
"This type may appear innocuous enough, until one considers how to construct "
"an instance of it. If ``a`` is an instance of ``SelfReferential``, then a "
"second instance can be created by the call::"
msgstr ""

#: ../../manual/constructors.rst:207
msgid ""
"But how does one construct the first instance when no instance exists to "
"provide as a valid value for its ``obj`` field? The only solution is to "
"allow creating an incompletely initialized instance of ``SelfReferential`` "
"with an unassigned ``obj`` field, and using that incomplete instance as a "
"valid value for the ``obj`` field of another instance, such as, for example,"
" itself."
msgstr ""

#: ../../manual/constructors.rst:214
msgid ""
"To allow for the creation of incompletely initialized objects, Julia allows "
"the ``new`` function to be called with fewer than the number of fields that "
"the type has, returning an object with the unspecified fields uninitialized."
" The inner constructor method can then use the incomplete object, finishing "
"its initialization before returning it. Here, for example, we take another "
"crack at defining the ``SelfReferential`` type, with a zero-argument inner "
"constructor returning instances having ``obj`` fields pointing to "
"themselves:"
msgstr ""

#: ../../manual/constructors.rst:231
msgid ""
"We can verify that this constructor works and constructs objects that are, "
"in fact, self-referential:"
msgstr ""

#: ../../manual/constructors.rst:247
msgid ""
"Although it is generally a good idea to return a fully initialized object "
"from an inner constructor, incompletely initialized objects can be returned:"
msgstr ""

#: ../../manual/constructors.rst:260
msgid ""
"While you are allowed to create objects with uninitialized fields, any "
"access to an uninitialized reference is an immediate error:"
msgstr ""

#: ../../manual/constructors.rst:268
msgid ""
"This avoids the need to continually check for ``null`` values. However, not "
"all object fields are references. Julia considers some types to be \"plain "
"data\", meaning all of their data is self-contained and does not reference "
"other objects. The plain data types consist of bits types (e.g. ``Int``) and"
" immutable structs of other plain data types. The initial contents of a "
"plain data type is undefined::"
msgstr ""

#: ../../manual/constructors.rst:283
msgid "Arrays of plain data types exhibit the same behavior."
msgstr ""

#: ../../manual/constructors.rst:285
msgid ""
"You can pass incomplete objects to other functions from inner constructors "
"to delegate their completion::"
msgstr ""

#: ../../manual/constructors.rst:294
msgid ""
"As with incomplete objects returned from constructors, if ``complete_me`` or"
" any of its callees try to access the ``xx`` field of the ``Lazy`` object "
"before it has been initialized, an error will be thrown immediately."
msgstr ""

#: ../../manual/constructors.rst:300
msgid "Parametric Constructors"
msgstr ""

#: ../../manual/constructors.rst:302
msgid ""
"Parametric types add a few wrinkles to the constructor story. Recall from "
":ref:`man-parametric-types` that, by default, instances of parametric "
"composite types can be constructed either with explicitly given type "
"parameters or with type parameters implied by the types of the arguments "
"given to the constructor. Here are some examples:"
msgstr ""

#: ../../manual/constructors.rst:341
msgid ""
"As you can see, for constructor calls with explicit type parameters, the "
"arguments are converted to the implied field types: ``Point{Int64}(1,2)`` "
"works, but ``Point{Int64}(1.0,2.5)`` raises an ``InexactError`` when "
"converting ``2.5`` to ``Int64``. When the type is implied by the arguments "
"to the constructor call, as in ``Point(1,2)``, then the types of the "
"arguments must agree — otherwise the ``T`` cannot be determined — but any "
"pair of real arguments with matching type may be given to the generic "
"``Point`` constructor."
msgstr ""

#: ../../manual/constructors.rst:351
msgid ""
"What's really going on here is that ``Point``, ``Point{Float64}`` and "
"``Point{Int64}`` are all different constructor functions. In fact, "
"``Point{T}`` is a distinct constructor function for each type ``T``. Without"
" any explicitly provided inner constructors, the declaration of the "
"composite type ``Point{T<:Real}`` automatically provides an inner "
"constructor, ``Point{T}``, for each possible type ``T<:Real``, that behaves "
"just like non-parametric default inner constructors do. It also provides a "
"single general outer ``Point`` constructor that takes pairs of real "
"arguments, which must be of the same type. This automatic provision of "
"constructors is equivalent to the following explicit declaration::"
msgstr ""

#: ../../manual/constructors.rst:372
msgid ""
"Some features of parametric constructor definitions at work here deserve "
"comment. First, inner constructor declarations always define methods of "
"``Point{T}`` rather than methods of the general ``Point`` constructor "
"function. Since ``Point`` is not a concrete type, it makes no sense for it "
"to even have inner constructor methods at all. Thus, the inner method "
"declaration ``Point(x,y) = new(x,y)`` provides an inner constructor method "
"for each value of ``T``. It is this method declaration that defines the "
"behavior of constructor calls with explicit type parameters like "
"``Point{Int64}(1,2)`` and ``Point{Float64}(1.0,2.0)``. The outer constructor"
" declaration, on the other hand, defines a method for the general ``Point`` "
"constructor which only applies to pairs of values of the same real type. "
"This declaration makes constructor calls without explicit type parameters, "
"like ``Point(1,2)`` and ``Point(1.0,2.5)``, work. Since the method "
"declaration restricts the arguments to being of the same type, calls like "
"``Point(1,2.5)``, with arguments of different types, result in \"no method\""
" errors."
msgstr ""

#: ../../manual/constructors.rst:390
msgid ""
"Suppose we wanted to make the constructor call ``Point(1,2.5)`` work by "
"\"promoting\" the integer value ``1`` to the floating-point value ``1.0``. "
"The simplest way to achieve this is to define the following additional outer"
" constructor method:"
msgstr ""

#: ../../manual/constructors.rst:399
msgid ""
"This method uses the ``convert`` function to explicitly convert ``x`` to "
"``Float64`` and then delegates construction to the general constructor for "
"the case where both arguments are ``Float64``. With this method definition "
"what was previously a \"no method\" error now successfully creates a point "
"of type ``Point{Float64}``:"
msgstr ""

#: ../../manual/constructors.rst:413
msgid "However, other similar calls still don't work:"
msgstr ""

#: ../../manual/constructors.rst:420
msgid ""
"For a much more general way of making all such calls work sensibly, see :ref"
":`man-conversion-and-promotion`. At the risk of spoiling the suspense, we "
"can reveal here that all it takes is the following outer method definition "
"to make all calls to the general ``Point`` constructor work as one would "
"expect:"
msgstr ""

#: ../../manual/constructors.rst:430
msgid ""
"The ``promote`` function converts all its arguments to a common type — in "
"this case ``Float64``. With this method definition, the ``Point`` "
"constructor promotes its arguments the same way that numeric operators like "
"``+`` do, and works for all kinds of real numbers:"
msgstr ""

#: ../../manual/constructors.rst:446
msgid ""
"Thus, while the implicit type parameter constructors provided by default in "
"Julia are fairly strict, it is possible to make them behave in a more "
"relaxed but sensible manner quite easily. Moreover, since constructors can "
"leverage all of the power of the type system, methods, and multiple "
"dispatch, defining sophisticated behavior is typically quite simple."
msgstr ""

#: ../../manual/constructors.rst:453
msgid "Case Study: Rational"
msgstr ""

#: ../../manual/constructors.rst:455
msgid ""
"Perhaps the best way to tie all these pieces together is to present a real "
"world example of a parametric composite type and its constructor methods. To"
" that end, here is beginning of `rational.jl "
"<https://github.com/JuliaLang/julia/blob/master/base/rational.jl>`_, which "
"implements Julia's :ref:`man-rational-numbers`::"
msgstr ""

#: ../../manual/constructors.rst:491
msgid ""
"The first line — ``immutable Rational{T<:Int} <: Real`` — declares that "
"``Rational`` takes one type parameter of an integer type, and is itself a "
"real type. The field declarations ``num::T`` and ``den::T`` indicate that "
"the data held in a ``Rational{T}`` object are a pair of integers of type "
"``T``, one representing the rational value's numerator and the other "
"representing its denominator."
msgstr ""

#: ../../manual/constructors.rst:498
msgid ""
"Now things get interesting. ``Rational`` has a single inner constructor "
"method which checks that both of ``num`` and ``den`` aren't zero and ensures"
" that every rational is constructed in \"lowest terms\" with a non-negative "
"denominator. This is accomplished by dividing the given numerator and "
"denominator values by their greatest common divisor, computed using the "
"``gcd`` function. Since ``gcd`` returns the greatest common divisor of its "
"arguments with sign matching the first argument (``den`` here), after this "
"division the new value of ``den`` is guaranteed to be non-negative. Because "
"this is the only inner constructor for ``Rational``, we can be certain that "
"``Rational`` objects are always constructed in this normalized form."
msgstr ""

#: ../../manual/constructors.rst:510
msgid ""
"``Rational`` also provides several outer constructor methods for "
"convenience. The first is the \"standard\" general constructor that infers "
"the type parameter ``T`` from the type of the numerator and denominator when"
" they have the same type. The second applies when the given numerator and "
"denominator values have different types: it promotes them to a common type "
"and then delegates construction to the outer constructor for arguments of "
"matching type. The third outer constructor turns integer values into "
"rationals by supplying a value of ``1`` as the denominator."
msgstr ""

#: ../../manual/constructors.rst:520
msgid ""
"Following the outer constructor definitions, we have a number of methods for"
" the ``//`` operator, which provides a syntax for writing rationals. Before "
"these definitions, ``//`` is a completely undefined operator with only "
"syntax and no meaning. Afterwards, it behaves just as described in :ref"
":`man-rational-numbers` — its entire behavior is defined in these few lines."
" The first and most basic definition just makes ``a//b`` construct a "
"``Rational`` by applying the ``Rational`` constructor to ``a`` and ``b`` "
"when they are integers. When one of the operands of ``//`` is already a "
"rational number, we construct a new rational for the resulting ratio "
"slightly differently; this behavior is actually identical to division of a "
"rational with an integer. Finally, applying ``//`` to complex integral "
"values creates an instance of ``Complex{Rational}`` — a complex number whose"
" real and imaginary parts are rationals:"
msgstr ""

#: ../../manual/constructors.rst:546
msgid ""
"Thus, although the ``//`` operator usually returns an instance of "
"``Rational``, if either of its arguments are complex integers, it will "
"return an instance of ``Complex{Rational}`` instead. The interested reader "
"should consider perusing the rest of `rational.jl "
"<https://github.com/JuliaLang/julia/blob/master/base/rational.jl>`_: it is "
"short, self-contained, and implements an entire basic Julia type in just a "
"little over a hundred lines of code."
msgstr ""

#: ../../manual/control-flow.rst:5
msgid "Control Flow"
msgstr ""

#: ../../manual/control-flow.rst:7
msgid "Julia provides a variety of control flow constructs:"
msgstr ""

#: ../../manual/control-flow.rst:9
msgid ":ref:`man-compound-expressions`: ``begin`` and ``(;)``."
msgstr ""

#: ../../manual/control-flow.rst:10
msgid ""
":ref:`man-conditional-evaluation`: ``if``-``elseif``-``else`` and ``?:`` "
"(ternary operator)."
msgstr ""

#: ../../manual/control-flow.rst:12
msgid ""
":ref:`man-short-circuit-evaluation`: ``&&``, ``||`` and chained comparisons."
msgstr ""

#: ../../manual/control-flow.rst:14
msgid ":ref:`man-loops`: ``while`` and ``for``."
msgstr ""

#: ../../manual/control-flow.rst:15
msgid ""
":ref:`man-exception-handling`: ``try``-``catch``, ``error`` and ``throw``."
msgstr ""

#: ../../manual/control-flow.rst:17
msgid ":ref:`man-tasks`: ``yieldto``."
msgstr ""

#: ../../manual/control-flow.rst:19
msgid ""
"The first five control flow mechanisms are standard to high-level "
"programming languages. Tasks are not so standard: they provide non-local "
"control flow, making it possible to switch between temporarily-suspended "
"computations. This is a powerful construct: both exception handling and "
"cooperative multitasking are implemented in Julia using tasks. Everyday "
"programming requires no direct usage of tasks, but certain problems can be "
"solved much more easily by using tasks."
msgstr ""

#: ../../manual/control-flow.rst:30
msgid "Compound Expressions"
msgstr ""

#: ../../manual/control-flow.rst:32
msgid ""
"Sometimes it is convenient to have a single expression which evaluates "
"several subexpressions in order, returning the value of the last "
"subexpression as its value. There are two Julia constructs that accomplish "
"this: ``begin`` blocks and ``(;)`` chains. The value of both compound "
"expression constructs is that of the last subexpression. Here's an example "
"of a ``begin`` block:"
msgstr ""

#: ../../manual/control-flow.rst:48
msgid ""
"Since these are fairly small, simple expressions, they could easily be "
"placed onto a single line, which is where the ``(;)`` chain syntax comes in "
"handy:"
msgstr ""

#: ../../manual/control-flow.rst:57
msgid ""
"This syntax is particularly useful with the terse single-line function "
"definition form introduced in :ref:`man-functions`. Although it is typical, "
"there is no requirement that ``begin`` blocks be multiline or that ``(;)`` "
"chains be single-line:"
msgstr ""

#: ../../manual/control-flow.rst:75
msgid "Conditional Evaluation"
msgstr ""

#: ../../manual/control-flow.rst:77
msgid ""
"Conditional evaluation allows portions of code to be evaluated or not "
"evaluated depending on the value of a boolean expression. Here is the "
"anatomy of the ``if``-``elseif``-``else`` conditional syntax::"
msgstr ""

#: ../../manual/control-flow.rst:89
msgid ""
"If the condition expression ``x < y`` is ``true``, then the corresponding "
"block is evaluated; otherwise the condition expression ``x > y`` is "
"evaluated, and if it is ``true``, the corresponding block is evaluated; if "
"neither expression is true, the ``else`` block is evaluated. Here it is in "
"action:"
msgstr ""

#: ../../manual/control-flow.rst:116
msgid ""
"The ``elseif`` and ``else`` blocks are optional, and as many ``elseif`` "
"blocks as desired can be used. The condition expressions in the "
"``if``-``elseif``-``else`` construct are evaluated until the first one "
"evaluates to ``true``, after which the associated block is evaluated, and no"
" further condition expressions or blocks are evaluated."
msgstr ""

#: ../../manual/control-flow.rst:122
msgid ""
"Note that very short conditional statements (one-liners) are frequently "
"expressed using Short-Circuit Evaluation in Julia, as outlined in the next "
"section."
msgstr ""

#: ../../manual/control-flow.rst:125
msgid ""
"Unlike C, MATLAB, Perl, Python, and Ruby — but like Java, and a few other "
"stricter, typed languages — it is an error if the value of a conditional "
"expression is anything but ``true`` or ``false``:"
msgstr ""

#: ../../manual/control-flow.rst:136
msgid ""
"This error indicates that the conditional was of the wrong type: ``Int64`` "
"rather than the required ``Bool``."
msgstr ""

#: ../../manual/control-flow.rst:139
msgid ""
"The so-called \"ternary operator\", ``?:``, is closely related to the "
"``if``-``elseif``-``else`` syntax, but is used where a conditional choice "
"between single expression values is required, as opposed to conditional "
"execution of longer blocks of code. It gets its name from being the only "
"operator in most languages taking three operands::"
msgstr ""

#: ../../manual/control-flow.rst:147
msgid ""
"The expression ``a``, before the ``?``, is a condition expression, and the "
"ternary operation evaluates the expression ``b``, before the ``:``, if the "
"condition ``a`` is ``true`` or the expression ``c``, after the ``:``, if it "
"is ``false``."
msgstr ""

#: ../../manual/control-flow.rst:152
msgid ""
"The easiest way to understand this behavior is to see an example. In the "
"previous example, the ``println`` call is shared by all three branches: the "
"only real choice is which literal string to print. This could be written "
"more concisely using the ternary operator. For the sake of clarity, let's "
"try a two-way version first:"
msgstr ""

#: ../../manual/control-flow.rst:170
msgid ""
"If the expression ``x < y`` is true, the entire ternary operator expression "
"evaluates to the string ``\"less than\"`` and otherwise it evaluates to the "
"string ``\"not less than\"``. The original three-way example requires "
"chaining multiple uses of the ternary operator together:"
msgstr ""

#: ../../manual/control-flow.rst:191
msgid "To facilitate chaining, the operator associates from right to left."
msgstr ""

#: ../../manual/control-flow.rst:193
msgid ""
"It is significant that like ``if``-``elseif``-``else``, the expressions "
"before and after the ``:`` are only evaluated if the condition expression "
"evaluates to ``true`` or ``false``, respectively:"
msgstr ""

#: ../../manual/control-flow.rst:214
msgid "Short-Circuit Evaluation"
msgstr ""

#: ../../manual/control-flow.rst:216
msgid ""
"Short-circuit evaluation is quite similar to conditional evaluation. The "
"behavior is found in most imperative programming languages having the ``&&``"
" and ``||`` boolean operators: in a series of boolean expressions connected "
"by these operators, only the minimum number of expressions are evaluated as "
"are necessary to determine the final boolean value of the entire chain. "
"Explicitly, this means that:"
msgstr ""

#: ../../manual/control-flow.rst:223
msgid ""
"In the expression ``a && b``, the subexpression ``b`` is only evaluated if "
"``a`` evaluates to ``true``."
msgstr ""

#: ../../manual/control-flow.rst:225
msgid ""
"In the expression ``a || b``, the subexpression ``b`` is only evaluated if "
"``a`` evaluates to ``false``."
msgstr ""

#: ../../manual/control-flow.rst:228
msgid ""
"The reasoning is that ``a && b`` must be ``false`` if ``a`` is ``false``, "
"regardless of the value of ``b``, and likewise, the value of ``a || b`` must"
" be true if ``a`` is ``true``, regardless of the value of ``b``. Both ``&&``"
" and ``||`` associate to the right, but ``&&`` has higher precedence than "
"``||`` does. It's easy to experiment with this behavior:"
msgstr ""

#: ../../manual/control-flow.rst:279
msgid ""
"You can easily experiment in the same way with the associativity and "
"precedence of various combinations of ``&&`` and ``||`` operators."
msgstr ""

#: ../../manual/control-flow.rst:282
msgid ""
"This behavior is frequently used in Julia to form an alternative to very "
"short ``if`` statements. Instead of ``if <cond> <statement> end``, one can "
"write ``<cond> && <statement>`` (which could be read as: <cond> *and then* "
"<statement>). Similarly, instead of ``if ! <cond> <statement> end``, one can"
" write ``<cond> || <statement>`` (which could be read as: <cond> *or else* "
"<statement>)."
msgstr ""

#: ../../manual/control-flow.rst:288
msgid "For example, a recursive factorial routine could be defined like this:"
msgstr ""

#: ../../manual/control-flow.rst:310
msgid ""
"Boolean operations *without* short-circuit evaluation can be done with the "
"bitwise boolean operators introduced in :ref:`man-mathematical-operations`: "
"``&`` and ``|``. These are normal functions, which happen to support infix "
"operator syntax, but always evaluate their arguments:"
msgstr ""

#: ../../manual/control-flow.rst:327
msgid ""
"Just like condition expressions used in ``if``, ``elseif`` or the ternary "
"operator, the operands of ``&&`` or ``||`` must be boolean values (``true`` "
"or ``false``). Using a non-boolean value anywhere except for the last entry "
"in a conditional chain is an error:"
msgstr ""

#: ../../manual/control-flow.rst:337
msgid ""
"On the other hand, any type of expression can be used at the end of a "
"conditional chain. It will be evaluated and returned depending on the "
"preceding conditionals:"
msgstr ""

#: ../../manual/control-flow.rst:357
msgid "Repeated Evaluation: Loops"
msgstr ""

#: ../../manual/control-flow.rst:359
msgid ""
"There are two constructs for repeated evaluation of expressions: the "
"``while`` loop and the ``for`` loop. Here is an example of a ``while`` loop:"
msgstr ""

#: ../../manual/control-flow.rst:377
msgid ""
"The ``while`` loop evaluates the condition expression (``i <= 5`` in this "
"case), and as long it remains ``true``, keeps also evaluating the body of "
"the ``while`` loop. If the condition expression is ``false`` when the "
"``while`` loop is first reached, the body is never evaluated."
msgstr ""

#: ../../manual/control-flow.rst:382
msgid ""
"The ``for`` loop makes common repeated evaluation idioms easier to write. "
"Since counting up and down like the above ``while`` loop does is so common, "
"it can be expressed more concisely with a ``for`` loop:"
msgstr ""

#: ../../manual/control-flow.rst:397
msgid ""
"Here the ``1:5`` is a ``Range`` object, representing the sequence of numbers"
" 1, 2, 3, 4, 5. The ``for`` loop iterates through these values, assigning "
"each one in turn to the variable ``i``. One rather important distinction "
"between the previous ``while`` loop form and the ``for`` loop form is the "
"scope during which the variable is visible. If the variable ``i`` has not "
"been introduced in an other scope, in the ``for`` loop form, it is visible "
"only inside of the ``for`` loop, and not afterwards. You'll either need a "
"new interactive session instance or a different variable name to test this:"
msgstr ""

#: ../../manual/control-flow.rst:421
msgid ""
"See :ref:`man-variables-and-scoping` for a detailed explanation of variable "
"scope and how it works in Julia."
msgstr ""

#: ../../manual/control-flow.rst:424
msgid ""
"In general, the ``for`` loop construct can iterate over any container. In "
"these cases, the alternative (but fully equivalent) keyword ``in`` is "
"typically used instead of ``=``, since it makes the code read more clearly:"
msgstr ""

#: ../../manual/control-flow.rst:445
msgid ""
"Various types of iterable containers will be introduced and discussed in "
"later sections of the manual (see, e.g., :ref:`man-arrays`)."
msgstr ""

#: ../../manual/control-flow.rst:448
msgid ""
"It is sometimes convenient to terminate the repetition of a ``while`` before"
" the test condition is falsified or stop iterating in a ``for`` loop before "
"the end of the iterable object is reached. This can be accomplished with the"
" ``break`` keyword:"
msgstr ""

#: ../../manual/control-flow.rst:482
msgid ""
"The above ``while`` loop would never terminate on its own, and the ``for`` "
"loop would iterate up to 1000. These loops are both exited early by using "
"the ``break`` keyword."
msgstr ""

#: ../../manual/control-flow.rst:486
msgid ""
"In other circumstances, it is handy to be able to stop an iteration and move"
" on to the next one immediately. The ``continue`` keyword accomplishes this:"
msgstr ""

#: ../../manual/control-flow.rst:502
msgid ""
"This is a somewhat contrived example since we could produce the same "
"behavior more clearly by negating the condition and placing the ``println`` "
"call inside the ``if`` block. In realistic usage there is more code to be "
"evaluated after the ``continue``, and often there are multiple points from "
"which one calls ``continue``."
msgstr ""

#: ../../manual/control-flow.rst:508
msgid ""
"Multiple nested ``for`` loops can be combined into a single outer loop, "
"forming the cartesian product of its iterables:"
msgstr ""

#: ../../manual/control-flow.rst:521
msgid ""
"A ``break`` statement inside such a loop exits the entire nest of loops, not"
" just the inner one."
msgstr ""

#: ../../manual/control-flow.rst:527
msgid "Exception Handling"
msgstr ""

#: ../../manual/control-flow.rst:529
msgid ""
"When an unexpected condition occurs, a function may be unable to return a "
"reasonable value to its caller. In such cases, it may be best for the "
"exceptional condition to either terminate the program, printing a diagnostic"
" error message, or if the programmer has provided code to handle such "
"exceptional circumstances, allow that code to take the appropriate action."
msgstr ""

#: ../../manual/control-flow.rst:537
msgid "Built-in ``Exception``\\ s"
msgstr ""

#: ../../manual/control-flow.rst:539
msgid ""
"``Exception``\\ s are thrown when an unexpected condition has occurred. The "
"built-in ``Exception``\\ s listed below all interrupt the normal flow of "
"control."
msgstr ""

#: ../../manual/control-flow.rst:543
msgid "``Exception``"
msgstr ""

#: ../../manual/control-flow.rst:545
msgid "``ArgumentError``"
msgstr ""

#: ../../manual/control-flow.rst:547
msgid "``BoundsError``"
msgstr ""

#: ../../manual/control-flow.rst:549
msgid "``DivideError``"
msgstr ""

#: ../../manual/control-flow.rst:551
msgid "``DomainError``"
msgstr ""

#: ../../manual/control-flow.rst:553
msgid "``EOFError``"
msgstr ""

#: ../../manual/control-flow.rst:555
msgid "``ErrorException``"
msgstr ""

#: ../../manual/control-flow.rst:557
msgid "``InexactError``"
msgstr ""

#: ../../manual/control-flow.rst:559
msgid "``InterruptException``"
msgstr ""

#: ../../manual/control-flow.rst:561
msgid "``KeyError``"
msgstr ""

#: ../../manual/control-flow.rst:563
msgid "``LoadError``"
msgstr ""

#: ../../manual/control-flow.rst:565
msgid "``MemoryError``"
msgstr ""

#: ../../manual/control-flow.rst:567
msgid "``MethodError``"
msgstr ""

#: ../../manual/control-flow.rst:569
msgid "``OverflowError``"
msgstr ""

#: ../../manual/control-flow.rst:571
msgid "``ParseError``"
msgstr ""

#: ../../manual/control-flow.rst:573
msgid "``SystemError``"
msgstr ""

#: ../../manual/control-flow.rst:575
msgid "``TypeError``"
msgstr ""

#: ../../manual/control-flow.rst:577
msgid "``UndefRefError``"
msgstr ""

#: ../../manual/control-flow.rst:579
msgid "``UndefVarError``"
msgstr ""

#: ../../manual/control-flow.rst:582
msgid ""
"For example, the ``sqrt`` function throws a ``DomainError()`` if applied to "
"a negative real value:"
msgstr ""

#: ../../manual/control-flow.rst:593
msgid "You may define your own exceptions in the following way:"
msgstr ""

#: ../../manual/control-flow.rst:600
msgid "The ``throw`` function"
msgstr ""

#: ../../manual/control-flow.rst:602
msgid ""
"Exceptions can be created explicitly with ``throw``. For example, a function"
" defined only for nonnegative numbers could be written to ``throw`` a "
"``DomainError`` if the argument is negative:"
msgstr ""

#: ../../manual/control-flow.rst:618
msgid ""
"Note that ``DomainError`` without parentheses is not an exception, but a "
"type of exception. It needs to be called to obtain an ``Exception`` object:"
msgstr ""

#: ../../manual/control-flow.rst:629
msgid ""
"Additionally, some exception types take one or more arguments that are used "
"for error reporting:"
msgstr ""

#: ../../manual/control-flow.rst:637
msgid ""
"This mechanism can be implemented easily by custom exception types following"
" the way ``UndefVarError`` is written:"
msgstr ""

#: ../../manual/control-flow.rst:648
msgid "Errors"
msgstr ""

#: ../../manual/control-flow.rst:650
msgid ""
"The ``error`` function is used to produce an ``ErrorException`` that "
"interrupts the normal flow of control."
msgstr ""

#: ../../manual/control-flow.rst:653
msgid ""
"Suppose we want to stop execution immediately if the square root of a "
"negative number is taken. To do this, we can define a fussy version of the "
"``sqrt`` function that raises an error if its argument is negative:"
msgstr ""

#: ../../manual/control-flow.rst:669
msgid ""
"If ``fussy_sqrt`` is called with a negative value from another function, "
"instead of trying to continue execution of the calling function, it returns "
"immediately, displaying the error message in the interactive session:"
msgstr ""

#: ../../manual/control-flow.rst:695
msgid "Warnings and informational messages"
msgstr ""

#: ../../manual/control-flow.rst:697
msgid ""
"Julia also provides other functions that write messages to the standard "
"error I/O, but do not throw any ``Exception``\\ s and hence do not interrupt"
" execution.:"
msgstr ""

#: ../../manual/control-flow.rst:717
msgid "The ``try/catch`` statement"
msgstr ""

#: ../../manual/control-flow.rst:719
msgid ""
"The ``try/catch`` statement allows for ``Exception``\\ s to be tested for. "
"For example, a customized square root function can be written to "
"automatically call either the real or complex square root method on demand "
"using ``Exception``\\ s :"
msgstr ""

#: ../../manual/control-flow.rst:739
msgid ""
"It is important to note that in real code computing this function, one would"
" compare ``x`` to zero instead of catching an exception. The exception is "
"much slower than simply comparing and branching."
msgstr ""

#: ../../manual/control-flow.rst:743
msgid ""
"``try/catch`` statements also allow the ``Exception`` to be saved in a "
"variable. In this contrived example, the following example calculates the "
"square root of the second element of ``x`` if ``x`` is indexable, otherwise "
"assumes ``x`` is a real number and returns its square root:"
msgstr ""

#: ../../manual/control-flow.rst:774
msgid ""
"Note that the symbol following ``catch`` will always be interpreted as a "
"name for the exception, so care is needed when writing ``try/catch`` "
"expressions on a single line. The following code will *not* work to return "
"the value of ``x`` in case of an error::"
msgstr ""

#: ../../manual/control-flow.rst:781
msgid "Instead, use a semicolon or insert a line break after ``catch``::"
msgstr ""

#: ../../manual/control-flow.rst:790
msgid ""
"The power of the ``try/catch`` construct lies in the ability to unwind a "
"deeply nested computation immediately to a much higher level in the stack of"
" calling functions. There are situations where no error has occurred, but "
"the ability to unwind the stack and pass a value to a higher level is "
"desirable. Julia provides the ``rethrow``, ``backtrace`` and "
"``catch_backtrace`` functions for more advanced error handling."
msgstr ""

#: ../../manual/control-flow.rst:798
msgid "finally Clauses"
msgstr ""

#: ../../manual/control-flow.rst:800
msgid ""
"In code that performs state changes or uses resources like files, there is "
"typically clean-up work (such as closing files) that needs to be done when "
"the code is finished. Exceptions potentially complicate this task, since "
"they can cause a block of code to exit before reaching its normal end. The "
"``finally`` keyword provides a way to run some code when a given block of "
"code exits, regardless of how it exits."
msgstr ""

#: ../../manual/control-flow.rst:807
msgid ""
"For example, here is how we can guarantee that an opened file is closed::"
msgstr ""

#: ../../manual/control-flow.rst:816
msgid ""
"When control leaves the ``try`` block (for example due to a ``return``, or "
"just finishing normally), ``close(f)`` will be executed. If the ``try`` "
"block exits due to an exception, the exception will continue propagating. A "
"``catch`` block may be combined with ``try`` and ``finally`` as well. In "
"this case the ``finally`` block will run after ``catch`` has handled the "
"error."
msgstr ""

#: ../../manual/control-flow.rst:826
msgid "Tasks (aka Coroutines)"
msgstr ""

#: ../../manual/control-flow.rst:828
msgid ""
"Tasks are a control flow feature that allows computations to be suspended "
"and resumed in a flexible manner. This feature is sometimes called by other "
"names, such as symmetric coroutines, lightweight threads, cooperative "
"multitasking, or one-shot continuations."
msgstr ""

#: ../../manual/control-flow.rst:833
msgid ""
"When a piece of computing work (in practice, executing a particular "
"function) is designated as a ``Task``, it becomes possible to interrupt it "
"by switching to another ``Task``. The original ``Task`` can later be "
"resumed, at which point it will pick up right where it left off. At first, "
"this may seem similar to a function call. However there are two key "
"differences. First, switching tasks does not use any space, so any number of"
" task switches can occur without consuming the call stack. Second, switching"
" among tasks can occur in any order, unlike function calls, where the called"
" function must finish executing before control returns to the calling "
"function."
msgstr ""

#: ../../manual/control-flow.rst:844
msgid ""
"This kind of control flow can make it much easier to solve certain problems."
" In some problems, the various pieces of required work are not naturally "
"related by function calls; there is no obvious \"caller\" or \"callee\" "
"among the jobs that need to be done. An example is the producer-consumer "
"problem, where one complex procedure is generating values and another "
"complex procedure is consuming them. The consumer cannot simply call a "
"producer function to get a value, because the producer may have more values "
"to generate and so might not yet be ready to return. With tasks, the "
"producer and consumer can both run as long as they need to, passing values "
"back and forth as necessary."
msgstr ""

#: ../../manual/control-flow.rst:855
msgid ""
"Julia provides the functions ``produce`` and ``consume`` for solving this "
"problem. A producer is a function that calls ``produce`` on each value it "
"needs to produce:"
msgstr ""

#: ../../manual/control-flow.rst:869
msgid ""
"To consume values, first the producer is wrapped in a ``Task``, then "
"``consume`` is called repeatedly on that object:"
msgstr ""

#: ../../manual/control-flow.rst:894
msgid ""
"One way to think of this behavior is that ``producer`` was able to return "
"multiple times. Between calls to ``produce``, the producer's execution is "
"suspended and the consumer has control."
msgstr ""

#: ../../manual/control-flow.rst:898
msgid ""
"A Task can be used as an iterable object in a ``for`` loop, in which case "
"the loop variable takes on all the produced values:"
msgstr ""

#: ../../manual/control-flow.rst:913
msgid ""
"Note that the ``Task()`` constructor expects a 0-argument function. A common"
" pattern is for the producer to be parameterized, in which case a partial "
"function application is needed to create a 0-argument :ref:`anonymous "
"function <man-anonymous-functions>`. This can be done either directly or by "
"use of a convenience macro::"
msgstr ""

#: ../../manual/control-flow.rst:927
msgid ""
"``produce`` and ``consume`` do not launch threads that can run on separate "
"CPUs. True kernel threads are discussed under the topic of :ref:`man-"
"parallel-computing`."
msgstr ""

#: ../../manual/control-flow.rst:931
msgid "Core task operations"
msgstr ""

#: ../../manual/control-flow.rst:933
msgid ""
"While ``produce`` and ``consume`` illustrate the essential nature of tasks, "
"they are actually implemented as library functions using a more primitive "
"function, ``yieldto``. ``yieldto(task,value)`` suspends the current task, "
"switches to the specified ``task``, and causes that task's last ``yieldto`` "
"call to return the specified ``value``. Notice that ``yieldto`` is the only "
"operation required to use task-style control flow; instead of calling and "
"returning we are always just switching to a different task. This is why this"
" feature is also called \"symmetric coroutines\"; each task is switched to "
"and from using the same mechanism."
msgstr ""

#: ../../manual/control-flow.rst:942
msgid ""
"``yieldto`` is powerful, but most uses of tasks do not invoke it directly. "
"Consider why this might be. If you switch away from the current task, you "
"will probably want to switch back to it at some point, but knowing when to "
"switch back, and knowing which task has the responsibility of switching "
"back, can require considerable coordination. For example, ``produce`` needs "
"to maintain some state to remember who the consumer is. Not needing to "
"manually keep track of the consuming task is what makes ``produce`` easier "
"to use than ``yieldto``."
msgstr ""

#: ../../manual/control-flow.rst:950
msgid ""
"In addition to ``yieldto``, a few other basic functions are needed to use "
"tasks effectively. ``current_task()`` gets a reference to the currently-"
"running task. ``istaskdone(t)`` queries whether a task has exited. "
"``istaskstarted(t)`` queries whether a task has run yet. "
"``task_local_storage`` manipulates a key-value store specific to the current"
" task."
msgstr ""

#: ../../manual/control-flow.rst:958
msgid "Tasks and events"
msgstr ""

#: ../../manual/control-flow.rst:960
msgid ""
"Most task switches occur as a result of waiting for events such as I/O "
"requests, and are performed by a scheduler included in the standard library."
" The scheduler maintains a queue of runnable tasks, and executes an event "
"loop that restarts tasks based on external events such as message arrival."
msgstr ""

#: ../../manual/control-flow.rst:965
msgid ""
"The basic function for waiting for an event is ``wait``. Several objects "
"implement ``wait``; for example, given a ``Process`` object, ``wait`` will "
"wait for it to exit. ``wait`` is often implicit; for example, a ``wait`` can"
" happen inside a call to ``read`` to wait for data to be available."
msgstr ""

#: ../../manual/control-flow.rst:970
msgid ""
"In all of these cases, ``wait`` ultimately operates on a ``Condition`` "
"object, which is in charge of queueing and restarting tasks. When a task "
"calls ``wait`` on a ``Condition``, the task is marked as non-runnable, added"
" to the condition's queue, and switches to the scheduler. The scheduler will"
" then pick another task to run, or block waiting for external events. If all"
" goes well, eventually an event handler will call ``notify`` on the "
"condition, which causes tasks waiting for that condition to become runnable "
"again."
msgstr ""

#: ../../manual/control-flow.rst:979
msgid ""
"A task created explicitly by calling ``Task`` is initially not known to the "
"scheduler. This allows you to manage tasks manually using ``yieldto`` if you"
" wish. However, when such a task waits for an event, it still gets restarted"
" automatically when the event happens, as you would expect. It is also "
"possible to make the scheduler run a task whenever it can, without "
"necessarily waiting for any events. This is done by calling "
"``schedule(task)``, or using the ``@schedule`` or ``@async`` macros (see "
":ref:`man-parallel-computing` for more details)."
msgstr ""

#: ../../manual/control-flow.rst:989
msgid "Task states"
msgstr ""

#: ../../manual/control-flow.rst:991
msgid ""
"Tasks have a ``state`` field that describes their execution status. A task "
"state is one of the following symbols:"
msgstr ""

#: ../../manual/control-flow.rst:995
msgid "Symbol"
msgstr ""

#: ../../manual/control-flow.rst:995
msgid "Meaning"
msgstr ""

#: ../../manual/control-flow.rst:997
msgid "``:runnable``"
msgstr ""

#: ../../manual/control-flow.rst:997
msgid "Currently running, or available to be switched to"
msgstr ""

#: ../../manual/control-flow.rst:998
msgid "``:waiting``"
msgstr ""

#: ../../manual/control-flow.rst:998
msgid "Blocked waiting for a specific event"
msgstr ""

#: ../../manual/control-flow.rst:999
msgid "``:queued``"
msgstr ""

#: ../../manual/control-flow.rst:999
msgid "In the scheduler's run queue about to be restarted"
msgstr ""

#: ../../manual/control-flow.rst:1000
msgid "``:done``"
msgstr ""

#: ../../manual/control-flow.rst:1000
msgid "Successfully finished executing"
msgstr ""

#: ../../manual/control-flow.rst:1001
msgid "``:failed``"
msgstr ""

#: ../../manual/control-flow.rst:1001
msgid "Finished with an uncaught exception"
msgstr ""

#: ../../manual/conversion-and-promotion.rst:5
msgid "Conversion and Promotion"
msgstr ""

#: ../../manual/conversion-and-promotion.rst:7
msgid ""
"Julia has a system for promoting arguments of mathematical operators to a "
"common type, which has been mentioned in various other sections, including "
":ref:`man-integers-and-floating-point-numbers`, :ref:`man-mathematical-"
"operations`, :ref:`man-types`, and :ref:`man-methods`. In this section, we "
"explain how this promotion system works, as well as how to extend it to new "
"types and apply it to functions besides built-in mathematical operators. "
"Traditionally, programming languages fall into two camps with respect to "
"promotion of arithmetic arguments:"
msgstr ""

#: ../../manual/conversion-and-promotion.rst:16
msgid ""
"**Automatic promotion for built-in arithmetic types and operators.** In most"
" languages, built-in numeric types, when used as operands to arithmetic "
"operators with infix syntax, such as ``+``, ``-``, ``*``, and ``/``, are "
"automatically promoted to a common type to produce the expected results. C, "
"Java, Perl, and Python, to name a few, all correctly compute the sum ``1 + "
"1.5`` as the floating-point value ``2.5``, even though one of the operands "
"to ``+`` is an integer. These systems are convenient and designed carefully "
"enough that they are generally all-but-invisible to the programmer: hardly "
"anyone consciously thinks of this promotion taking place when writing such "
"an expression, but compilers and interpreters must perform conversion before"
" addition since integers and floating-point values cannot be added as-is. "
"Complex rules for such automatic conversions are thus inevitably part of "
"specifications and implementations for such languages."
msgstr ""

#: ../../manual/conversion-and-promotion.rst:31
msgid ""
"**No automatic promotion.** This camp includes Ada and ML — very \"strict\" "
"statically typed languages. In these languages, every conversion must be "
"explicitly specified by the programmer. Thus, the example expression ``1 + "
"1.5`` would be a compilation error in both Ada and ML. Instead one must "
"write ``real(1) + 1.5``, explicitly converting the integer ``1`` to a "
"floating-point value before performing addition. Explicit conversion "
"everywhere is so inconvenient, however, that even Ada has some degree of "
"automatic conversion: integer literals are promoted to the expected integer "
"type automatically, and floating-point literals are similarly promoted to "
"appropriate floating-point types."
msgstr ""

#: ../../manual/conversion-and-promotion.rst:43
msgid ""
"In a sense, Julia falls into the \"no automatic promotion\" category: "
"mathematical operators are just functions with special syntax, and the "
"arguments of functions are never automatically converted. However, one may "
"observe that applying mathematical operations to a wide variety of mixed "
"argument types is just an extreme case of polymorphic multiple dispatch — "
"something which Julia's dispatch and type systems are particularly well-"
"suited to handle. \"Automatic\" promotion of mathematical operands simply "
"emerges as a special application: Julia comes with pre-defined catch-all "
"dispatch rules for mathematical operators, invoked when no specific "
"implementation exists for some combination of operand types. These catch-all"
" rules first promote all operands to a common type using user-definable "
"promotion rules, and then invoke a specialized implementation of the "
"operator in question for the resulting values, now of the same type. User-"
"defined types can easily participate in this promotion system by defining "
"methods for conversion to and from other types, and providing a handful of "
"promotion rules defining what types they should promote to when mixed with "
"other types."
msgstr ""

#: ../../manual/conversion-and-promotion.rst:64
msgid "Conversion"
msgstr ""

#: ../../manual/conversion-and-promotion.rst:66
msgid ""
"Conversion of values to various types is performed by the ``convert`` "
"function. The ``convert`` function generally takes two arguments: the first "
"is a type object while the second is a value to convert to that type; the "
"returned value is the value converted to an instance of given type. The "
"simplest way to understand this function is to see it in action:"
msgstr ""

#: ../../manual/conversion-and-promotion.rst:93
msgid ""
"Conversion isn't always possible, in which case a no method error is thrown "
"indicating that ``convert`` doesn't know how to perform the requested "
"conversion:"
msgstr ""

#: ../../manual/conversion-and-promotion.rst:103
msgid ""
"Some languages consider parsing strings as numbers or formatting numbers as "
"strings to be conversions (many dynamic languages will even perform "
"conversion for you automatically), however Julia does not: even though some "
"strings can be parsed as numbers, most strings are not valid representations"
" of numbers, and only a very limited subset of them are. Therefore in Julia "
"the dedicated ``parseint`` function must be used to perform this operation, "
"making it more explicit."
msgstr ""

#: ../../manual/conversion-and-promotion.rst:112
msgid "Defining New Conversions"
msgstr ""

#: ../../manual/conversion-and-promotion.rst:114
msgid ""
"To define a new conversion, simply provide a new method for ``convert``. "
"That's really all there is to it. For example, the method to convert a "
"number to a boolean is simply this::"
msgstr ""

#: ../../manual/conversion-and-promotion.rst:120
msgid ""
"The type of the first argument of this method is a :ref:`singleton type "
"<man-singleton-types>`, ``Type{Bool}``, the only instance of which is "
"``Bool``. Thus, this method is only invoked when the first argument is the "
"type value ``Bool``. Notice the syntax used for the first argument: the "
"argument name is omitted prior to the ``::`` symbol, and only the type is "
"given.  This is the syntax in Julia for a function argument whose type is "
"specified but whose value is never used in the function body.  In this "
"example, since the type is a singleton, there would never be any reason to "
"use its value within the body. When invoked, the method determines whether a"
" numeric value is true or false as a boolean, by comparing it to zero:"
msgstr ""

#: ../../manual/conversion-and-promotion.rst:148
msgid ""
"The method signatures for conversion methods are often quite a bit more "
"involved than this example, especially for parametric types. The example "
"above is meant to be pedagogical, and is not the actual julia behaviour. "
"This is the actual implementation in julia::"
msgstr ""

#: ../../manual/conversion-and-promotion.rst:162
msgid "Case Study: Rational Conversions"
msgstr ""

#: ../../manual/conversion-and-promotion.rst:164
msgid ""
"To continue our case study of Julia's ``Rational`` type, here are the "
"conversions declared in `rational.jl "
"<https://github.com/JuliaLang/julia/blob/master/base/rational.jl>`_, right "
"after the declaration of the type and its constructors::"
msgstr ""

#: ../../manual/conversion-and-promotion.rst:192
msgid ""
"The initial four convert methods provide conversions to rational types. The "
"first method converts one type of rational to another type of rational by "
"converting the numerator and denominator to the appropriate integer type. "
"The second method does the same conversion for integers by taking the "
"denominator to be 1. The third method implements a standard algorithm for "
"approximating a floating-point number by a ratio of integers to within a "
"given tolerance, and the fourth method applies it, using machine epsilon at "
"the given value as the threshold. In general, one should have ``a//b == "
"convert(Rational{Int64}, a/b)``."
msgstr ""

#: ../../manual/conversion-and-promotion.rst:202
msgid ""
"The last two convert methods provide conversions from rational types to "
"floating-point and integer types. To convert to floating point, one simply "
"converts both numerator and denominator to that floating point type and then"
" divides. To convert to integer, one can use the ``div`` operator for "
"truncated integer division (rounded towards zero)."
msgstr ""

#: ../../manual/conversion-and-promotion.rst:211
msgid "Promotion"
msgstr ""

#: ../../manual/conversion-and-promotion.rst:213
msgid ""
"Promotion refers to converting values of mixed types to a single common "
"type. Although it is not strictly necessary, it is generally implied that "
"the common type to which the values are converted can faithfully represent "
"all of the original values. In this sense, the term \"promotion\" is "
"appropriate since the values are converted to a \"greater\" type — i.e. one "
"which can represent all of the input values in a single common type. It is "
"important, however, not to confuse this with object-oriented (structural) "
"super-typing, or Julia's notion of abstract super-types: promotion has "
"nothing to do with the type hierarchy, and everything to do with converting "
"between alternate representations. For instance, although every ``Int32`` "
"value can also be represented as a ``Float64`` value, ``Int32`` is not a "
"subtype of ``Float64``."
msgstr ""

#: ../../manual/conversion-and-promotion.rst:226
msgid ""
"Promotion to a common \"greater\" type is performed in Julia by the "
"``promote`` function, which takes any number of arguments, and returns a "
"tuple of the same number of values, converted to a common type, or throws an"
" exception if promotion is not possible. The most common use case for "
"promotion is to convert numeric arguments to a common type:"
msgstr ""

#: ../../manual/conversion-and-promotion.rst:252
msgid ""
"Floating-point values are promoted to the largest of the floating-point "
"argument types. Integer values are promoted to the larger of either the "
"native machine word size or the largest integer argument type. Mixtures of "
"integers and floating-point values are promoted to a floating-point type big"
" enough to hold all the values. Integers mixed with rationals are promoted "
"to rationals. Rationals mixed with floats are promoted to floats. Complex "
"values mixed with real values are promoted to the appropriate kind of "
"complex value."
msgstr ""

#: ../../manual/conversion-and-promotion.rst:261
msgid ""
"That is really all there is to using promotions. The rest is just a matter "
"of clever application, the most typical \"clever\" application being the "
"definition of catch-all methods for numeric operations like the arithmetic "
"operators ``+``, ``-``, ``*`` and ``/``. Here are some of the the catch-all "
"method definitions given in `promotion.jl "
"<https://github.com/JuliaLang/julia/blob/master/base/promotion.jl>`_::"
msgstr ""

#: ../../manual/conversion-and-promotion.rst:273
msgid ""
"These method definitions say that in the absence of more specific rules for "
"adding, subtracting, multiplying and dividing pairs of numeric values, "
"promote the values to a common type and then try again. That's all there is "
"to it: nowhere else does one ever need to worry about promotion to a common "
"numeric type for arithmetic operations — it just happens automatically. "
"There are definitions of catch-all promotion methods for a number of other "
"arithmetic and mathematical functions in `promotion.jl "
"<https://github.com/JuliaLang/julia/blob/master/base/promotion.jl>`_, but "
"beyond that, there are hardly any calls to ``promote`` required in the Julia"
" standard library. The most common usages of ``promote`` occur in outer "
"constructors methods, provided for convenience, to allow constructor calls "
"with mixed types to delegate to an inner type with fields promoted to an "
"appropriate common type. For example, recall that `rational.jl "
"<https://github.com/JuliaLang/julia/blob/master/base/rational.jl>`_ provides"
" the following outer constructor method::"
msgstr ""

#: ../../manual/conversion-and-promotion.rst:291
msgid "This allows calls like the following to work:"
msgstr ""

#: ../../manual/conversion-and-promotion.rst:301
msgid ""
"For most user-defined types, it is better practice to require programmers to"
" supply the expected types to constructor functions explicitly, but "
"sometimes, especially for numeric problems, it can be convenient to do "
"promotion automatically."
msgstr ""

#: ../../manual/conversion-and-promotion.rst:307
msgid "Defining Promotion Rules"
msgstr ""

#: ../../manual/conversion-and-promotion.rst:309
msgid ""
"Although one could, in principle, define methods for the ``promote`` "
"function directly, this would require many redundant definitions for all "
"possible permutations of argument types. Instead, the behavior of "
"``promote`` is defined in terms of an auxiliary function called "
"``promote_rule``, which one can provide methods for. The ``promote_rule`` "
"function takes a pair of type objects and returns another type object, such "
"that instances of the argument types will be promoted to the returned type. "
"Thus, by defining the rule::"
msgstr ""

#: ../../manual/conversion-and-promotion.rst:320
msgid ""
"one declares that when 64-bit and 32-bit floating-point values are promoted "
"together, they should be promoted to 64-bit floating-point. The promotion "
"type does not need to be one of the argument types, however; the following "
"promotion rules both occur in Julia's standard library::"
msgstr ""

#: ../../manual/conversion-and-promotion.rst:328
msgid ""
"In the latter case, the result type is ``BigInt`` since ``BigInt`` is the "
"only type large enough to hold integers for arbitrary-precision integer "
"arithmetic.  Also note that one does not need to define both "
"``promote_rule(::Type{A}, ::Type{B})`` and ``promote_rule(::Type{B}, "
"::Type{A})`` — the symmetry is implied by the way ``promote_rule`` is used "
"in the promotion process."
msgstr ""

#: ../../manual/conversion-and-promotion.rst:335
msgid ""
"The ``promote_rule`` function is used as a building block to define a second"
" function called ``promote_type``, which, given any number of type objects, "
"returns the common type to which those values, as arguments to ``promote`` "
"should be promoted. Thus, if one wants to know, in absence of actual values,"
" what type a collection of values of certain types would promote to, one can"
" use ``promote_type``:"
msgstr ""

#: ../../manual/conversion-and-promotion.rst:347
msgid ""
"Internally, ``promote_type`` is used inside of ``promote`` to determine what"
" type argument values should be converted to for promotion. It can, however,"
" be useful in its own right. The curious reader can read the code in "
"`promotion.jl "
"<https://github.com/JuliaLang/julia/blob/master/base/promotion.jl>`_, which "
"defines the complete promotion mechanism in about 35 lines."
msgstr ""

#: ../../manual/conversion-and-promotion.rst:355
msgid "Case Study: Rational Promotions"
msgstr ""

#: ../../manual/conversion-and-promotion.rst:357
msgid ""
"Finally, we finish off our ongoing case study of Julia's rational number "
"type, which makes relatively sophisticated use of the promotion mechanism "
"with the following promotion rules::"
msgstr ""

#: ../../manual/conversion-and-promotion.rst:366
msgid ""
"The first rule asserts that promotion of a rational number with its own "
"numerator/denominator type, simply promotes to itself. The second rule says "
"that promoting a rational number with any other integer type promotes to a "
"rational type whose numerator/denominator type is the result of promotion of"
" its numerator/denominator type with the other integer type. The third rule "
"applies the same logic to two different types of rational numbers, resulting"
" in a rational of the promotion of their respective numerator/denominator "
"types. The fourth and final rule dictates that promoting a rational with a "
"float results in the same type as promoting the numerator/denominator type "
"with the float."
msgstr ""

#: ../../manual/conversion-and-promotion.rst:377
msgid ""
"This small handful of promotion rules, together with the `conversion methods"
" discussed above <#case-study-rational-conversions>`_, are sufficient to "
"make rational numbers interoperate completely naturally with all of Julia's "
"other numeric types — integers, floating-point numbers, and complex numbers."
" By providing appropriate conversion methods and promotion rules in the same"
" manner, any user-defined numeric type can interoperate just as naturally "
"with Julia's predefined numerics."
msgstr ""

#: ../../manual/dates.rst:5
msgid "Date and DateTime"
msgstr ""

#: ../../manual/dates.rst:7
msgid ""
"The ``Dates`` module provides two types for working with dates: ``Date`` and"
" ``DateTime``, representing day and millisecond precision, respectively; "
"both are subtypes of the abstract ``TimeType``. The motivation for distinct "
"types is simple: some operations are much simpler, both in terms of code and"
" mental reasoning, when the complexities of greater precision don't have to "
"be dealt with. For example, since the ``Date`` type only resolves to the "
"precision of a single date (i.e. no hours, minutes, or seconds), normal "
"considerations for time zones, daylight savings/summer time, and leap "
"seconds are unnecessary and avoided."
msgstr ""

#: ../../manual/dates.rst:9
msgid ""
"Both ``Date`` and ``DateTime`` are basically immutable ``Int64`` wrappers. "
"The single ``instant`` field of either type is actually a ``UTInstant{P}`` "
"type, which represents a continuously increasing machine timeline based on "
"the UT second [1]_. The ``DateTime`` type is *timezone-unaware* (in Python "
"parlance) or is analogous to a *LocalDateTime* in Java 8. Additional time "
"zone functionality can be added through the `Timezones.jl package "
"<https://github.com/quinnj/Timezones.jl/>`_, which compiles the `Olsen Time "
"Zone Database <http://www.iana.org/time-zones>`_. Both ``Date`` and "
"``DateTime`` are based on the ISO 8601 standard, which follows the proleptic"
" Gregorian calendar. One note is that the ISO 8601 standard is particular "
"about BC/BCE dates. In general, the last day of the BC/BCE era, 1-12-31 "
"BC/BCE, was followed by 1-1-1 AD/CE, thus no year zero exists. The ISO "
"standard, however, states that 1 BC/BCE is year zero, so ``0000-12-31`` is "
"the day before ``0001-01-01``, and year ``-0001`` (yes, negative one for the"
" year) is 2 BC/BCE, year ``-0002`` is 3 BC/BCE, etc."
msgstr ""

#: ../../manual/dates.rst:11
msgid ""
"The notion of the UT second is actually quite fundamental. There are "
"basically two different notions of time generally accepted, one based on the"
" physical rotation of the earth (one full rotation = 1 day), the other based"
" on the SI second (a fixed, constant value). These are radically different! "
"Think about it, a \"UT second\", as defined relative to the rotation of the "
"earth, may have a different absolute length depending on the day! Anyway, "
"the fact that ``Date`` and ``DateTime`` are based on UT seconds is a "
"simplifying, yet honest assumption so that things like leap seconds and all "
"their complexity can be avoided. This basis of time is formally called `UT "
"<http://en.wikipedia.org/wiki/Universal_Time>`_ or UT1. Basing types on the "
"UT second basically means that every minute has 60 seconds and every day has"
" 24 hours and leads to more natural calculations when working with calendar "
"dates."
msgstr ""

#: ../../manual/dates.rst:15
msgid ""
"``Date`` and ``DateTime`` types can be constructed by integer or ``Period`` "
"types, by parsing, or through adjusters (more on those later)::"
msgstr ""

#: ../../manual/dates.rst:53
msgid ""
"``Date`` or ``DateTime`` parsing is accomplished by the use of format "
"strings. Format strings work by the notion of defining *delimited* or "
"*fixed-width* \"slots\" that contain a period to parse and pass to a "
"``Date`` or ``DateTime`` constructor."
msgstr ""

#: ../../manual/dates.rst:55
msgid ""
"Delimited slots are marked by specifying the delimiter the parser should "
"expect between two subsequent periods; so ``\"y-m-d\"`` lets the parser know"
" that between the first and second slots in a date string like "
"``\"2014-07-16\"``, it should find the ``-`` character. The ``y``, ``m``, "
"and ``d`` characters let the parser know which periods to parse in each "
"slot."
msgstr ""

#: ../../manual/dates.rst:57
msgid ""
"Fixed-width slots are specified by repeating the period character the number"
" of times corresponding to the width. So ``\"yyyymmdd\"`` would correspond "
"to a date string like ``\"20140716\"``. The parser distinguishes a fixed-"
"width slot by the absence of a delimiter, noting the transition "
"``\"yyyymm\"`` from one period character to the next."
msgstr ""

#: ../../manual/dates.rst:59
msgid ""
"Support for text-form month parsing is also supported through the ``u`` and "
"``U`` characters, for abbreviated and full-length month names, respectively."
" By default, only English month names are supported, so ``u`` corresponds to"
" \"Jan\", \"Feb\", \"Mar\", etc. And ``U`` corresponds to \"January\", "
"\"February\", \"March\", etc. Similar to other name=>value mapping functions"
" ``dayname`` and ``monthname``, custom locales can be loaded by passing in "
"the ``locale=>Dict{UTF8String,Int}`` mapping to the "
"``Dates.MONTHTOVALUEABBR`` and ``Dates.MONTHTOVALUE`` dicts for abbreviated "
"and full-name month names, respectively."
msgstr ""

#: ../../manual/dates.rst:61
msgid ""
"A full suite of parsing and formatting tests and examples is available in "
"`tests/dates/io.jl "
"<https://github.com/JuliaLang/julia/blob/master/test/dates/io.jl>`_."
msgstr ""

#: ../../manual/dates.rst:64
msgid "Durations/Comparisons"
msgstr ""

#: ../../manual/dates.rst:66
msgid ""
"Finding the length of time between two ``Date`` or ``DateTime`` is "
"straightforward given their underlying representation as ``UTInstant{Day}`` "
"and ``UTInstant{Millisecond}``, respectively. The difference between "
"``Date`` is returned in the number of ``Day``, and ``DateTime`` in the "
"number of ``Millisecond``. Similarly, comparing ``TimeType`` is a simple "
"matter of comparing the underlying machine instants (which in turn compares "
"the internal ``Int64`` values)."
msgstr ""

#: ../../manual/dates.rst:120
msgid "Accessor Functions"
msgstr ""

#: ../../manual/dates.rst:122
msgid ""
"Because the `Date` and `DateTime` types are stored as single ``Int64`` "
"values, date parts or fields can be retrieved through accessor functions. "
"The lowercase accessors return the field as an integer::"
msgstr ""

#: ../../manual/dates.rst:139
msgid ""
"While propercase return the same value in the corresponding ``Period`` "
"type::"
msgstr ""

#: ../../manual/dates.rst:147
msgid ""
"Compound methods are provided, as they provide a measure of efficiency if "
"multiple fields are needed at the same time::"
msgstr ""

#: ../../manual/dates.rst:158
msgid "One may also access the underlying ``UTInstant`` or integer value::"
msgstr ""

#: ../../manual/dates.rst:173
msgid "Query Functions"
msgstr ""

#: ../../manual/dates.rst:175
msgid ""
"Query functions provide calendrical information about a ``TimeType``. They "
"include information about the day of the week::"
msgstr ""

#: ../../manual/dates.rst:189
msgid "Month of the year::"
msgstr ""

#: ../../manual/dates.rst:197
msgid "As well as information about the ``TimeType``'s year and quarter::"
msgstr ""

#: ../../manual/dates.rst:211
msgid ""
"The ``dayname`` and ``monthname`` methods can also take an optional "
"``locale`` keyword that can be used to return the name of the day or month "
"of the year for other languages/locales::"
msgstr ""

#: ../../manual/dates.rst:221
msgid ""
"Similarly for the ``monthname`` function, a mapping of "
"``locale=>Dict{Int,UTF8String}`` should be loaded in ``Dates.VALUETOMONTH``."
msgstr ""

#: ../../manual/dates.rst:224
msgid "TimeType-Period Arithmetic"
msgstr ""

#: ../../manual/dates.rst:226
msgid ""
"It's good practice when using any language/date framework to be familiar "
"with how date-period arithmetic is handled as there are some `tricky issues "
"<http://msmvps.com/blogs/jon_skeet/archive/2010/12/01/the-joys-of-date-time-"
"arithmetic.aspx>`_ to deal with (though much less so for day-precision "
"types)."
msgstr ""

#: ../../manual/dates.rst:228
msgid ""
"The ``Dates`` module approach tries to follow the simple principle of trying"
" to change as little as possible when doing ``Period`` arithmetic. This "
"approach is also often known as *calendrical* arithmetic or what you would "
"probably guess if someone were to ask you the same calculation in a "
"conversation. Why all the fuss about this? Let's take a classic example: add"
" 1 month to January 31st, 2014. What's the answer? Javascript will say "
"`March 3 <http://www.markhneedham.com/blog/2009/01/07/javascript-add-a"
"-month-to-a-date/>`_ (assumes 31 days). PHP says `March 2 "
"<http://stackoverflow.com/questions/5760262/php-adding-months-to-a-date-"
"while-not-exceeding-the-last-day-of-the-month>`_ (assumes 30 days). The fact"
" is, there is no right answer. In the ``Dates`` module, it gives the result "
"of February 28th. How does it figure that out? I like to think of the "
"classic 7-7-7 gambling game in casinos."
msgstr ""

#: ../../manual/dates.rst:230
msgid ""
"Now just imagine that instead of 7-7-7, the slots are Year-Month-Day, or in "
"our example, 2014-01-31. When you ask to add 1 month to this date, the month"
" slot is incremented, so now we have 2014-02-31. Then the day number is "
"checked if it is greater than the last valid day of the new month; if it is "
"(as in the case above), the day number is adjusted down to the last valid "
"day (28). What are the ramifications with this approach? Go ahead and add "
"another month to our date, ``2014-02-28 + Month(1) == 2014-03-28``. What? "
"Were you expecting the last day of March? Nope, sorry, remember the 7-7-7 "
"slots. As few slots as possible are going to change, so we first increment "
"the month slot by 1, 2014-03-28, and boom, we're done because that's a valid"
" date. On the other hand, if we were to add 2 months to our original date, "
"2014-01-31, then we end up with 2014-03-31, as expected. The other "
"ramification of this approach is a loss in associativity when a specific "
"ordering is forced (i.e. adding things in different orders results in "
"different outcomes). For example::"
msgstr ""

#: ../../manual/dates.rst:238
msgid ""
"What's going on there? In the first line, we're adding 1 day to January "
"29th, which results in 2014-01-30; then we add 1 month, so we get "
"2014-02-30, which then adjusts down to 2014-02-28. In the second example, we"
" add 1 month *first*, where we get 2014-02-29, which adjusts down to "
"2014-02-28, and *then* add 1 day, which results in 2014-03-01. One design "
"principle that helps in this case is that, in the presence of multiple "
"Periods, the operations will be ordered by the Periods' *types*, not their "
"value or positional order; this means ``Year`` will always be added first, "
"then ``Month``, then ``Week``, etc. Hence the following *does* result in "
"associativity and Just Works::"
msgstr ""

#: ../../manual/dates.rst:246
msgid ""
"Tricky? Perhaps. What is an innocent ``Dates`` user to do? The bottom line "
"is to be aware that explicitly forcing a certain associativity, when dealing"
" with months, may lead to some unexpected results, but otherwise, everything"
" should work as expected. Thankfully, that's pretty much the extent of the "
"odd cases in date-period arithmetic when dealing with time in UT (avoiding "
"the \"joys\" of dealing with daylight savings, leap seconds, etc.)."
msgstr ""

#: ../../manual/dates.rst:250
msgid "Adjuster Functions"
msgstr ""

#: ../../manual/dates.rst:252
msgid ""
"As convenient as date-period arithmetics are, often the kinds of "
"calculations needed on dates take on a *calendrical* or *temporal* nature "
"rather than a fixed number of periods. Holidays are a perfect example; most "
"follow rules such as \"Memorial Day = Last Monday of May\", or "
"\"Thanksgiving = 4th Thursday of November\". These kinds of temporal "
"expressions deal with rules relative to the calendar, like first or last of "
"the month, next Tuesday, or the first and third Wednesdays, etc."
msgstr ""

#: ../../manual/dates.rst:254
msgid ""
"The ``Dates`` module provides the *adjuster* API through several convenient "
"methods that aid in simply and succinctly expressing temporal rules. The "
"first group of adjuster methods deal with the first and last of weeks, "
"months, quarters, and years. They each take a single ``TimeType`` as input "
"and return or *adjust to* the first or last of the desired period relative "
"to the input."
msgstr ""

#: ../../manual/dates.rst:270
msgid ""
"The next two higher-order methods, ``tonext``, and ``toprev``, generalize "
"working with temporal expressions by taking a ``DateFunction`` as first "
"argument, along with a starting ``TimeType``. A ``DateFunction`` is just a "
"function, usually anonymous, that takes a single ``TimeType`` as input and "
"returns a ``Bool``, ``true`` indicating a satisfied adjustment criterion. "
"For example::"
msgstr ""

#: ../../manual/dates.rst:283
msgid ""
"This is useful with the do-block syntax for more complex temporal "
"expressions::"
msgstr ""

#: ../../manual/dates.rst:293
msgid ""
"The final method in the adjuster API is the ``recur`` function. ``recur`` "
"vectorizes the adjustment process by taking a start and stop date "
"(optionally specificed by a ``StepRange``), along with a ``DateFunction`` to"
" specify all valid dates/moments to be returned in the specified range. In "
"this case, the ``DateFunction`` is often referred to as the \"inclusion\" "
"function because it specifies (by returning true) which dates/moments should"
" be included in the returned vector of dates."
msgstr ""

#: ../../manual/dates.rst:315
msgid ""
"Additional examples and tests are available in `test/dates/adjusters.jl "
"<https://github.com/JuliaLang/julia/blob/master/test/dates/adjusters.jl>`_."
msgstr ""

#: ../../manual/dates.rst:319
msgid "Period Types"
msgstr ""

#: ../../manual/dates.rst:321
msgid ""
"Periods are a human view of discrete, sometimes irregular durations of time."
" Consider 1 month; it could represent, in days, a value of 28, 29, 30, or 31"
" depending on the year and month context. Or a year could represent 365 or "
"366 days in the case of a leap year. ``Period`` types are simple ``Int64`` "
"wrappers and are constructed by wrapping any ``Int64`` convertible type, "
"i.e. ``Year(1)`` or ``Month(3.0)``. Arithmetic between ``Period`` of the "
"same type behave like integers, and limited ``Period-Real`` arithmetic is "
"available. ::"
msgstr ""

#: ../../manual/dates.rst:355
msgid ""
"See the `API reference <http://docs.julialang.org/en/latest/stdlib/dates/>`_"
" for additional information on methods exported from the :mod:`Dates` "
"module."
msgstr ""

#: ../../manual/embedding.rst:7
msgid "Embedding Julia"
msgstr ""

#: ../../manual/embedding.rst:9
msgid ""
"As we have seen (:ref:`man-calling-c-and-fortran-code`) Julia has a simple "
"and efficient way to call functions written in C. But there are situations "
"where the opposite is needed: calling Julia function from C code. This can "
"be used to integrate Julia code into a larger C/C++ project, without the "
"need to rewrite everything in C/C++. Julia has a C API to make this "
"possible. As almost all programming languages have some way to call C "
"functions, the Julia C API can also be used to build further language "
"bridges (e.g. calling Julia from Python or C#)."
msgstr ""

#: ../../manual/embedding.rst:13
msgid "High-Level Embedding"
msgstr ""

#: ../../manual/embedding.rst:15
msgid ""
"We start with a simple C program that initializes Julia and calls some Julia"
" code::"
msgstr ""

#: ../../manual/embedding.rst:36
msgid ""
"In order to build this program you have to put the path to the Julia header "
"into the include path and link against ``libjulia``. For instance, when "
"Julia is installed to ``$JULIA_DIR``, one can compile the above test program"
" ``test.c`` with gcc using::"
msgstr ""

#: ../../manual/embedding.rst:40
msgid ""
"Alternatively, look at the ``embedding.c`` program in the julia source tree "
"in the ``examples/`` folder. The file ``ui/repl.c`` program is another "
"simple example of how to set ``jl_compileropts`` options while linking "
"against libjulia."
msgstr ""

#: ../../manual/embedding.rst:42
msgid ""
"The first thing that has to be done before calling any other Julia C "
"function is to initialize Julia. This is done by calling ``jl_init``, which "
"takes as argument a C string (``const char*``) to the location where Julia "
"is installed. When the argument is ``NULL``, Julia tries to determine the "
"install location automatically."
msgstr ""

#: ../../manual/embedding.rst:44
msgid ""
"The second statement initializes Julia's task scheduling system. This "
"statement must appear in a function that will not return as long as calls "
"into Julia will be made (``main`` works fine). Strictly speaking, this "
"statement is optional, but operations that switch tasks will cause problems "
"if it is omitted."
msgstr ""

#: ../../manual/embedding.rst:46
msgid ""
"The third statement in the test program evaluates a Julia statement using a "
"call to ``jl_eval_string``."
msgstr ""

#: ../../manual/embedding.rst:49
msgid "Converting Types"
msgstr ""

#: ../../manual/embedding.rst:51
msgid ""
"Real applications will not just need to execute expressions, but also return"
" their values to the host program. ``jl_eval_string`` returns a "
"``jl_value_t*``, which is a pointer to a heap-allocated Julia object. "
"Storing simple data types like ``Float64`` in this way is called ``boxing``,"
" and extracting the stored primitive data is called ``unboxing``. Our "
"improved sample program that calculates the square root of 2 in Julia and "
"reads back the result in C looks as follows::"
msgstr ""

#: ../../manual/embedding.rst:60
msgid ""
"In order to check whether ``ret`` is of a specific Julia type, we can use "
"the ``jl_is_...`` functions. By typing ``typeof(sqrt(2.0))`` into the Julia "
"shell we can see that the return type is ``Float64`` (``double`` in C). To "
"convert the boxed Julia value into a C double the ``jl_unbox_float64`` "
"function is used in the above code snippet."
msgstr ""

#: ../../manual/embedding.rst:62
msgid ""
"Corresponding ``jl_box_...`` functions are used to convert the other way::"
msgstr ""

#: ../../manual/embedding.rst:68
msgid ""
"As we will see next, boxing is required to call Julia functions with "
"specific arguments."
msgstr ""

#: ../../manual/embedding.rst:71
msgid "Calling Julia Functions"
msgstr ""

#: ../../manual/embedding.rst:73
msgid ""
"While ``jl_eval_string`` allows C to obtain the result of a Julia "
"expression, it does not allow passing arguments computed in C to Julia. For "
"this you will need to invoke Julia functions directly, using ``jl_call``::"
msgstr ""

#: ../../manual/embedding.rst:79
msgid ""
"In the first step, a handle to the Julia function ``sqrt`` is retrieved by "
"calling ``jl_get_function``. The first argument passed to "
"``jl_get_function`` is a pointer to the ``Base`` module in which ``sqrt`` is"
" defined. Then, the double value is boxed using ``jl_box_float64``. Finally,"
" in the last step, the function is called using ``jl_call1``. ``jl_call0``, "
"``jl_call2``, and ``jl_call3`` functions also exist, to conveniently handle "
"different numbers of arguments. To pass more arguments, use ``jl_call``::"
msgstr ""

#: ../../manual/embedding.rst:83
msgid ""
"Its second argument ``args`` is an array of ``jl_value_t*`` arguments and "
"``nargs`` is the number of arguments."
msgstr ""

#: ../../manual/embedding.rst:86
msgid "Memory Management"
msgstr ""

#: ../../manual/embedding.rst:88
msgid ""
"As we have seen, Julia objects are represented in C as pointers. This raises"
" the question of who is responsible for freeing these objects."
msgstr ""

#: ../../manual/embedding.rst:90
msgid ""
"Typically, Julia objects are freed by a garbage collector (GC), but the GC "
"does not automatically know that we are holding a reference to a Julia value"
" from C. This means the GC can free objects out from under you, rendering "
"pointers invalid."
msgstr ""

#: ../../manual/embedding.rst:92
msgid ""
"The GC can only run when Julia objects are allocated. Calls like "
"``jl_box_float64`` perform allocation, and allocation might also happen at "
"any point in running Julia code. However, it is generally safe to use "
"pointers in between ``jl_...`` calls. But in order to make sure that values "
"can survive ``jl_...`` calls, we have to tell Julia that we hold a reference"
" to a Julia value. This can be done using the ``JL_GC_PUSH`` macros::"
msgstr ""

#: ../../manual/embedding.rst:99
msgid ""
"The ``JL_GC_POP`` call releases the references established by the previous "
"``JL_GC_PUSH``. Note that ``JL_GC_PUSH``  is working on the stack, so it "
"must be exactly paired with a ``JL_GC_POP`` before the stack frame is "
"destroyed."
msgstr ""

#: ../../manual/embedding.rst:101
msgid ""
"Several Julia values can be pushed at once using the ``JL_GC_PUSH2`` , "
"``JL_GC_PUSH3`` , and ``JL_GC_PUSH4`` macros. To push an array of Julia "
"values one can use the  ``JL_GC_PUSHARGS`` macro, which can be used as "
"follows::"
msgstr ""

#: ../../manual/embedding.rst:111
msgid "Manipulating the Garbage Collector"
msgstr ""

#: ../../manual/embedding.rst:113
msgid ""
"There are some functions to control the GC. In normal use cases, these "
"should not be necessary."
msgstr ""

#: ../../manual/embedding.rst:116
msgid "``void jl_gc_collect()``"
msgstr ""

#: ../../manual/embedding.rst:116
msgid "Force a GC run"
msgstr ""

#: ../../manual/embedding.rst:117
msgid "``void jl_gc_disable()``"
msgstr ""

#: ../../manual/embedding.rst:117
msgid "Disable the GC"
msgstr ""

#: ../../manual/embedding.rst:118
msgid "``void jl_gc_enable()``"
msgstr ""

#: ../../manual/embedding.rst:118
msgid "Enable the GC"
msgstr ""

#: ../../manual/embedding.rst:122
msgid "Working with Arrays"
msgstr ""

#: ../../manual/embedding.rst:124
msgid ""
"Julia and C can share array data without copying. The next example will show"
" how this works."
msgstr ""

#: ../../manual/embedding.rst:126
msgid ""
"Julia arrays are represented in C by the datatype ``jl_array_t*``. "
"Basically, ``jl_array_t`` is a struct that contains:"
msgstr ""

#: ../../manual/embedding.rst:128
msgid "Information about the datatype"
msgstr ""

#: ../../manual/embedding.rst:129
msgid "A pointer to the data block"
msgstr ""

#: ../../manual/embedding.rst:130
msgid "Information about the sizes of the array"
msgstr ""

#: ../../manual/embedding.rst:132
msgid ""
"To keep things simple, we start with a 1D array. Creating an array "
"containing Float64 elements of length 10 is done by::"
msgstr ""

#: ../../manual/embedding.rst:137
msgid ""
"Alternatively, if you have already allocated the array you can generate a "
"thin wrapper around its data::"
msgstr ""

#: ../../manual/embedding.rst:142
msgid ""
"The last argument is a boolean indicating whether Julia should take "
"ownership of the data. If this argument is non-zero, the GC will call "
"``free`` on the data pointer when the array is no longer referenced."
msgstr ""

#: ../../manual/embedding.rst:144
msgid "In order to access the data of x, we can use ``jl_array_data``::"
msgstr ""

#: ../../manual/embedding.rst:148
msgid "Now we can fill the array::"
msgstr ""

#: ../../manual/embedding.rst:153
msgid ""
"Now let us call a Julia function that performs an in-place operation on "
"``x``::"
msgstr ""

#: ../../manual/embedding.rst:158
msgid ""
"By printing the array, one can verify that the elements of ``x`` are now "
"reversed."
msgstr ""

#: ../../manual/embedding.rst:161
msgid "Accessing Returned Arrays"
msgstr ""

#: ../../manual/embedding.rst:163
msgid ""
"If a Julia function returns an array, the return value of ``jl_eval_string``"
" and ``jl_call`` can be cast to a ``jl_array_t*``::"
msgstr ""

#: ../../manual/embedding.rst:168
msgid ""
"Now the content of ``y`` can be accessed as before using ``jl_array_data``. "
"As always, be sure to keep a reference to the array while it is in use."
msgstr ""

#: ../../manual/embedding.rst:172
msgid "Multidimensional Arrays"
msgstr ""

#: ../../manual/embedding.rst:174
msgid ""
"Julia's multidimensional arrays are stored in memory in column-major order. "
"Here is some code that creates a 2D array and accesses its properties::"
msgstr ""

#: ../../manual/embedding.rst:193
msgid ""
"Notice that while Julia arrays use 1-based indexing, the C API uses 0-based "
"indexing (for example in calling ``jl_array_dim``) in order to read as "
"idiomatic C code."
msgstr ""

#: ../../manual/embedding.rst:196
msgid "Exceptions"
msgstr ""

#: ../../manual/embedding.rst:198
msgid "Julia code can throw exceptions. For example, consider::"
msgstr ""

#: ../../manual/embedding.rst:202
msgid ""
"This call will appear to do nothing. However, it is possible to check "
"whether an exception was thrown::"
msgstr ""

#: ../../manual/embedding.rst:207
msgid ""
"If you are using the Julia C API from a language that supports exceptions "
"(e.g. Python, C#, C++), it makes sense to wrap each call into libjulia with "
"a function that checks whether an exception was thrown, and then rethrows "
"the exception in the host language."
msgstr ""

#: ../../manual/embedding.rst:211
msgid "Throwing Julia Exceptions"
msgstr ""

#: ../../manual/embedding.rst:213
msgid ""
"When writing Julia callable functions, it might be necessary to validate "
"arguments and throw exceptions to indicate errors. A typical type check "
"looks like::"
msgstr ""

#: ../../manual/embedding.rst:219
msgid "General exceptions can be raised using the funtions::"
msgstr ""

#: ../../manual/embedding.rst:224
msgid ""
"``jl_error`` takes a C string, and ``jl_errorf`` is called like ``printf``::"
msgstr ""

#: ../../manual/embedding.rst:228
msgid "where in this example ``x`` is assumed to be an integer."
msgstr ""

#: ../../manual/faq.rst:5
msgid "Frequently Asked Questions"
msgstr ""

#: ../../manual/faq.rst:8
msgid "Sessions and the REPL"
msgstr ""

#: ../../manual/faq.rst:11
msgid "How do I delete an object in memory?"
msgstr ""

#: ../../manual/faq.rst:13
msgid ""
"Julia does not have an analog of MATLAB's ``clear`` function; once a name is"
" defined in a Julia session (technically, in module ``Main``), it is always "
"present."
msgstr ""

#: ../../manual/faq.rst:17
msgid ""
"If memory usage is your concern, you can always replace objects with ones "
"that consume less memory.  For example, if ``A`` is a gigabyte-sized array "
"that you no longer need, you can free the memory with ``A = 0``.  The memory"
" will be released the next time the garbage collector runs; you can force "
"this to happen with ``gc()``."
msgstr ""

#: ../../manual/faq.rst:24
msgid "How can I modify the declaration of a type/immutable in my session?"
msgstr ""

#: ../../manual/faq.rst:26
msgid ""
"Perhaps you've defined a type and then realize you need to add a new field."
"  If you try this at the REPL, you get the error::"
msgstr ""

#: ../../manual/faq.rst:31
msgid "Types in module ``Main`` cannot be redefined."
msgstr ""

#: ../../manual/faq.rst:33
msgid ""
"While this can be inconvenient when you are developing new code, there's an "
"excellent workaround.  Modules can be replaced by redefining them, and so if"
" you wrap all your new code inside a module you can redefine types and "
"constants.  You can't import the type names into ``Main`` and then expect to"
" be able to redefine them there, but you can use the module name to resolve "
"the scope.  In other words, while developing you might use a workflow "
"something like this::"
msgstr ""

#: ../../manual/faq.rst:52 ../../manual/functions.rst:5
msgid "Functions"
msgstr ""

#: ../../manual/faq.rst:55
msgid ""
"I passed an argument ``x`` to a function, modified it inside that function, "
"but on the outside, the variable ``x`` is still unchanged. Why?"
msgstr ""

#: ../../manual/faq.rst:57
msgid "Suppose you call a function like this::"
msgstr ""

#: ../../manual/faq.rst:67
msgid ""
"In Julia, any function (including ``change_value!()``) can't change the "
"binding of a local variable. If ``x`` (in the calling scope) is bound to a "
"immutable object (like a real number), you can't modify the object; "
"likewise, if x is bound in the calling scope to a Dict, you can't change it "
"to be bound to an ASCIIString."
msgstr ""

#: ../../manual/faq.rst:69
msgid ""
"But here is a thing you should pay attention to: suppose ``x`` is bound to "
"an Array (or any other mutable type). You cannot \"unbind\" ``x`` from this "
"Array. But, since an Array is a *mutable* type, you can change its content. "
"For example::"
msgstr ""

#: ../../manual/faq.rst:87
msgid ""
"Here we created a function ``change_array!()``, that assigns ``5`` to the "
"first element of the Array. We passed ``x`` (which was previously bound to "
"an Array) to the function. Notice that, after the function call, ``x`` is "
"still bound to the same Array, but the content of that Array changed."
msgstr ""

#: ../../manual/faq.rst:91
msgid "Can I use ``using`` or ``import`` inside a function?"
msgstr ""

#: ../../manual/faq.rst:93
msgid ""
"No, you are not allowed to have a ``using`` or ``import`` statement inside a"
" function.  If you want to import a module but only use its symbols inside a"
" specific function or set of functions, you have two options:"
msgstr ""

#: ../../manual/faq.rst:97
msgid "Use ``import``::"
msgstr ""

#: ../../manual/faq.rst:105
msgid ""
"This loads the module Foo and defines a variable ``Foo`` that refers to the "
"module, but does not import any of the other symbols from the module into "
"the current namespace.  You refer to the ``Foo`` symbols by their qualified "
"names ``Foo.bar`` etc."
msgstr ""

#: ../../manual/faq.rst:111
msgid "Wrap your function in a module::"
msgstr ""

#: ../../manual/faq.rst:122
msgid "This imports all the symbols from Foo, but only inside the module Bar."
msgstr ""

#: ../../manual/faq.rst:127
msgid "What does the ``...`` operator do?"
msgstr ""

#: ../../manual/faq.rst:130
msgid "The two uses of the `...` operator: slurping and splatting"
msgstr ""

#: ../../manual/faq.rst:132
msgid ""
"Many newcomers to Julia find the use of ``...`` operator confusing. Part of "
"what makes the ``...`` operator confusing is that it means two different "
"things depending on context."
msgstr ""

#: ../../manual/faq.rst:137
msgid ""
"``...`` combines many arguments into one argument in function definitions"
msgstr ""

#: ../../manual/faq.rst:139
msgid ""
"In the context of function definitions, the ``...`` operator is used to "
"combine many different arguments into a single argument. This use of ``...``"
" for combining many different arguments into a single argument is called "
"slurping:"
msgstr ""

#: ../../manual/faq.rst:147
msgid "julia> function printargs(args...)"
msgstr ""

#: ../../manual/faq.rst:144
msgid "@printf(\"%s\\n\", typeof(args)) for (i, arg) in enumerate(args)"
msgstr ""

#: ../../manual/faq.rst:146
msgid "@printf(\"Arg %d = %s\\n\", i, arg)"
msgstr ""

#: ../../manual/faq.rst:147 ../../manual/faq.rst:148 ../../manual/faq.rst:173
#: ../../manual/parallel-computing.rst:755
msgid "end"
msgstr ""

#: ../../manual/faq.rst:149
msgid "printargs (generic function with 1 method)"
msgstr ""

#: ../../manual/faq.rst:151
msgid ""
"julia> printargs(1, 2, 3) (Int64,Int64,Int64) Arg 1 = 1 Arg 2 = 2 Arg 3 = 3"
msgstr ""

#: ../../manual/faq.rst:157
msgid ""
"If Julia were a language that made more liberal use of ASCII characters, the"
" slurping operator might have been written as ``<-...`` instead of ``...``."
msgstr ""

#: ../../manual/faq.rst:161
msgid ""
"``...`` splits one argument into many different arguments in function calls"
msgstr ""

#: ../../manual/faq.rst:163
msgid ""
"In contrast to the use of the ``...`` operator to denote slurping many "
"different arguments into one argument when defining a function, the ``...`` "
"operator is also used to cause a single function argument to be split apart "
"into many different arguments when used in the context of a function call. "
"This use of ``...`` is called splatting:"
msgstr ""

#: ../../manual/faq.rst:172
msgid "julia> function threeargs(a, b, c)"
msgstr ""

#: ../../manual/faq.rst:170
msgid ""
"@printf(\"a = %s::%s\\n\", a, typeof(a)) @printf(\"b = %s::%s\\n\", b, "
"typeof(b)) @printf(\"c = %s::%s\\n\", c, typeof(c))"
msgstr ""

#: ../../manual/faq.rst:174
msgid "threeargs (generic function with 1 method)"
msgstr ""

#: ../../manual/faq.rst:176
msgid "julia> vec = [1, 2, 3] 3-element Array{Int64,1}:"
msgstr ""

#: ../../manual/faq.rst:178
msgid "1 2 3"
msgstr ""

#: ../../manual/faq.rst:182
msgid "julia> threeargs(vec...) a = 1::Int64 b = 2::Int64 c = 3::Int64"
msgstr ""

#: ../../manual/faq.rst:187
msgid ""
"If Julia were a language that made more liberal use of ASCII characters, the"
" splatting operator might have been written as ``...->`` instead of ``...``."
msgstr ""

#: ../../manual/faq.rst:191
msgid "Types, type declarations, and constructors"
msgstr ""

#: ../../manual/faq.rst:196
msgid "What does \"type-stable\" mean?"
msgstr ""

#: ../../manual/faq.rst:198
msgid ""
"It means that the type of the output is predictable from the types of the "
"inputs.  In particular, it means that the type of the output cannot vary "
"depending on the *values* of the inputs. The following code is *not* type-"
"stable::"
msgstr ""

#: ../../manual/faq.rst:211
msgid ""
"It returns either an ``Int`` or a ``Float64`` depending on the value of its "
"argument. Since Julia can't predict the return type of this function at "
"compile-time, any computation that uses it will have to guard against both "
"types possibly occurring, making generation of fast machine code difficult."
msgstr ""

#: ../../manual/faq.rst:219
msgid ""
"Why does Julia give a ``DomainError`` for certain seemingly-sensible "
"operations?"
msgstr ""

#: ../../manual/faq.rst:221
msgid "Certain operations make mathematical sense but result in errors::"
msgstr ""

#: ../../manual/faq.rst:232
msgid ""
"This behavior is an inconvenient consequence of the requirement for type-"
"stability.  In the case of ``sqrt``, most users want ``sqrt(2.0)`` to give a"
" real number, and would be unhappy if it produced the complex number "
"``1.4142135623730951 + 0.0im``.  One could write the ``sqrt`` function to "
"switch to a complex-valued output only when passed a negative number (which "
"is what ``sqrt`` does in some other languages), but then the result would "
"not be `type-stable <#man-type-stable>`_ and the ``sqrt`` function would "
"have poor performance."
msgstr ""

#: ../../manual/faq.rst:242
msgid ""
"In these and other cases, you can get the result you want by choosing an "
"*input type* that conveys your willingness to accept an *output type* in "
"which the result can be represented::"
msgstr ""

#: ../../manual/faq.rst:254
msgid "Why does Julia use native machine integer arithmetic?"
msgstr ""

#: ../../manual/faq.rst:256
msgid ""
"Julia uses machine arithmetic for integer computations. This means that the "
"range of ``Int`` values is bounded and wraps around at either end so that "
"adding, subtracting and multiplying integers can overflow or underflow, "
"leading to some results that can be unsettling at first::"
msgstr ""

#: ../../manual/faq.rst:270
msgid ""
"Clearly, this is far from the way mathematical integers behave, and you "
"might think it less than ideal for a high-level programming language to "
"expose this to the user. For numerical work where efficiency and "
"transparency are at a premium, however, the alternatives are worse."
msgstr ""

#: ../../manual/faq.rst:275
msgid ""
"One alternative to consider would be to check each integer operation for "
"overflow and promote results to bigger integer types such as ``Int128`` or "
"``BigInt`` in the case of overflow. Unfortunately, this introduces major "
"overhead on every integer operation (think incrementing a loop counter) – it"
" requires emitting code to perform run-time overflow checks after arithmetic"
" instructions and branches to handle potential overflows. Worse still, this "
"would cause every computation involving integers to be type-unstable. As we "
"mentioned above, `type-stability is crucial <#man-type-stable>`_ for "
"effective generation of efficient code. If you can't count on the results of"
" integer operations being integers, it's impossible to generate fast, simple"
" code the way C and Fortran compilers do."
msgstr ""

#: ../../manual/faq.rst:287
msgid ""
"A variation on this approach, which avoids the appearance of type "
"instability is to merge the ``Int`` and ``BigInt`` types into a single "
"hybrid integer type, that internally changes representation when a result no"
" longer fits into the size of a machine integer. While this superficially "
"avoids type-instability at the level of Julia code, it just sweeps the "
"problem under the rug by foisting all of the same difficulties onto the C "
"code implementing this hybrid integer type. This approach *can* be made to "
"work and can even be made quite fast in many cases, but has several "
"drawbacks. One problem is that the in-memory representation of integers and "
"arrays of integers no longer match the natural representation used by C, "
"Fortran and other languages with native machine integers. Thus, to "
"interoperate with those languages, we would ultimately need to introduce "
"native integer types anyway. Any unbounded representation of integers cannot"
" have a fixed number of bits, and thus cannot be stored inline in an array "
"with fixed-size slots – large integer values will always require separate "
"heap-allocated storage. And of course, no matter how clever a hybrid integer"
" implementation one uses, there are always performance traps – situations "
"where performance degrades unexpectedly. Complex representation, lack of "
"interoperability with C and Fortran, the inability to represent integer "
"arrays without additional heap storage, and unpredictable performance "
"characteristics make even the cleverest hybrid integer implementations a "
"poor choice for high-performance numerical work."
msgstr ""

#: ../../manual/faq.rst:289
msgid ""
"An alternative to using hybrid integers or promoting to BigInts is to use "
"saturating integer arithmetic, where adding to the largest integer value "
"leaves it unchanged and likewise for subtracting from the smallest integer "
"value. This is precisely what Matlab™ does::"
msgstr ""

#: ../../manual/faq.rst:318
msgid ""
"At first blush, this seems reasonable enough since 9223372036854775807 is "
"much closer to 9223372036854775808 than -9223372036854775808 is and integers"
" are still represented with a fixed size in a natural way that is compatible"
" with C and Fortran. Saturated integer arithmetic, however, is deeply "
"problematic. The first and most obvious issue is that this is not the way "
"machine integer arithmetic works, so implementing saturated operations "
"requires emitting instructions after each machine integer operation to check"
" for underflow or overflow and replace the result with ``typemin(Int)`` or "
"``typemax(Int)`` as appropriate. This alone expands each integer operation "
"from a single, fast instruction into half a dozen instructions, probably "
"including branches. Ouch. But it gets worse – saturating integer arithmetic "
"isn't associative. Consider this Matlab computation::"
msgstr ""

#: ../../manual/faq.rst:329
msgid ""
"This makes it hard to write many basic integer algorithms since a lot of "
"common techniques depend on the fact that machine addition with overflow "
"*is* associative. Consider finding the midpoint between integer values "
"``lo`` and ``hi`` in Julia using the expression ``(lo + hi) >>> 1``::"
msgstr ""

#: ../../manual/faq.rst:340
msgid ""
"See? No problem. That's the correct midpoint between 2^62 and 2^63, despite "
"the fact that ``n + 2n`` is -4611686018427387904. Now try it in Matlab::"
msgstr ""

#: ../../manual/faq.rst:349
msgid ""
"Oops. Adding a ``>>>`` operator to Matlab wouldn't help, because saturation "
"that occurs when adding ``n`` and ``2n`` has already destroyed the "
"information necessary to compute the correct midpoint."
msgstr ""

#: ../../manual/faq.rst:353
msgid ""
"Not only is lack of associativity unfortunate for programmers who cannot "
"rely it for techniques like this, but it also defeats almost anything "
"compilers might want to do to optimize integer arithmetic. For example, "
"since Julia integers use normal machine integer arithmetic, LLVM is free to "
"aggressively optimize simple little functions like ``f(k) = 5k-1``. The "
"machine code for this function is just this::"
msgstr ""

#: ../../manual/faq.rst:371
msgid ""
"The actual body of the function is a single ``lea`` instruction, which "
"computes the integer multiply and add at once. This is even more beneficial "
"when ``f`` gets inlined into another function::"
msgstr ""

#: ../../manual/faq.rst:403
msgid ""
"Since the call to ``f`` gets inlined, the loop body ends up being just a "
"single ``lea`` instruction. Next, consider what happens if we make the "
"number of loop iterations fixed::"
msgstr ""

#: ../../manual/faq.rst:428
msgid ""
"Because the compiler knows that integer addition and multiplication are "
"associative and that multiplication distributes over addition – neither of "
"which is true of saturating arithmetic – it can optimize the entire loop "
"down to just a multiply and an add. Saturated arithmetic completely defeats "
"this kind of optimization since associativity and distributivity can fail at"
" each loop iteration, causing different outcomes depending on which "
"iteration the failure occurs in. The compiler can unroll the loop, but it "
"cannot algebraically reduce multiple operations into fewer equivalent "
"operations."
msgstr ""

#: ../../manual/faq.rst:437
msgid ""
"The most reasonable alternative to having integer arithmetic silently "
"overflow is to do checked arithmetic everywhere, raising errors when adds, "
"subtracts, and multiplies overflow, producing values that are not value-"
"correct. In this [blog post](http://danluu.com/integer-overflow/), Dan Luu "
"analyzes this and finds that rather than the trivial cost that this approach"
" should in theory have, it ends up having a substantial cost due to "
"compilers (LLVM and GCC) not gracefully optimizing around the added overflow"
" checks. If this improves in the future, we could consider defaulting to "
"checked integer arithmetic in Julia, but for now, we have to live with the "
"possibility of overflow."
msgstr ""

#: ../../manual/faq.rst:451
msgid ""
"How do \"abstract\" or ambiguous fields in types interact with the compiler?"
msgstr ""

#: ../../manual/faq.rst:452
msgid "Types can be declared without specifying the types of their fields:"
msgstr ""

#: ../../manual/faq.rst:460
msgid ""
"This allows ``a`` to be of any type. This can often be useful, but it does "
"have a downside: for objects of type ``MyAmbiguousType``, the compiler will "
"not be able to generate high-performance code.  The reason is that the "
"compiler uses the types of objects, not their values, to determine how to "
"build code. Unfortunately, very little can be inferred about an object of "
"type ``MyAmbiguousType``:"
msgstr ""

#: ../../manual/faq.rst:481
msgid ""
"``b`` and ``c`` have the same type, yet their underlying representation of "
"data in memory is very different. Even if you stored just numeric values in "
"field ``a``, the fact that the memory representation of a ``UInt8`` differs "
"from a ``Float64`` also means that the CPU needs to handle them using two "
"different kinds of instructions.  Since the required information is not "
"available in the type, such decisions have to be made at run-time. This "
"slows performance."
msgstr ""

#: ../../manual/faq.rst:490
msgid ""
"You can do better by declaring the type of ``a``. Here, we are focused on "
"the case where ``a`` might be any one of several types, in which case the "
"natural solution is to use parameters. For example:"
msgstr ""

#: ../../manual/faq.rst:500
msgid "This is a better choice than"
msgstr ""

#: ../../manual/faq.rst:508
msgid ""
"because the first version specifies the type of ``a`` from the type of the "
"wrapper object.  For example:"
msgstr ""

#: ../../manual/faq.rst:525
msgid ""
"The type of field ``a`` can be readily determined from the type of ``m``, "
"but not from the type of ``t``.  Indeed, in ``t`` it's possible to change "
"the type of field ``a``:"
msgstr ""

#: ../../manual/faq.rst:540
msgid ""
"In contrast, once ``m`` is constructed, the type of ``m.a`` cannot change:"
msgstr ""

#: ../../manual/faq.rst:551
msgid ""
"The fact that the type of ``m.a`` is known from ``m``'s type---coupled with "
"the fact that its type cannot change mid-function---allows the compiler to "
"generate highly-optimized code for objects like ``m`` but not for objects "
"like ``t``."
msgstr ""

#: ../../manual/faq.rst:556
msgid ""
"Of course, all of this is true only if we construct ``m`` with a concrete "
"type.  We can break this by explicitly constructing it with an abstract "
"type:"
msgstr ""

#: ../../manual/faq.rst:574
msgid ""
"For all practical purposes, such objects behave identically to those of "
"``MyStillAmbiguousType``."
msgstr ""

#: ../../manual/faq.rst:577
msgid ""
"It's quite instructive to compare the sheer amount code generated for a "
"simple function ::"
msgstr ""

#: ../../manual/faq.rst:583
msgid "using ::"
msgstr ""

#: ../../manual/faq.rst:590
msgid ""
"For reasons of length the results are not shown here, but you may wish to "
"try this yourself. Because the type is fully-specified in the first case, "
"the compiler doesn't need to generate any code to resolve the type at run-"
"time.  This results in shorter and faster code."
msgstr ""

#: ../../manual/faq.rst:599
msgid "How should I declare \"abstract container type\" fields?"
msgstr ""

#: ../../manual/faq.rst:601
msgid ""
"The same best practices that apply in the `previous section <#man-abstract-"
"fields>`_ also work for container types:"
msgstr ""

#: ../../manual/faq.rst:614
msgid "For example:"
msgstr ""

#: ../../manual/faq.rst:638
msgid ""
"For ``MySimpleContainer``, the object is fully-specified by its type and "
"parameters, so the compiler can generate optimized functions. In most "
"instances, this will probably suffice."
msgstr ""

#: ../../manual/faq.rst:642
msgid ""
"While the compiler can now do its job perfectly well, there are cases where "
"*you* might wish that your code could do different things depending on the "
"*element type* of ``a``.  Usually the best way to achieve this is to wrap "
"your specific operation (here, ``foo``) in a separate function::"
msgstr ""

#: ../../manual/faq.rst:659
msgid ""
"This keeps things simple, while allowing the compiler to generate optimized "
"code in all cases."
msgstr ""

#: ../../manual/faq.rst:662
msgid ""
"However, there are cases where you may need to declare different versions of"
" the outer function for different element types of ``a``. You could do it "
"like this::"
msgstr ""

#: ../../manual/faq.rst:673
msgid ""
"This works fine for ``Vector{T}``, but we'd also have to write explicit "
"versions for ``UnitRange{T}`` or other abstract types. To prevent such "
"tedium, you can use two parameters in the declaration of ``MyContainer``::"
msgstr ""

#: ../../manual/faq.rst:688
msgid ""
"Note the somewhat surprising fact that ``T`` doesn't appear in the "
"declaration of field ``a``, a point that we'll return to in a moment. With "
"this approach, one can write functions such as::"
msgstr ""

#: ../../manual/faq.rst:717
msgid ""
"As you can see, with this approach it's possible to specialize on both the "
"element type ``T`` and the array type ``A``."
msgstr ""

#: ../../manual/faq.rst:720
msgid ""
"However, there's one remaining hole: we haven't enforced that ``A`` has "
"element type ``T``, so it's perfectly possible to construct an object like "
"this::"
msgstr ""

#: ../../manual/faq.rst:729
msgid "To prevent this, we can add an inner constructor::"
msgstr ""

#: ../../manual/faq.rst:747
msgid ""
"The inner constructor requires that the element type of ``A`` be ``T``."
msgstr ""

#: ../../manual/faq.rst:750
msgid "Nothingness and missing values"
msgstr ""

#: ../../manual/faq.rst:753
msgid "How does \"null\" or \"nothingness\" work in Julia?"
msgstr ""

#: ../../manual/faq.rst:755
msgid ""
"Unlike many languages (for example, C and Java), Julia does not have a "
"\"null\" value. When a reference (variable, object field, or array element) "
"is uninitialized, accessing it will immediately throw an error. This "
"situation can be detected using the ``isdefined`` function."
msgstr ""

#: ../../manual/faq.rst:760
msgid ""
"Some functions are used only for their side effects, and do not need to "
"return a value. In these cases, the convention is to return the value "
"``nothing``, which is just a singleton object of type ``Void``. This is an "
"ordinary type with no fields; there is nothing special about it except for "
"this convention, and that the REPL does not print anything for it. Some "
"language constructs that would not otherwise have a value also yield "
"``nothing``, for example ``if false; end``."
msgstr ""

#: ../../manual/faq.rst:768
msgid ""
"For situations where a value exists only sometimes (for example, missing "
"statistical data), it is best to use the ``Nullable{T}`` type, which allows "
"specifying the type of a missing value."
msgstr ""

#: ../../manual/faq.rst:772
msgid ""
"The empty tuple (``()``) is another form of nothingness. But, it should not "
"really be thought of as nothing but rather a tuple of zero values."
msgstr ""

#: ../../manual/faq.rst:775
msgid ""
"In code written for Julia prior to version 0.4 you may occasionally see "
"``None``, which is quite different. It is the empty (or \"bottom\") type, a "
"type with no values and no subtypes (except itself). This is now written as "
"``Union()`` (an empty union type). You will generally not need to use this "
"type."
msgstr ""

#: ../../manual/faq.rst:781
msgid "Julia Releases"
msgstr ""

#: ../../manual/faq.rst:784
msgid "Do I want to use a release, beta, or nightly version of Julia?"
msgstr ""

#: ../../manual/faq.rst:786
msgid ""
"You may prefer the release version of Julia if you are looking for a stable "
"code base. Releases generally occur every 6 months, giving you a stable "
"platform for writing code."
msgstr ""

#: ../../manual/faq.rst:788
msgid ""
"You may prefer the beta version of Julia if you don't mind being slightly "
"behind the latest bugfixes and changes, but find the slightly faster rate of"
" changes more appealing. Additionally, these binaries are tested before they"
" are published to ensure they are fully functional."
msgstr ""

#: ../../manual/faq.rst:790
msgid ""
"You may prefer the nightly version of Julia if you want to take advantage of"
" the latest updates to the language, and don't mind if the version available"
" today occasionally doesn't actually work."
msgstr ""

#: ../../manual/faq.rst:792
msgid ""
"Finally, you may also consider building Julia from source for yourself. This"
" option is mainly for those individuals who are comfortable at the command "
"line, or interested in learning. If this describes you, you may also be "
"interested in reading our `guidelines for contributing`__."
msgstr ""

#: ../../manual/faq.rst:796
msgid ""
"Links to each of these download types can be found on the download page at "
"http://julialang.org/downloads/. Note that not all versions of Julia are "
"available for all platforms."
msgstr ""

#: ../../manual/faq.rst:799
msgid "When are deprecated functions removed?"
msgstr ""

#: ../../manual/faq.rst:801
msgid ""
"Deprecated functions are removed after the subsequent release. For example, "
"functions marked as deprecated in the 0.1 release will not be available "
"starting with the 0.2 release."
msgstr ""

#: ../../manual/faq.rst:804
msgid "Developing Julia"
msgstr ""

#: ../../manual/faq.rst:807
msgid ""
"How do I debug julia's C code? (running the julia REPL from within a "
"debugger like gdb)"
msgstr ""

#: ../../manual/faq.rst:809
msgid ""
"First, you should build the debug version of julia with ``make debug``.  "
"Below, lines starting with ``(gdb)`` mean things you should type at the gdb "
"prompt."
msgstr ""

#: ../../manual/faq.rst:814
msgid "From the shell"
msgstr ""

#: ../../manual/faq.rst:816
msgid ""
"The main challenge is that Julia and gdb each need to have their own "
"terminal, to allow you to interact with them both.  One approach is to use "
"gdb's ``attach`` functionality to debug an already-running julia session.  "
"However, on many systems you'll need root access to get this to work. What "
"follows is a method that can be implemented with just user-level "
"permissions."
msgstr ""

#: ../../manual/faq.rst:823
msgid ""
"The first time you do this, you'll need to define a script, here called "
"``oterm``, containing the following lines::"
msgstr ""

#: ../../manual/faq.rst:829
msgid "Make it executable with ``chmod +x oterm``."
msgstr ""

#: ../../manual/faq.rst:831
msgid "Now:"
msgstr ""

#: ../../manual/faq.rst:833
msgid ""
"From a shell (called shell 1), type ``xterm -e oterm &``. You'll see a new "
"window pop up; this will be called terminal 2."
msgstr ""

#: ../../manual/faq.rst:836
msgid ""
"From within shell 1, ``gdb julia-debug``. You can find this executable "
"within ``julia/usr/bin``."
msgstr ""

#: ../../manual/faq.rst:839
msgid ""
"From within shell 1, ``(gdb) tty /dev/pts/#`` where ``#`` is the number "
"shown after ``pts/`` in terminal 2."
msgstr ""

#: ../../manual/faq.rst:842
msgid "From within shell 1, ``(gdb) run``"
msgstr ""

#: ../../manual/faq.rst:844
msgid ""
"From within terminal 2, issue any preparatory commands in Julia that you "
"need to get to the step you want to debug"
msgstr ""

#: ../../manual/faq.rst:847
msgid "From within shell 1, hit Ctrl-C"
msgstr ""

#: ../../manual/faq.rst:849
msgid ""
"From within shell 1, insert your breakpoint, e.g., ``(gdb) b "
"codegen.cpp:2244``"
msgstr ""

#: ../../manual/faq.rst:850
msgid "From within shell 1, ``(gdb) c`` to resume execution of julia"
msgstr ""

#: ../../manual/faq.rst:852
msgid ""
"From within terminal 2, issue the command that you want to debug. Shell 1 "
"will stop at your breakpoint."
msgstr ""

#: ../../manual/faq.rst:857
msgid "Within emacs"
msgstr ""

#: ../../manual/faq.rst:859
msgid ""
"``M-x gdb``, then enter ``julia-debug`` (this is easiest from within "
"julia/usr/bin, or you can specify the full path)"
msgstr ""

#: ../../manual/faq.rst:862
msgid "``(gdb) run``"
msgstr ""

#: ../../manual/faq.rst:864
msgid ""
"Now you'll see the Julia prompt. Run any commands in Julia you need to get "
"to the step you want to debug."
msgstr ""

#: ../../manual/faq.rst:867
msgid ""
"Under emacs' \"Signals\" menu choose BREAK---this will return you to the "
"``(gdb)`` prompt"
msgstr ""

#: ../../manual/faq.rst:869
msgid "Set a breakpoint, e.g., ``(gdb) b codegen.cpp:2244``"
msgstr ""

#: ../../manual/faq.rst:871
msgid "Go back to the Julia prompt via ``(gdb) c``"
msgstr ""

#: ../../manual/faq.rst:873
msgid "Execute the Julia command you want to see running."
msgstr ""

#: ../../manual/functions.rst:7
msgid ""
"In Julia, a function is an object that maps a tuple of argument values to a "
"return value. Julia functions are not pure mathematical functions, in the "
"sense that functions can alter and be affected by the global state of the "
"program. The basic syntax for defining functions in Julia is:"
msgstr ""

#: ../../manual/functions.rst:24
msgid ""
"There is a second, more terse syntax for defining a function in Julia. The "
"traditional function declaration syntax demonstrated above is equivalent to "
"the following compact \"assignment form\"::"
msgstr ""

#: ../../manual/functions.rst:30
msgid ""
"In the assignment form, the body of the function must be a single "
"expression, although it can be a compound expression (see :ref:`man-"
"compound-expressions`). Short, simple function definitions are common in "
"Julia. The short function syntax is accordingly quite idiomatic, "
"considerably reducing both typing and visual noise."
msgstr ""

#: ../../manual/functions.rst:37
msgid "A function is called using the traditional parenthesis syntax:"
msgstr ""

#: ../../manual/functions.rst:44
msgid ""
"Without parentheses, the expression ``f`` refers to the function object, and"
" can be passed around like any value:"
msgstr ""

#: ../../manual/functions.rst:54
msgid ""
"There are two other ways that functions can be applied: using special "
"operator syntax for certain function names (see `Operators Are Functions "
"<#operators-are-functions>`_ below), or with the ``apply`` function:"
msgstr ""

#: ../../manual/functions.rst:64
msgid ""
"The ``apply`` function applies its first argument — a function object — to "
"its remaining arguments."
msgstr ""

#: ../../manual/functions.rst:67
msgid "As with variables, Unicode can also be used for function names::"
msgstr ""

#: ../../manual/functions.rst:74
msgid "Argument Passing Behavior"
msgstr ""

#: ../../manual/functions.rst:76
msgid ""
"Julia function arguments follow a convention sometimes called \"pass-by-"
"sharing\", which means that values are not copied when they are passed to "
"functions. Function arguments themselves act as new variable *bindings* (new"
" locations that can refer to values), but the values they refer to are "
"identical to the passed values. Modifications to mutable values (such as "
"Arrays) made within a function will be visible to the caller. This is the "
"same behavior found in Scheme, most Lisps, Python, Ruby and Perl, among "
"other dynamic languages."
msgstr ""

#: ../../manual/functions.rst:87
msgid "The ``return`` Keyword"
msgstr ""

#: ../../manual/functions.rst:89
msgid ""
"The value returned by a function is the value of the last expression "
"evaluated, which, by default, is the last expression in the body of the "
"function definition. In the example function, ``f``, from the previous "
"section this is the value of the expression ``x + y``. As in C and most "
"other imperative or functional languages, the ``return`` keyword causes a "
"function to return immediately, providing an expression whose value is "
"returned::"
msgstr ""

#: ../../manual/functions.rst:102
msgid ""
"Since function definitions can be entered into interactive sessions, it is "
"easy to compare these definitions::"
msgstr ""

#: ../../manual/functions.rst:118
msgid ""
"Of course, in a purely linear function body like ``g``, the usage of "
"``return`` is pointless since the expression ``x + y`` is never evaluated "
"and we could simply make ``x * y`` the last expression in the function and "
"omit the ``return``. In conjunction with other control flow, however, "
"``return`` is of real use. Here, for example, is a function that computes "
"the hypotenuse length of a right triangle with sides of length *x* and *y*, "
"avoiding overflow::"
msgstr ""

#: ../../manual/functions.rst:140
msgid ""
"There are three possible points of return from this function, returning the "
"values of three different expressions, depending on the values of *x* and "
"*y*. The ``return`` on the last line could be omitted since it is the last "
"expression."
msgstr ""

#: ../../manual/functions.rst:146
msgid "Operators Are Functions"
msgstr ""

#: ../../manual/functions.rst:148
msgid ""
"In Julia, most operators are just functions with support for special syntax."
" The exceptions are operators with special evaluation semantics like ``&&`` "
"and ``||``. These operators cannot be functions since :ref:`short-circuit "
"evaluation <man-short-circuit-evaluation>` requires that their operands are "
"not evaluated before evaluation of the operator. Accordingly, you can also "
"apply them using parenthesized argument lists, just as you would any other "
"function:"
msgstr ""

#: ../../manual/functions.rst:164
msgid ""
"The infix form is exactly equivalent to the function application form — in "
"fact the former is parsed to produce the function call internally. This also"
" means that you can assign and pass around operators such as ``+`` and ``*``"
" just like you would with other function values:"
msgstr ""

#: ../../manual/functions.rst:176
msgid ""
"Under the name ``f``, the function does not support infix notation, however."
msgstr ""

#: ../../manual/functions.rst:180
msgid "Operators With Special Names"
msgstr ""

#: ../../manual/functions.rst:182
msgid ""
"A few special expressions correspond to calls to functions with non-obvious "
"names. These are:"
msgstr ""

#: ../../manual/functions.rst:188
msgid "``hcat``"
msgstr ""

#: ../../manual/functions.rst:189
msgid "``vcat``"
msgstr ""

#: ../../manual/functions.rst:190
msgid "``hvcat``"
msgstr ""

#: ../../manual/functions.rst:191
msgid "``A'``"
msgstr ""

#: ../../manual/functions.rst:191
msgid "``ctranspose``"
msgstr ""

#: ../../manual/functions.rst:192
msgid "``A.'``"
msgstr ""

#: ../../manual/functions.rst:192
msgid "``transpose``"
msgstr ""

#: ../../manual/functions.rst:193
msgid "``1:n``"
msgstr ""

#: ../../manual/functions.rst:193
msgid "``colon``"
msgstr ""

#: ../../manual/functions.rst:194
msgid "``A[i]``"
msgstr ""

#: ../../manual/functions.rst:194
msgid "``getindex``"
msgstr ""

#: ../../manual/functions.rst:195
msgid "``A[i]=x``"
msgstr ""

#: ../../manual/functions.rst:195
msgid "``setindex!``"
msgstr ""

#: ../../manual/functions.rst:198
msgid ""
"These functions are included in the ``Base.Operators`` module even though "
"they do not have operator-like names."
msgstr ""

#: ../../manual/functions.rst:204
msgid "Anonymous Functions"
msgstr ""

#: ../../manual/functions.rst:206
msgid ""
"Functions in Julia are `first-class objects <http://en.wikipedia.org/wiki"
"/First-class_citizen>`_: they can be assigned to variables, called using the"
" standard function call syntax from the variable they have been assigned to."
" They can be used as arguments, and they can be returned as values. They can"
" also be created anonymously, without being given a name:"
msgstr ""

#: ../../manual/functions.rst:218
msgid ""
"This creates an unnamed function taking one argument *x* and returning the "
"value of the polynomial *x*\\ ^2 + 2\\ *x* - 1 at that value. The primary "
"use for anonymous functions is passing them to functions which take other "
"functions as arguments. A classic example is the ``map`` function, which "
"applies a function to each value of an array and returns a new array "
"containing the resulting values:"
msgstr ""

#: ../../manual/functions.rst:233
msgid ""
"This is fine if a named function effecting the transform one wants already "
"exists to pass as the first argument to ``map``. Often, however, a ready-to-"
"use, named function does not exist. In these situations, the anonymous "
"function construct allows easy creation of a single-use function object "
"without needing a name:"
msgstr ""

#: ../../manual/functions.rst:247
msgid ""
"An anonymous function accepting multiple arguments can be written using the "
"syntax ``(x,y,z)->2x+y-z``. A zero-argument anonymous function is written as"
" ``()->3``. The idea of a function with no arguments may seem strange, but "
"is useful for \"delaying\" a computation. In this usage, a block of code is "
"wrapped in a zero-argument function, which is later invoked by calling it as"
" ``f()``."
msgstr ""

#: ../../manual/functions.rst:255
msgid "Multiple Return Values"
msgstr ""

#: ../../manual/functions.rst:257
msgid ""
"In Julia, one returns a tuple of values to simulate returning multiple "
"values. However, tuples can be created and destructured without needing "
"parentheses, thereby providing an illusion that multiple values are being "
"returned, rather than a single tuple value. For example, the following "
"function returns a pair of values:"
msgstr ""

#: ../../manual/functions.rst:269
msgid ""
"If you call it in an interactive session without assigning the return value "
"anywhere, you will see the tuple returned:"
msgstr ""

#: ../../manual/functions.rst:277
msgid ""
"A typical usage of such a pair of return values, however, extracts each "
"value into a variable. Julia supports simple tuple \"destructuring\" that "
"facilitates this:"
msgstr ""

#: ../../manual/functions.rst:291
msgid ""
"You can also return multiple values via an explicit usage of the ``return`` "
"keyword::"
msgstr ""

#: ../../manual/functions.rst:298
msgid "This has the exact same effect as the previous definition of ``foo``."
msgstr ""

#: ../../manual/functions.rst:301
msgid "Varargs Functions"
msgstr ""

#: ../../manual/functions.rst:303
msgid ""
"It is often convenient to be able to write functions taking an arbitrary "
"number of arguments. Such functions are traditionally known as \"varargs\" "
"functions, which is short for \"variable number of arguments\". You can "
"define a varargs function by following the last argument with an ellipsis:"
msgstr ""

#: ../../manual/functions.rst:314
msgid ""
"The variables ``a`` and ``b`` are bound to the first two argument values as "
"usual, and the variable ``x`` is bound to an iterable collection of the zero"
" or more values passed to ``bar`` after its first two arguments:"
msgstr ""

#: ../../manual/functions.rst:332
msgid ""
"In all these cases, ``x`` is bound to a tuple of the trailing values passed "
"to ``bar``."
msgstr ""

#: ../../manual/functions.rst:335
msgid ""
"On the flip side, it is often handy to \"splice\" the values contained in an"
" iterable collection into a function call as individual arguments. To do "
"this, one also uses ``...`` but in the function call instead:"
msgstr ""

#: ../../manual/functions.rst:347
msgid ""
"In this case a tuple of values is spliced into a varargs call precisely "
"where the variable number of arguments go. This need not be the case, "
"however:"
msgstr ""

#: ../../manual/functions.rst:365
msgid ""
"Furthermore, the iterable object spliced into a function call need not be a "
"tuple:"
msgstr ""

#: ../../manual/functions.rst:388
msgid ""
"Also, the function that arguments are spliced into need not be a varargs "
"function (although it often is)::"
msgstr ""

#: ../../manual/functions.rst:410
msgid ""
"As you can see, if the wrong number of elements are in the spliced "
"container, then the function call will fail, just as it would if too many "
"arguments were given explicitly."
msgstr ""

#: ../../manual/functions.rst:415
msgid "Optional Arguments"
msgstr ""

#: ../../manual/functions.rst:417
msgid ""
"In many cases, function arguments have sensible default values and therefore"
" might not need to be passed explicitly in every call. For example, the "
"library function ``parseint(num,base)`` interprets a string as a number in "
"some base. The ``base`` argument defaults to ``10``. This behavior can be "
"expressed concisely as::"
msgstr ""

#: ../../manual/functions.rst:427
msgid ""
"With this definition, the function can be called with either one or two "
"arguments, and ``10`` is automatically passed when a second argument is not "
"specified:"
msgstr ""

#: ../../manual/functions.rst:442
msgid ""
"Optional arguments are actually just a convenient syntax for writing "
"multiple method definitions with different numbers of arguments (see :ref"
":`man-methods`)."
msgstr ""

#: ../../manual/functions.rst:448
msgid "Keyword Arguments"
msgstr ""

#: ../../manual/functions.rst:450
msgid ""
"Some functions need a large number of arguments, or have a large number of "
"behaviors. Remembering how to call such functions can be difficult. Keyword "
"arguments can make these complex interfaces easier to use and extend by "
"allowing arguments to be identified by name instead of only by position."
msgstr ""

#: ../../manual/functions.rst:455
msgid ""
"For example, consider a function ``plot`` that plots a line. This function "
"might have many options, for controlling line style, width, color, and so "
"on. If it accepts keyword arguments, a possible call might look like "
"``plot(x, y, width=2)``, where we have chosen to specify only line width. "
"Notice that this serves two purposes. The call is easier to read, since we "
"can label an argument with its meaning. It also becomes possible to pass any"
" subset of a large number of arguments, in any order."
msgstr ""

#: ../../manual/functions.rst:464
msgid ""
"Functions with keyword arguments are defined using a semicolon in the "
"signature::"
msgstr ""

#: ../../manual/functions.rst:471
msgid ""
"When the function is called, the semicolon is optional: one can either call "
"``plot(x, y, width=2)`` or ``plot(x, y; width=2)``, but the former style is "
"more common.  An explicit semicolon is required only for passing varargs or "
"computed keywords as described below."
msgstr ""

#: ../../manual/functions.rst:476
msgid ""
"Keyword argument default values are evaluated only when necessary (when a "
"corresponding keyword argument is not passed), and in left-to-right order. "
"Therefore default expressions may refer to prior keyword arguments."
msgstr ""

#: ../../manual/functions.rst:481
msgid ""
"Extra keyword arguments can be collected using ``...``, as in varargs "
"functions::"
msgstr ""

#: ../../manual/functions.rst:488
msgid ""
"Inside ``f``, ``args`` will be a collection of ``(key,value)`` tuples, where"
" each ``key`` is a symbol. Such collections can be passed as keyword "
"arguments using a semicolon in a call, e.g. ``f(x, z=1; args...)``. "
"Dictionaries can also be used for this purpose."
msgstr ""

#: ../../manual/functions.rst:493
msgid ""
"In addition, one can also pass ``(key,value)`` tuples, or any iterable "
"expression (such as a ``=>`` pair) that can be assigned to such a tuple, "
"explicitly after a semicolon.  For example, ``plot(x, y; (:width,2))`` and "
"``plot(x, y; :width => 2)`` are equivalent to ``plot(x, y, width=2)``.  This"
" is useful in situations where the keyword name is computed at runtime."
msgstr ""

#: ../../manual/functions.rst:502
msgid "Evaluation Scope of Default Values"
msgstr ""

#: ../../manual/functions.rst:504
msgid ""
"Optional and keyword arguments differ slightly in how their default values "
"are evaluated. When optional argument default expressions are evaluated, "
"only *previous* arguments are in scope. In contrast, *all* the arguments are"
" in scope when keyword arguments default expressions are evaluated. For "
"example, given this definition::"
msgstr ""

#: ../../manual/functions.rst:514
msgid ""
"the ``b`` in ``a=b`` refers to a ``b`` in an outer scope, not the subsequent"
" argument ``b``. However, if ``a`` and ``b`` were keyword arguments instead,"
" then both would be created in the same scope and the ``b`` in ``a=b`` would"
" refer the the subsequent argument ``b`` (shadowing any ``b`` in an outer "
"scope), which would result in an undefined variable error (since the default"
" expressions are evaluated left-to-right, and ``b`` has not been assigned "
"yet)."
msgstr ""

#: ../../manual/functions.rst:524
msgid "Block Syntax for Function Arguments"
msgstr ""

#: ../../manual/functions.rst:526
msgid ""
"Passing functions as arguments to other functions is a powerful technique, "
"but the syntax for it is not always convenient. Such calls are especially "
"awkward to write when the function argument requires multiple lines. As an "
"example, consider calling ``map`` on a function with several cases::"
msgstr ""

#: ../../manual/functions.rst:542
msgid ""
"Julia provides a reserved word ``do`` for rewriting this code more clearly::"
msgstr ""

#: ../../manual/functions.rst:554
msgid ""
"The ``do x`` syntax creates an anonymous function with argument ``x`` and "
"passes it as the first argument to ``map``. Similarly, ``do a,b`` would "
"create a two-argument anonymous function, and a plain ``do`` would declare "
"that what follows is an anonymous function of the form ``() -> ...``."
msgstr ""

#: ../../manual/functions.rst:560
msgid ""
"How these arguments are initialized depends on the \"outer\" function; here,"
" ``map`` will sequentially set ``x`` to ``A``, ``B``, ``C``, calling the "
"anonymous function on each, just as would happen in the syntax ``map(func, "
"[A, B, C])``."
msgstr ""

#: ../../manual/functions.rst:565
msgid ""
"This syntax makes it easier to use functions to effectively extend the "
"language, since calls look like normal code blocks. There are many possible "
"uses quite different from ``map``, such as managing system state. For "
"example, there is a version of ``open`` that runs code ensuring that the "
"opened file is eventually closed::"
msgstr ""

#: ../../manual/functions.rst:575
msgid "This is accomplished by the following definition::"
msgstr ""

#: ../../manual/functions.rst:586
msgid ""
"In contrast to the ``map`` example, here ``io`` is initialized by the "
"*result* of ``open(\"outfile\", \"w\")``.  The stream is then passed to your"
" anonymous function, which performs the writing; finally, the ``open`` "
"function ensures that the stream is closed after your function exits.  The "
"``try/finally`` construct will be described in :ref:`man-control-flow`."
msgstr ""

#: ../../manual/functions.rst:593
msgid ""
"With the ``do`` block syntax, it helps to check the documentation or "
"implementation to know how the arguments of the user function are "
"initialized."
msgstr ""

#: ../../manual/functions.rst:598
msgid "Further Reading"
msgstr ""

#: ../../manual/functions.rst:600
msgid ""
"We should mention here that this is far from a complete picture of defining "
"functions. Julia has a sophisticated type system and allows multiple "
"dispatch on argument types. None of the examples given here provide any type"
" annotations on their arguments, meaning that they are applicable to all "
"types of arguments. The type system is described in :ref:`man-types` and "
"defining a function in terms of methods chosen by multiple dispatch on run-"
"time argument types is described in :ref:`man-methods`."
msgstr ""

#: ../../manual/getting-started.rst:5
msgid "Getting Started"
msgstr ""

#: ../../manual/getting-started.rst:7
msgid ""
"Julia installation is straightforward, whether using precompiled binaries or"
" compiling from source. Download and install Julia by following the "
"instructions at `http://julialang.org/downloads/ "
"<http://julialang.org/downloads/>`_."
msgstr ""

#: ../../manual/getting-started.rst:12
msgid ""
"The easiest way to learn and experiment with Julia is by starting an "
"interactive session (also known as a read-eval-print loop or \"repl\") by "
"double-clicking the Julia executable or running ``julia`` from the command "
"line::"
msgstr ""

#: ../../manual/getting-started.rst:33
msgid ""
"To exit the interactive session, type ``^D`` — the control key together with"
" the ``d`` key or type ``quit()``. When run in interactive mode, ``julia`` "
"displays a banner and prompts the user for input. Once the user has entered "
"a complete expression, such as ``1 + 2``, and hits enter, the interactive "
"session evaluates the expression and shows its value. If an expression is "
"entered into an interactive session with a trailing semicolon, its value is "
"not shown. The variable ``ans`` is bound to the value of the last evaluated "
"expression whether it is shown or not. The ``ans`` variable is only bound in"
" interactive sessions, not when Julia code is run in other ways."
msgstr ""

#: ../../manual/getting-started.rst:44
msgid ""
"To evaluate expressions written in a source file ``file.jl``, write "
"``include(\"file.jl\")``."
msgstr ""

#: ../../manual/getting-started.rst:47
msgid ""
"To run code in a file non-interactively, you can give it as the first "
"argument to the julia command::"
msgstr ""

#: ../../manual/getting-started.rst:52
msgid ""
"As the example implies, the following command-line arguments to julia are "
"taken as command-line arguments to the program ``script.jl``, passed in the "
"global constant ``ARGS``. ``ARGS`` is also set when script code is given "
"using the ``-e`` option on the command line (see the ``julia`` help output "
"below). For example, to just print the arguments given to a script, you "
"could do this::"
msgstr ""

#: ../../manual/getting-started.rst:63
msgid "Or you could put that code into a script and run it::"
msgstr ""

#: ../../manual/getting-started.rst:70
msgid ""
"Julia can be started in parallel mode with either the ``-p`` or the "
"``--machinefile`` options. ``-p n`` will launch an additional ``n`` worker "
"processes, while ``--machinefile file`` will launch a worker for each line "
"in file ``file``. The machines defined in ``file`` must be accessible via a "
"passwordless ``ssh`` login, with Julia installed at the same location as the"
" current host. Each machine definition takes the form "
"``[count*][user@]host[:port] [bind_addr[:port]]`` . ``user`` defaults to "
"current user, ``port`` to the standard ssh port. ``count`` is the number of "
"workers to spawn on the node, and defaults to 1. The optional ``bind-to "
"bind_addr[:port]`` specifies the ip-address and port that other workers "
"should use to connect to this worker."
msgstr ""

#: ../../manual/getting-started.rst:83
msgid ""
"If you have code that you want executed whenever julia is run, you can put "
"it in ``~/.juliarc.jl``:"
msgstr ""

#: ../../manual/getting-started.rst:102
msgid ""
"There are various ways to run Julia code and provide options, similar to "
"those available for the ``perl`` and ``ruby`` programs::"
msgstr ""

#: ../../manual/getting-started.rst:140
msgid "Resources"
msgstr ""

#: ../../manual/getting-started.rst:142
msgid ""
"In addition to this manual, there are various other resources that may help "
"new users get started with julia:"
msgstr ""

#: ../../manual/getting-started.rst:145
msgid ""
"`Julia and IJulia cheatsheet <http://math.mit.edu/~stevenj/Julia-"
"cheatsheet.pdf>`_"
msgstr ""

#: ../../manual/getting-started.rst:146
msgid ""
"`Learn Julia in a few minutes <http://learnxinyminutes.com/docs/julia/>`_"
msgstr ""

#: ../../manual/getting-started.rst:147
msgid ""
"`Tutorial for Homer Reid's numerical analysis class "
"<http://homerreid.dyndns.org/teaching/18.330/JuliaProgramming.shtml>`_"
msgstr ""

#: ../../manual/getting-started.rst:148
msgid ""
"`An introductory presentation <https://raw.githubusercontent.com/ViralBShah"
"/julia-presentations/master/Fifth-Elephant-2013/Fifth-Elephant-2013.pdf>`_"
msgstr ""

#: ../../manual/getting-started.rst:149
msgid ""
"`Videos from the Julia tutorial at MIT <http://julialang.org/blog/2013/03"
"/julia-tutorial-MIT/>`_"
msgstr ""

#: ../../manual/getting-started.rst:150
msgid ""
"`Forio Julia Tutorials <http://forio.com/labs/julia-studio/tutorials/>`_"
msgstr ""

#: ../../manual/index.rst:6
msgid "The Julia Manual"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:5
msgid "Integers and Floating-Point Numbers"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:7
msgid ""
"Integers and floating-point values are the basic building blocks of "
"arithmetic and computation. Built-in representations of such values are "
"called numeric primitives, while representations of integers and floating-"
"point numbers as immediate values in code are known as numeric literals. For"
" example, ``1`` is an integer literal, while ``1.0`` is a floating-point "
"literal; their binary in-memory representations as objects are numeric "
"primitives."
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:15
msgid ""
"Julia provides a broad range of primitive numeric types, and a full "
"complement of arithmetic and bitwise operators as well as standard "
"mathematical functions are defined over them. These map directly onto "
"numeric types and operations that are natively supported on modern "
"computers, thus allowing Julia to take full advantage of computational "
"resources. Additionally, Julia provides software support for :ref:`man-"
"arbitrary-precision-arithmetic`, which can handle operations on numeric "
"values that cannot be represented effectively in native hardware "
"representations, but at the cost of relatively slower performance."
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:25
msgid "The following are Julia's primitive numeric types:"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:27
msgid "**Integer types:**"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:30
#: ../../manual/integers-and-floating-point-numbers.rst:48
msgid "Type"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:30
msgid "Signed?"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:30
#: ../../manual/integers-and-floating-point-numbers.rst:48
msgid "Number of bits"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:30
msgid "Smallest value"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:30
msgid "Largest value"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:32
msgid "``Int8``"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:32
#: ../../manual/integers-and-floating-point-numbers.rst:34
#: ../../manual/integers-and-floating-point-numbers.rst:36
#: ../../manual/integers-and-floating-point-numbers.rst:38
#: ../../manual/integers-and-floating-point-numbers.rst:40
msgid "✓"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:32
#: ../../manual/integers-and-floating-point-numbers.rst:33
#: ../../manual/integers-and-floating-point-numbers.rst:42
msgid "8"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:32
msgid "-2^7"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:32
msgid "2^7 - 1"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:33
#: ../../manual/integers-and-floating-point-numbers.rst:35
#: ../../manual/integers-and-floating-point-numbers.rst:37
#: ../../manual/integers-and-floating-point-numbers.rst:39
#: ../../manual/integers-and-floating-point-numbers.rst:41
msgid "0"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:33
msgid "2^8 - 1"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:34
#: ../../manual/integers-and-floating-point-numbers.rst:35
#: ../../manual/integers-and-floating-point-numbers.rst:50
msgid "16"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:34
msgid "-2^15"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:34
msgid "2^15 - 1"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:35
msgid "2^16 - 1"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:36
#: ../../manual/integers-and-floating-point-numbers.rst:37
#: ../../manual/integers-and-floating-point-numbers.rst:51
msgid "32"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:36
msgid "-2^31"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:36
msgid "2^31 - 1"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:37
msgid "2^32 - 1"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:38
#: ../../manual/integers-and-floating-point-numbers.rst:39
#: ../../manual/integers-and-floating-point-numbers.rst:52
msgid "64"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:38
msgid "-2^63"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:38
msgid "2^63 - 1"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:39
msgid "2^64 - 1"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:40
msgid "``Int128``"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:40
#: ../../manual/integers-and-floating-point-numbers.rst:41
msgid "128"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:40
msgid "-2^127"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:40
msgid "2^127 - 1"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:41
msgid "``UInt128``"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:41
msgid "2^128 - 1"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:42
msgid "``Bool``"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:42
msgid "N/A"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:42
msgid "``false`` (0)"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:42
msgid "``true`` (1)"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:45
msgid "**Floating-point types:**"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:48
msgid "Precision"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:50
#: ../../manual/integers-and-floating-point-numbers.rst:357
msgid "``Float16``"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:50
msgid "half_"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:51
msgid "single_"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:52
msgid "double_"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:59
msgid ""
"Additionally, full support for :ref:`man-complex-and-rational-numbers` is "
"built on top of these primitive numeric types. All numeric types "
"interoperate naturally without explicit casting, thanks to a flexible, user-"
"extensible :ref:`type promotion system <man-conversion-and-promotion>`."
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:65
msgid "Integers"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:67
msgid "Literal integers are represented in the standard manner:"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:77
msgid ""
"The default type for an integer literal depends on whether the target system"
" has a 32-bit architecture or a 64-bit architecture::"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:88
msgid ""
"The Julia internal variable ``WORD_SIZE`` indicates whether the target "
"system is 32-bit or 64-bit.::"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:99
msgid ""
"Julia also defines the types ``Int`` and ``UInt``, which are aliases for the"
" system's signed and unsigned native integer types respectively.::"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:115
msgid ""
"Larger integer literals that cannot be represented using only 32 bits but "
"can be represented in 64 bits always create 64-bit integers, regardless of "
"the system type::"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:123
msgid ""
"Unsigned integers are input and output using the ``0x`` prefix and "
"hexadecimal (base 16) digits ``0-9a-f`` (the capitalized digits ``A-F`` also"
" work for input). The size of the unsigned value is determined by the number"
" of hex digits used:"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:153
msgid ""
"This behavior is based on the observation that when one uses unsigned hex "
"literals for integer values, one typically is using them to represent a "
"fixed numeric byte sequence, rather than just an integer value."
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:158
msgid ""
"Recall that the variable ``ans`` is set to the value of the last expression "
"evaluated in an interactive session. This does not occur when Julia code is "
"run in other ways."
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:162
msgid "Binary and octal literals are also supported:"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:178
msgid ""
"The minimum and maximum representable values of primitive numeric types such"
" as integers are given by the ``typemin`` and ``typemax`` functions:"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:200
msgid ""
"The values returned by ``typemin`` and ``typemax`` are always of the given "
"argument type. (The above expression uses several features we have yet to "
"introduce, including :ref:`for loops <man-loops>`, :ref:`man-strings`, and "
":ref:`man-string-interpolation`, but should be easy enough to understand for"
" users with some existing programming experience.)"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:209
msgid "Overflow behavior"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:211
msgid ""
"In Julia, exceeding the maximum representable value of a given type results "
"in a wraparound behavior:"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:225
msgid ""
"Thus, arithmetic with Julia integers is actually a form of `modular "
"arithmetic <http://en.wikipedia.org/wiki/Modular_arithmetic>`_. This "
"reflects the characteristics of the underlying arithmetic of integers as "
"implemented on modern computers. In applications where overflow is possible,"
" explicit checking for wraparound produced by overflow is essential; "
"otherwise, the ``BigInt`` type in :ref:`man-arbitrary-precision-arithmetic` "
"is recommended instead."
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:232
msgid ""
"To minimize the practical impact of this overflow, integer addition, "
"subtraction, multiplication, and exponentiation operands are promoted to "
"``Int`` or ``UInt`` from narrower integer types.  (However, divisions, "
"remainders, and bitwise operations do not promote narrower types.)"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:239
msgid "Division errors"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:241
msgid ""
"Integer division (the ``div`` function) has two exceptional cases: dividing "
"by zero, and dividing the lowest negative number (``typemin``) by -1. Both "
"of these cases throw a ``DivideError``. The remainder and modulus functions "
"(``rem`` and ``mod``) throw a ``DivideError`` when their second argument is "
"zero."
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:248
msgid "Floating-Point Numbers"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:250
msgid ""
"Literal floating-point numbers are represented in the standard formats:"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:275
msgid ""
"The above results are all ``Float64`` values. Literal ``Float32`` values can"
" be entered by writing an ``f`` in place of ``e``:"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:289
msgid "Values can be converted to ``Float32`` easily:"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:299
msgid ""
"Hexadecimal floating-point literals are also valid, but only as ``Float64`` "
"values:"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:315
msgid ""
"Half-precision floating-point numbers are also supported (``Float16``), but "
"only as a storage format. In calculations they'll be converted to "
"``Float32``:"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:328
msgid "Floating-point zero"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:330
msgid ""
"Floating-point numbers have `two zeros "
"<http://en.wikipedia.org/wiki/Signed_zero>`_, positive zero and negative "
"zero. They are equal to each other but have different binary "
"representations, as can be seen using the ``bits`` function: :"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:349
msgid "Special floating-point values"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:351
msgid ""
"There are three specified standard floating-point values that do not "
"correspond to any point on the real number line:"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:355
msgid "Special value"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:355
#: ../../manual/mathematical-operations.rst:20
#: ../../manual/mathematical-operations.rst:36
#: ../../manual/mathematical-operations.rst:69
#: ../../manual/mathematical-operations.rst:149
msgid "Name"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:359
msgid "``Inf16``"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:359
msgid "``Inf32``"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:359
msgid "``Inf``"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:359
msgid "positive infinity"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:359
msgid "a value greater than all finite floating-point values"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:360
msgid "``-Inf16``"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:360
msgid "``-Inf32``"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:360
msgid "``-Inf``"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:360
msgid "negative infinity"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:360
msgid "a value less than all finite floating-point values"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:361
msgid "``NaN16``"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:361
msgid "``NaN32``"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:361
msgid "``NaN``"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:361
msgid "not a number"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:361
msgid "a value not ``==`` to any floating-point value (including itself)"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:364
msgid ""
"For further discussion of how these non-finite floating-point values are "
"ordered with respect to each other and other floats, see :ref:`man-numeric-"
"comparisons`. By the `IEEE 754 standard "
"<http://en.wikipedia.org/wiki/IEEE_754-2008>`_, these floating-point values "
"are the results of certain arithmetic operations:"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:408
msgid ""
"The ``typemin`` and ``typemax`` functions also apply to floating-point "
"types:"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:424
msgid "Machine epsilon"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:426
msgid ""
"Most real numbers cannot be represented exactly with floating-point numbers,"
" and so for many purposes it is important to know the distance between two "
"adjacent representable floating-point numbers, which is often known as "
"`machine epsilon <http://en.wikipedia.org/wiki/Machine_epsilon>`_."
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:431
msgid ""
"Julia provides the ``eps`` function, which gives the distance between "
"``1.0`` and the next larger representable floating-point value:"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:445
msgid ""
"These values are ``2.0^-23`` and ``2.0^-52`` as ``Float32`` and ``Float64`` "
"values, respectively. The ``eps`` function can also take a floating-point "
"value as an argument, and gives the absolute difference between that value "
"and the next representable floating point value. That is, ``eps(x)`` yields "
"a value of the same type as ``x`` such that ``x + eps(x)`` is the next "
"representable floating-point value larger than ``x``:"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:467
msgid ""
"The distance between two adjacent representable floating-point numbers is "
"not constant, but is smaller for smaller values and larger for larger "
"values. In other words, the representable floating-point numbers are densest"
" in the real number line near zero, and grow sparser exponentially as one "
"moves farther away from zero. By definition, ``eps(1.0)`` is the same as "
"``eps(Float64)`` since ``1.0`` is a 64-bit floating-point value."
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:474
msgid ""
"Julia also provides the ``nextfloat`` and ``prevfloat`` functions which "
"return the next largest or smallest representable floating-point number to "
"the argument respectively: :"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:498
msgid ""
"This example highlights the general principle that the adjacent "
"representable floating-point numbers also have adjacent binary integer "
"representations."
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:502
msgid "Rounding modes"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:504
msgid ""
"If a number doesn't have an exact floating-point representation, it must be "
"rounded to an appropriate representable value, however, if wanted, the "
"manner in which this rounding is done can be changed according to the "
"rounding modes presented in the `IEEE 754 standard "
"<http://en.wikipedia.org/wiki/IEEE_754-2008>`_::"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:518
msgid ""
"The default mode used is always ``RoundNearest``, which rounds to the "
"nearest representable value, with ties rounded towards the nearest value "
"with an even least significant bit."
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:523
msgid "Background and References"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:525
msgid ""
"Floating-point arithmetic entails many subtleties which can be surprising to"
" users who are unfamiliar with the low-level implementation details. "
"However, these subtleties are described in detail in most books on "
"scientific computation, and also in the following references:"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:530
msgid ""
"The definitive guide to floating point arithmetic is the `IEEE 754-2008 "
"Standard <http://standards.ieee.org/findstds/standard/754-2008.html>`_; "
"however, it is not available for free online."
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:533
msgid ""
"For a brief but lucid presentation of how floating-point numbers are "
"represented, see John D. Cook's `article "
"<http://www.johndcook.com/blog/2009/04/06/anatomy-of-a-floating-point-"
"number/>`_ on the subject as well as his `introduction "
"<http://www.johndcook.com/blog/2009/04/06/numbers-are-a-leaky-"
"abstraction/>`_ to some of the issues arising from how this representation "
"differs in behavior from the idealized abstraction of real numbers."
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:540
msgid ""
"Also recommended is Bruce Dawson's `series of blog posts on floating-point "
"numbers <http://randomascii.wordpress.com/2012/05/20/thats-not-normalthe-"
"performance-of-odd-floats/>`_."
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:542
msgid ""
"For an excellent, in-depth discussion of floating-point numbers and issues "
"of numerical accuracy encountered when computing with them, see David "
"Goldberg's paper `What Every Computer Scientist Should Know About Floating-"
"Point Arithmetic "
"<http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.102.244&rep=rep1&type=pdf>`_."
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:547
msgid ""
"For even more extensive documentation of the history of, rationale for, and "
"issues with floating-point numbers, as well as discussion of many other "
"topics in numerical computing, see the `collected writings "
"<http://www.cs.berkeley.edu/~wkahan/>`_ of `William Kahan "
"<http://en.wikipedia.org/wiki/William_Kahan>`_, commonly known as the "
"\"Father of Floating-Point\". Of particular interest may be `An Interview "
"with the Old Man of Floating-Point "
"<http://www.cs.berkeley.edu/~wkahan/ieee754status/754story.html>`_."
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:559
msgid "Arbitrary Precision Arithmetic"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:561
msgid ""
"To allow computations with arbitrary-precision integers and floating point "
"numbers, Julia wraps the `GNU Multiple Precision Arithmetic Library (GMP) "
"<https://gmplib.org>`_ and the `GNU MPFR Library <http://www.mpfr.org>`_, "
"respectively. The `BigInt` and `BigFloat` types are available in Julia for "
"arbitrary precision integer and floating point numbers respectively."
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:566
msgid ""
"Constructors exist to create these types from primitive numerical types, or "
"from ``AbstractString``. Once created, they participate in arithmetic with "
"all other numeric types thanks to Julia's :ref:`type promotion and "
"conversion mechanism <man-conversion-and-promotion>`. :"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:587
msgid ""
"However, type promotion between the primitive types above and "
"`BigInt`/`BigFloat` is not automatic and must be explicitly stated. :"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:610
msgid ""
"The default precision (in number of bits of the significand) and rounding "
"mode of `BigFloat` operations can be changed, and all further calculations "
"will take these changes in account:"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:635
msgid "Numeric Literal Coefficients"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:637
msgid ""
"To make common numeric formulas and expressions clearer, Julia allows "
"variables to be immediately preceded by a numeric literal, implying "
"multiplication. This makes writing polynomial expressions much cleaner:"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:652
msgid "It also makes writing exponential functions more elegant:"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:659
msgid ""
"The precedence of numeric literal coefficients is the same as that of unary "
"operators such as negation. So ``2^3x`` is parsed as ``2^(3x)``, and "
"``2x^3`` is parsed as ``2*(x^3)``."
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:663
msgid ""
"Numeric literals also work as coefficients to parenthesized expressions:"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:671
msgid ""
"Additionally, parenthesized expressions can be used as coefficients to "
"variables, implying multiplication of the expression by the variable:"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:679
msgid ""
"Neither juxtaposition of two parenthesized expressions, nor placing a "
"variable before a parenthesized expression, however, can be used to imply "
"multiplication:"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:691
msgid ""
"Both of these expressions are interpreted as function application: any "
"expression that is not a numeric literal, when immediately followed by a "
"parenthetical, is interpreted as a function applied to the values in "
"parentheses (see :ref:`man-functions` for more about functions). Thus, in "
"both of these cases, an error occurs since the left-hand value is not a "
"function."
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:698
msgid ""
"The above syntactic enhancements significantly reduce the visual noise "
"incurred when writing common mathematical formulae. Note that no whitespace "
"may come between a numeric literal coefficient and the identifier or "
"parenthesized expression which it multiplies."
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:704
msgid "Syntax Conflicts"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:706
msgid ""
"Juxtaposed literal coefficient syntax may conflict with two numeric literal "
"syntaxes: hexadecimal integer literals and engineering notation for "
"floating-point literals. Here are some situations where syntactic conflicts "
"arise:"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:711
msgid ""
"The hexadecimal integer literal expression ``0xff`` could be interpreted as "
"the numeric literal ``0`` multiplied by the variable ``xff``."
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:714
msgid ""
"The floating-point literal expression ``1e10`` could be interpreted as the "
"numeric literal ``1`` multiplied by the variable ``e10``, and similarly with"
" the equivalent ``E`` form."
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:718
msgid ""
"In both cases, we resolve the ambiguity in favor of interpretation as a "
"numeric literals:"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:721
msgid "Expressions starting with ``0x`` are always hexadecimal literals."
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:722
msgid ""
"Expressions starting with a numeric literal followed by ``e`` or ``E`` are "
"always floating-point literals."
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:726
msgid "Literal zero and one"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:728
msgid ""
"Julia provides functions which return literal 0 and 1 corresponding to a "
"specified type or the type of a given variable."
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:734
msgid "``zero(x)``"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:734
msgid "Literal zero of type ``x`` or type of variable ``x``"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:735
msgid "``one(x)``"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:735
msgid "Literal one of type ``x`` or type of variable ``x``"
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:738
msgid ""
"These functions are useful in :ref:`man-numeric-comparisons` to avoid "
"overhead from unnecessary :ref:`type conversion <man-conversion-and-"
"promotion>`."
msgstr ""

#: ../../manual/integers-and-floating-point-numbers.rst:741
msgid "Examples:"
msgstr ""

#: ../../manual/interacting-with-julia.rst:5
msgid "Interacting With Julia"
msgstr ""

#: ../../manual/interacting-with-julia.rst:7
msgid ""
"Julia comes with a full-featured interactive command-line REPL (read-eval-"
"print loop) built into the ``julia`` executable.  In addition to allowing "
"quick and easy evaluation of Julia statements, it has a searchable history, "
"tab-completion, many helpful keybindings, and dedicated help and shell "
"modes.  The REPL can be started by simply calling julia with no arguments or"
" double-clicking on the executable::"
msgstr ""

#: ../../manual/interacting-with-julia.rst:21
msgid ""
"To exit the interactive session, type ``^D`` — the control key together with"
" the ``d`` key on a blank line — or type ``quit()`` followed by the return "
"or enter key. The REPL greets you with a banner and a ``julia>`` prompt."
msgstr ""

#: ../../manual/interacting-with-julia.rst:24
msgid "The different prompt modes"
msgstr ""

#: ../../manual/interacting-with-julia.rst:27
msgid "The Julian mode"
msgstr ""

#: ../../manual/interacting-with-julia.rst:29
msgid ""
"The REPL has four main modes of operation.  The first and most common is the"
" Julian prompt.  It is the default mode of operation; each new line "
"initially starts with ``julia>``.  It is here that you can enter Julia "
"expressions.  Hitting return or enter after a complete expression has been "
"entered will evaluate the entry and show the result of the last expression."
msgstr ""

#: ../../manual/interacting-with-julia.rst:36
msgid ""
"There are a number useful features unique to interactive work. In addition "
"to showing the result, the REPL also binds the result to the variable "
"``ans``.  A trailing semicolon on the line can be used as a flag to suppress"
" showing the result."
msgstr ""

#: ../../manual/interacting-with-julia.rst:46
msgid "Help mode"
msgstr ""

#: ../../manual/interacting-with-julia.rst:48
msgid ""
"When the cursor is at the beginning of the line, the prompt can be changed "
"to a help mode by typing ``?``.  Julia will attempt to print help or "
"documentation for anything entered in help mode::"
msgstr ""

#: ../../manual/interacting-with-julia.rst:57
msgid ""
"In addition to function names, complete function calls may be entered to see"
" which method is called for the given argument(s).  Macros, types and "
"variables can also be queried::"
msgstr ""

#: ../../manual/interacting-with-julia.rst:74
msgid ""
"Help mode can be exited by pressing backspace at the beginning of the line."
msgstr ""

#: ../../manual/interacting-with-julia.rst:77
msgid "Shell mode"
msgstr ""

#: ../../manual/interacting-with-julia.rst:79
msgid ""
"Just as help mode is useful for quick access to documentation, another "
"common task is to use the system shell to execute system commands.  Just as "
"``?`` entered help mode when at the beginning of the line, a semicolon "
"(``;``) will enter the shell mode.  And it can be exited by pressing "
"backspace at the beginning of the line."
msgstr ""

#: ../../manual/interacting-with-julia.rst:89
msgid "Search modes"
msgstr ""

#: ../../manual/interacting-with-julia.rst:91
msgid ""
"In all of the above modes, the executed lines get saved to a history file, "
"which can be searched.  To initiate an incremental search through the "
"previous history, type ``^R`` — the control key together with the ``r`` key."
"  The prompt will change to ``(reverse-i-search)`':``, and as you type the "
"search query will appear in the quotes.  The most recent result that matches"
" the query will dynamically update to the right of the colon as more is "
"typed.  To find an older result using the same query, simply type ``^R`` "
"again."
msgstr ""

#: ../../manual/interacting-with-julia.rst:93
msgid ""
"Just as ``^R`` is a reverse search, ``^S`` is a forward search, with the "
"prompt ``(i-search)`':``.  The two may be used in conjunction with each "
"other to move through the previous or next matching results, respectively."
msgstr ""

#: ../../manual/interacting-with-julia.rst:97
msgid "Key bindings"
msgstr ""

#: ../../manual/interacting-with-julia.rst:99
msgid ""
"The Julia REPL makes great use of key bindings.  Several control-key "
"bindings were already introduced above (``^D`` to exit, ``^R`` and ``^S`` "
"for searching), but there are many more.  In addition to the control-key, "
"there are also meta-key bindings.  These vary more by platform, but most "
"terminals  default to using alt- or option- held down with a key to send the"
" meta-key (or can be configured to do so)."
msgstr ""

#: ../../manual/interacting-with-julia.rst:102
msgid "**Program control**"
msgstr ""

#: ../../manual/interacting-with-julia.rst:104
msgid "``^D``"
msgstr ""

#: ../../manual/interacting-with-julia.rst:104
msgid "Exit (when buffer is empty)"
msgstr ""

#: ../../manual/interacting-with-julia.rst:106
msgid "``^C``"
msgstr ""

#: ../../manual/interacting-with-julia.rst:106
msgid "Interrupt or cancel"
msgstr ""

#: ../../manual/interacting-with-julia.rst:108
msgid "Return/Enter, ``^J``"
msgstr ""

#: ../../manual/interacting-with-julia.rst:108
msgid "New line, executing if it is complete"
msgstr ""

#: ../../manual/interacting-with-julia.rst:110
msgid "meta-Return/Enter"
msgstr ""

#: ../../manual/interacting-with-julia.rst:110
msgid "Insert new line without executing it"
msgstr ""

#: ../../manual/interacting-with-julia.rst:112
msgid "``?`` or ``;``"
msgstr ""

#: ../../manual/interacting-with-julia.rst:112
msgid "Enter help or shell mode (when at start of a line)"
msgstr ""

#: ../../manual/interacting-with-julia.rst:114
msgid "``^R``, ``^S``"
msgstr ""

#: ../../manual/interacting-with-julia.rst:114
msgid "Incremental history search, described above"
msgstr ""

#: ../../manual/interacting-with-julia.rst:116
msgid "**Cursor movement**"
msgstr ""

#: ../../manual/interacting-with-julia.rst:118
msgid "Right arrow, ``^F``"
msgstr ""

#: ../../manual/interacting-with-julia.rst:118
msgid "Move right one character"
msgstr ""

#: ../../manual/interacting-with-julia.rst:120
msgid "Left arrow, ``^B``"
msgstr ""

#: ../../manual/interacting-with-julia.rst:120
msgid "Move left one character"
msgstr ""

#: ../../manual/interacting-with-julia.rst:122
msgid "Home, ``^A``"
msgstr ""

#: ../../manual/interacting-with-julia.rst:122
msgid "Move to beginning of line"
msgstr ""

#: ../../manual/interacting-with-julia.rst:124
msgid "End, ``^E``"
msgstr ""

#: ../../manual/interacting-with-julia.rst:124
msgid "Move to end of line"
msgstr ""

#: ../../manual/interacting-with-julia.rst:126
msgid "``^P``"
msgstr ""

#: ../../manual/interacting-with-julia.rst:126
msgid "Change to the previous or next history entry"
msgstr ""

#: ../../manual/interacting-with-julia.rst:128
msgid "``^N``"
msgstr ""

#: ../../manual/interacting-with-julia.rst:128
msgid "Change to the next history entry"
msgstr ""

#: ../../manual/interacting-with-julia.rst:130
msgid "Up arrow"
msgstr ""

#: ../../manual/interacting-with-julia.rst:130
msgid "Move up one line (or to the previous history entry)"
msgstr ""

#: ../../manual/interacting-with-julia.rst:132
msgid "Down arrow"
msgstr ""

#: ../../manual/interacting-with-julia.rst:132
msgid "Move down one line (or to the next history entry)"
msgstr ""

#: ../../manual/interacting-with-julia.rst:134
msgid "Page-up"
msgstr ""

#: ../../manual/interacting-with-julia.rst:134
msgid ""
"Change to the previous history entry that matches the text before the cursor"
msgstr ""

#: ../../manual/interacting-with-julia.rst:137
msgid "Page-down"
msgstr ""

#: ../../manual/interacting-with-julia.rst:137
msgid ""
"Change to the next history entry that matches the text before the cursor"
msgstr ""

#: ../../manual/interacting-with-julia.rst:140
msgid "``meta-F``"
msgstr ""

#: ../../manual/interacting-with-julia.rst:140
msgid "Move right one word"
msgstr ""

#: ../../manual/interacting-with-julia.rst:142
msgid "``meta-B``"
msgstr ""

#: ../../manual/interacting-with-julia.rst:142
msgid "Move left one word"
msgstr ""

#: ../../manual/interacting-with-julia.rst:144
msgid "**Editing**"
msgstr ""

#: ../../manual/interacting-with-julia.rst:146
msgid "Backspace, ``^H``"
msgstr ""

#: ../../manual/interacting-with-julia.rst:146
msgid "Delete the previous character"
msgstr ""

#: ../../manual/interacting-with-julia.rst:148
#: ../../manual/interacting-with-julia.rst:162
msgid "Delete, ``^D``"
msgstr ""

#: ../../manual/interacting-with-julia.rst:148
#: ../../manual/interacting-with-julia.rst:162
msgid "Forward delete one character (when buffer has text)"
msgstr ""

#: ../../manual/interacting-with-julia.rst:150
msgid "meta-Backspace"
msgstr ""

#: ../../manual/interacting-with-julia.rst:150
msgid "Delete the previous word"
msgstr ""

#: ../../manual/interacting-with-julia.rst:152
msgid "``meta-D``"
msgstr ""

#: ../../manual/interacting-with-julia.rst:152
msgid "Forward delete the next word"
msgstr ""

#: ../../manual/interacting-with-julia.rst:154
msgid "``^W``"
msgstr ""

#: ../../manual/interacting-with-julia.rst:154
msgid "Delete previous text up to the nearest whitespace"
msgstr ""

#: ../../manual/interacting-with-julia.rst:156
msgid "``^K``"
msgstr ""

#: ../../manual/interacting-with-julia.rst:156
msgid "\"Kill\" to end of line, placing the text in a buffer"
msgstr ""

#: ../../manual/interacting-with-julia.rst:158
msgid "``^Y``"
msgstr ""

#: ../../manual/interacting-with-julia.rst:158
msgid "\"Yank\" insert the text from the kill buffer"
msgstr ""

#: ../../manual/interacting-with-julia.rst:160
msgid "``^T``"
msgstr ""

#: ../../manual/interacting-with-julia.rst:160
msgid "Transpose the characters about the cursor"
msgstr ""

#: ../../manual/interacting-with-julia.rst:166
msgid "Customizing keybindings"
msgstr ""

#: ../../manual/interacting-with-julia.rst:168
msgid ""
"Julia's REPL keybindings may be fully customized to a user's preferences by "
"passing a dictionary to ``REPL.setup_interface()``. The keys of this "
"dictionary may be characters or strings. The key ``'*'`` refers to the "
"default action. Control plus character ``x`` bindings are indicated with "
"``\"^x\"``. Meta plus ``x`` can be written ``\"\\\\Mx\"``. The values of the"
" custom keymap must be ``nothing`` (indicating that the input should be "
"ignored) or functions that accept the signature ``(PromptState, "
"AbstractREPL, Char)``. For example, to bind the up and down arrow keys to "
"move through history without prefix search, one could put the following code"
" in ``.juliarc.jl``::"
msgstr ""

#: ../../manual/interacting-with-julia.rst:181
msgid ""
"Users should refer to ``base/LineEdit.jl`` to discover the available actions"
" on key input."
msgstr ""

#: ../../manual/interacting-with-julia.rst:184
msgid "Tab completion"
msgstr ""

#: ../../manual/interacting-with-julia.rst:186
msgid ""
"In both the Julian and help modes of the REPL, one can enter the first few "
"characters of a function or type and then press the tab key to get a list "
"all matches::"
msgstr ""

#: ../../manual/interacting-with-julia.rst:195
msgid ""
"The tab key can also be used to substitute LaTeX math symbols with their "
"Unicode equivalents, and get a list of LaTeX matches as well::"
msgstr ""

#: ../../manual/interacting-with-julia.rst:225
msgid ""
"A full list of tab-completions can be found in the :ref:`man-unicode-input` "
"section of the manual."
msgstr ""

#: ../../manual/introduction.rst:5
msgid "Introduction"
msgstr ""

#: ../../manual/introduction.rst:7
msgid ""
"Scientific computing has traditionally required the highest performance, yet"
" domain experts have largely moved to slower dynamic languages for daily "
"work. We believe there are many good reasons to prefer dynamic languages for"
" these applications, and we do not expect their use to diminish. "
"Fortunately, modern language design and compiler techniques make it possible"
" to mostly eliminate the performance trade-off and provide a single "
"environment productive enough for prototyping and efficient enough for "
"deploying performance-intensive applications. The Julia programming language"
" fills this role: it is a flexible dynamic language, appropriate for "
"scientific and numerical computing, with performance comparable to "
"traditional statically-typed languages."
msgstr ""

#: ../../manual/introduction.rst:19
msgid ""
"Because Julia's compiler is different from the interpreters used for "
"languages like Python or R, you may find that Julia's performance is "
"unintuitive at first. If you find that something is slow, we highly "
"recommend reading through the :ref:`man-performance-tips` section before "
"trying anything else. Once you understand how Julia works, it's easy to "
"write code that's nearly as fast as C."
msgstr ""

#: ../../manual/introduction.rst:26
msgid ""
"Julia features optional typing, multiple dispatch, and good performance, "
"achieved using type inference and `just-in-time (JIT) compilation "
"<http://en.wikipedia.org/wiki/Just-in-time_compilation>`_, implemented using"
" `LLVM <http://en.wikipedia.org/wiki/Low_Level_Virtual_Machine>`_. It is "
"multi-paradigm, combining features of imperative, functional, and object-"
"oriented programming. Julia provides ease and expressiveness for high-level "
"numerical computing, in the same way as languages such as R, MATLAB, and "
"Python, but also supports general programming. To achieve this, Julia builds"
" upon the lineage of mathematical programming languages, but also borrows "
"much from popular dynamic languages, including `Lisp "
"<http://en.wikipedia.org/wiki/Lisp_(programming_language)>`_, `Perl "
"<http://en.wikipedia.org/wiki/Perl_(programming_language)>`_, `Python "
"<http://en.wikipedia.org/wiki/Python_(programming_language)>`_, `Lua "
"<http://en.wikipedia.org/wiki/Lua_(programming_language)>`_, and `Ruby "
"<http://en.wikipedia.org/wiki/Ruby_(programming_language)>`_."
msgstr ""

#: ../../manual/introduction.rst:44
msgid ""
"The most significant departures of Julia from typical dynamic languages are:"
msgstr ""

#: ../../manual/introduction.rst:47
msgid ""
"The core language imposes very little; the standard library is written in "
"Julia itself, including primitive operations like integer arithmetic"
msgstr ""

#: ../../manual/introduction.rst:50
msgid ""
"A rich language of types for constructing and describing objects, that can "
"also optionally be used to make type declarations"
msgstr ""

#: ../../manual/introduction.rst:52
msgid ""
"The ability to define function behavior across many combinations of argument"
" types via `multiple dispatch "
"<http://en.wikipedia.org/wiki/Multiple_dispatch>`_"
msgstr ""

#: ../../manual/introduction.rst:55
msgid ""
"Automatic generation of efficient, specialized code for different argument "
"types"
msgstr ""

#: ../../manual/introduction.rst:57
msgid ""
"Good performance, approaching that of statically-compiled languages like C"
msgstr ""

#: ../../manual/introduction.rst:60
msgid ""
"Although one sometimes speaks of dynamic languages as being \"typeless\", "
"they are definitely not: every object, whether primitive or user-defined, "
"has a type. The lack of type declarations in most dynamic languages, "
"however, means that one cannot instruct the compiler about the types of "
"values, and often cannot explicitly talk about types at all. In static "
"languages, on the other hand, while one can — and usually must — annotate "
"types for the compiler, types exist only at compile time and cannot be "
"manipulated or expressed at run time. In Julia, types are themselves run-"
"time objects, and can also be used to convey information to the compiler."
msgstr ""

#: ../../manual/introduction.rst:71
msgid ""
"While the casual programmer need not explicitly use types or multiple "
"dispatch, they are the core unifying features of Julia: functions are "
"defined on different combinations of argument types, and applied by "
"dispatching to the most specific matching definition. This model is a good "
"fit for mathematical programming, where it is unnatural for the first "
"argument to \"own\" an operation as in traditional object-oriented dispatch."
" Operators are just functions with special notation — to extend addition to "
"new user-defined data types, you define new methods for the ``+`` function. "
"Existing code then seamlessly applies to the new data types."
msgstr ""

#: ../../manual/introduction.rst:82
msgid ""
"Partly because of run-time type inference (augmented by optional type "
"annotations), and partly because of a strong focus on performance from the "
"inception of the project, Julia's computational efficiency exceeds that of "
"other dynamic languages, and even rivals that of statically-compiled "
"languages. For large scale numerical problems, speed always has been, "
"continues to be, and probably always will be crucial: the amount of data "
"being processed has easily kept pace with Moore's Law over the past decades."
msgstr ""

#: ../../manual/introduction.rst:91
msgid ""
"Julia aims to create an unprecedented combination of ease-of-use, power, and"
" efficiency in a single language. In addition to the above, some advantages "
"of Julia over comparable systems include:"
msgstr ""

#: ../../manual/introduction.rst:95
msgid ""
"Free and open source (`MIT licensed "
"<https://github.com/JuliaLang/julia/blob/master/LICENSE.md>`_)"
msgstr ""

#: ../../manual/introduction.rst:97
msgid "User-defined types are as fast and compact as built-ins"
msgstr ""

#: ../../manual/introduction.rst:98
msgid "No need to vectorize code for performance; devectorized code is fast"
msgstr ""

#: ../../manual/introduction.rst:99
msgid "Designed for parallelism and distributed computation"
msgstr ""

#: ../../manual/introduction.rst:100
msgid ""
"Lightweight \"green\" threading (`coroutines "
"<http://en.wikipedia.org/wiki/Coroutine>`_)"
msgstr ""

#: ../../manual/introduction.rst:102
msgid "Unobtrusive yet powerful type system"
msgstr ""

#: ../../manual/introduction.rst:103
msgid ""
"Elegant and extensible conversions and promotions for numeric and other "
"types"
msgstr ""

#: ../../manual/introduction.rst:105
msgid ""
"Efficient support for `Unicode <http://en.wikipedia.org/wiki/Unicode>`_, "
"including but not limited to `UTF-8 <http://en.wikipedia.org/wiki/UTF-8>`_"
msgstr ""

#: ../../manual/introduction.rst:108
msgid "Call C functions directly (no wrappers or special APIs needed)"
msgstr ""

#: ../../manual/introduction.rst:109
msgid "Powerful shell-like capabilities for managing other processes"
msgstr ""

#: ../../manual/introduction.rst:110
msgid "Lisp-like macros and other metaprogramming facilities"
msgstr ""

#: ../../manual/linear-algebra.rst:3
msgid "Linear algebra"
msgstr ""

#: ../../manual/linear-algebra.rst:6 ../../manual/linear-algebra.rst:96
msgid "Matrix factorizations"
msgstr ""

#: ../../manual/linear-algebra.rst:8
msgid ""
"`Matrix factorizations (a.k.a. matrix decompositions) "
"<http://en.wikipedia.org/wiki/Matrix_decomposition>`_ compute the "
"factorization of a matrix into a product of matrices, and are one of the "
"central concepts in linear algebra."
msgstr ""

#: ../../manual/linear-algebra.rst:12
msgid ""
"The following table summarizes the types of matrix factorizations that have "
"been implemented in Julia. Details of their associated methods can be found "
"in the :ref:`stdlib-linalg` section of the standard library documentation."
msgstr ""

#: ../../manual/linear-algebra.rst:17
msgid "``Cholesky``"
msgstr ""

#: ../../manual/linear-algebra.rst:17
msgid ""
"`Cholesky factorization "
"<http://en.wikipedia.org/wiki/Cholesky_decomposition>`_"
msgstr ""

#: ../../manual/linear-algebra.rst:18
msgid "``CholeskyPivoted``"
msgstr ""

#: ../../manual/linear-algebra.rst:18
msgid ""
"`Pivoted <http://en.wikipedia.org/wiki/Pivot_element>`_ Cholesky "
"factorization"
msgstr ""

#: ../../manual/linear-algebra.rst:19
msgid "``LU``"
msgstr ""

#: ../../manual/linear-algebra.rst:19
msgid "`LU factorization <http://en.wikipedia.org/wiki/LU_decomposition>`_"
msgstr ""

#: ../../manual/linear-algebra.rst:20
msgid "``LUTridiagonal``"
msgstr ""

#: ../../manual/linear-algebra.rst:20
msgid "LU factorization for Tridiagonal matrices"
msgstr ""

#: ../../manual/linear-algebra.rst:21
msgid "``UmfpackLU``"
msgstr ""

#: ../../manual/linear-algebra.rst:21
msgid "LU factorization for sparse matrices (computed by UMFPack)"
msgstr ""

#: ../../manual/linear-algebra.rst:22
msgid "``QR``"
msgstr ""

#: ../../manual/linear-algebra.rst:22
msgid "`QR factorization <http://en.wikipedia.org/wiki/QR_decomposition>`_"
msgstr ""

#: ../../manual/linear-algebra.rst:23
msgid "``QRCompactWY``"
msgstr ""

#: ../../manual/linear-algebra.rst:23
msgid "Compact WY form of the QR factorization"
msgstr ""

#: ../../manual/linear-algebra.rst:24
msgid "``QRPivoted``"
msgstr ""

#: ../../manual/linear-algebra.rst:24
msgid ""
"Pivoted `QR factorization <http://en.wikipedia.org/wiki/QR_decomposition>`_"
msgstr ""

#: ../../manual/linear-algebra.rst:25
msgid "``Hessenberg``"
msgstr ""

#: ../../manual/linear-algebra.rst:25
msgid ""
"`Hessenberg decomposition "
"<http://mathworld.wolfram.com/HessenbergDecomposition.html>`_"
msgstr ""

#: ../../manual/linear-algebra.rst:26
msgid "``Eigen``"
msgstr ""

#: ../../manual/linear-algebra.rst:26
msgid ""
"`Spectral decomposition "
"<http://en.wikipedia.org/wiki/Eigendecomposition_(matrix)>`_"
msgstr ""

#: ../../manual/linear-algebra.rst:27
msgid "``SVD``"
msgstr ""

#: ../../manual/linear-algebra.rst:27
msgid ""
"`Singular value decomposition "
"<http://en.wikipedia.org/wiki/Singular_value_decomposition>`_"
msgstr ""

#: ../../manual/linear-algebra.rst:28
msgid "``GeneralizedSVD``"
msgstr ""

#: ../../manual/linear-algebra.rst:28
msgid ""
"`Generalized SVD "
"<http://en.wikipedia.org/wiki/Generalized_singular_value_decomposition#Higher_order_version>`_"
msgstr ""

#: ../../manual/linear-algebra.rst:32
msgid "Special matrices"
msgstr ""

#: ../../manual/linear-algebra.rst:34
msgid ""
"`Matrices with special symmetries and structures "
"<http://www2.imm.dtu.dk/pubdb/views/publication_details.php?id=3274>`_ arise"
" often in linear algebra and are frequently associated with various matrix "
"factorizations. Julia features a rich collection of special matrix types, "
"which allow for fast computation with specialized routines that are "
"specially developed for particular matrix types."
msgstr ""

#: ../../manual/linear-algebra.rst:41
msgid ""
"The following tables summarize the types of special matrices that have been "
"implemented in Julia, as well as whether hooks to various optimized methods "
"for them in LAPACK are available."
msgstr ""

#: ../../manual/linear-algebra.rst:46 ../../manual/linear-algebra.rst:68
#: ../../manual/linear-algebra.rst:101
msgid "``Hermitian``"
msgstr ""

#: ../../manual/linear-algebra.rst:46
msgid "`Hermitian matrix <http://en.wikipedia.org/wiki/Hermitian_matrix>`_"
msgstr ""

#: ../../manual/linear-algebra.rst:48 ../../manual/linear-algebra.rst:71
#: ../../manual/linear-algebra.rst:103
msgid "``Triangular``"
msgstr ""

#: ../../manual/linear-algebra.rst:48
msgid ""
"Upper/lower `triangular matrix "
"<http://en.wikipedia.org/wiki/Triangular_matrix>`_"
msgstr ""

#: ../../manual/linear-algebra.rst:50 ../../manual/linear-algebra.rst:75
#: ../../manual/linear-algebra.rst:107
msgid "``Tridiagonal``"
msgstr ""

#: ../../manual/linear-algebra.rst:50
msgid ""
"`Tridiagonal matrix <http://en.wikipedia.org/wiki/Tridiagonal_matrix>`_"
msgstr ""

#: ../../manual/linear-algebra.rst:52 ../../manual/linear-algebra.rst:73
#: ../../manual/linear-algebra.rst:105
msgid "``SymTridiagonal``"
msgstr ""

#: ../../manual/linear-algebra.rst:52
msgid "Symmetric tridiagonal matrix"
msgstr ""

#: ../../manual/linear-algebra.rst:54 ../../manual/linear-algebra.rst:77
#: ../../manual/linear-algebra.rst:109
msgid "``Bidiagonal``"
msgstr ""

#: ../../manual/linear-algebra.rst:54
msgid ""
"Upper/lower `bidiagonal matrix "
"<http://en.wikipedia.org/wiki/Bidiagonal_matrix>`_"
msgstr ""

#: ../../manual/linear-algebra.rst:56 ../../manual/linear-algebra.rst:79
#: ../../manual/linear-algebra.rst:111
msgid "``Diagonal``"
msgstr ""

#: ../../manual/linear-algebra.rst:56
msgid "`Diagonal matrix <http://en.wikipedia.org/wiki/Diagonal_matrix>`_"
msgstr ""

#: ../../manual/linear-algebra.rst:58 ../../manual/linear-algebra.rst:82
msgid "``UniformScaling``"
msgstr ""

#: ../../manual/linear-algebra.rst:58
msgid ""
"`Uniform scaling operator <http://en.wikipedia.org/wiki/Uniform_scaling>`_"
msgstr ""

#: ../../manual/linear-algebra.rst:62
msgid "Elementary operations"
msgstr ""

#: ../../manual/linear-algebra.rst:65 ../../manual/linear-algebra.rst:99
msgid "Matrix type"
msgstr ""

#: ../../manual/linear-algebra.rst:65
msgid "``+``"
msgstr ""

#: ../../manual/linear-algebra.rst:65
msgid "``-``"
msgstr ""

#: ../../manual/linear-algebra.rst:65
msgid "``*``"
msgstr ""

#: ../../manual/linear-algebra.rst:65
msgid "``\\``"
msgstr ""

#: ../../manual/linear-algebra.rst:65
msgid "Other functions with optimized methods"
msgstr ""

#: ../../manual/linear-algebra.rst:68 ../../manual/linear-algebra.rst:71
#: ../../manual/linear-algebra.rst:71 ../../manual/linear-algebra.rst:73
#: ../../manual/linear-algebra.rst:75 ../../manual/linear-algebra.rst:77
#: ../../manual/linear-algebra.rst:79 ../../manual/linear-algebra.rst:79
msgid "MV"
msgstr ""

#: ../../manual/linear-algebra.rst:68
msgid "``inv``, ``sqrtm``, ``expm``"
msgstr ""

#: ../../manual/linear-algebra.rst:71
msgid "``inv``, ``det``"
msgstr ""

#: ../../manual/linear-algebra.rst:73 ../../manual/linear-algebra.rst:73
#: ../../manual/linear-algebra.rst:75 ../../manual/linear-algebra.rst:75
#: ../../manual/linear-algebra.rst:77 ../../manual/linear-algebra.rst:77
#: ../../manual/linear-algebra.rst:79 ../../manual/linear-algebra.rst:79
#: ../../manual/linear-algebra.rst:82 ../../manual/linear-algebra.rst:82
msgid "M"
msgstr ""

#: ../../manual/linear-algebra.rst:73 ../../manual/linear-algebra.rst:75
#: ../../manual/linear-algebra.rst:77
msgid "MS"
msgstr ""

#: ../../manual/linear-algebra.rst:73
msgid "``eigmax/min``"
msgstr ""

#: ../../manual/linear-algebra.rst:79
msgid "``inv``, ``det``, ``logdet``, ``/``"
msgstr ""

#: ../../manual/linear-algebra.rst:82 ../../manual/linear-algebra.rst:82
msgid "MVS"
msgstr ""

#: ../../manual/linear-algebra.rst:82
msgid "``/``"
msgstr ""

#: ../../manual/linear-algebra.rst:85 ../../manual/linear-algebra.rst:114
msgid "Legend:"
msgstr ""

#: ../../manual/linear-algebra.rst:88
msgid "M (matrix)"
msgstr ""

#: ../../manual/linear-algebra.rst:88
msgid "An optimized method for matrix-matrix operations is available"
msgstr ""

#: ../../manual/linear-algebra.rst:90
msgid "V (vector)"
msgstr ""

#: ../../manual/linear-algebra.rst:90
msgid "An optimized method for matrix-vector operations is available"
msgstr ""

#: ../../manual/linear-algebra.rst:92
msgid "S (scalar)"
msgstr ""

#: ../../manual/linear-algebra.rst:92
msgid "An optimized method for matrix-scalar operations is available"
msgstr ""

#: ../../manual/linear-algebra.rst:99
msgid "LAPACK"
msgstr ""

#: ../../manual/linear-algebra.rst:99
msgid "``eig``"
msgstr ""

#: ../../manual/linear-algebra.rst:99
msgid "``eigvals``"
msgstr ""

#: ../../manual/linear-algebra.rst:99
msgid "``eigvecs``"
msgstr ""

#: ../../manual/linear-algebra.rst:99
msgid "``svd``"
msgstr ""

#: ../../manual/linear-algebra.rst:99
msgid "``svdvals``"
msgstr ""

#: ../../manual/linear-algebra.rst:101
msgid "HE"
msgstr ""

#: ../../manual/linear-algebra.rst:101 ../../manual/linear-algebra.rst:105
msgid "ARI"
msgstr ""

#: ../../manual/linear-algebra.rst:103
msgid "TR"
msgstr ""

#: ../../manual/linear-algebra.rst:105
msgid "ST"
msgstr ""

#: ../../manual/linear-algebra.rst:105 ../../manual/linear-algebra.rst:109
#: ../../manual/linear-algebra.rst:109 ../../manual/linear-algebra.rst:111
msgid "A"
msgstr ""

#: ../../manual/linear-algebra.rst:105
msgid "AV"
msgstr ""

#: ../../manual/linear-algebra.rst:107
msgid "GT"
msgstr ""

#: ../../manual/linear-algebra.rst:109
msgid "BD"
msgstr ""

#: ../../manual/linear-algebra.rst:111
msgid "DI"
msgstr ""

#: ../../manual/linear-algebra.rst:117
msgid "A (all)"
msgstr ""

#: ../../manual/linear-algebra.rst:117
msgid ""
"An optimized method to find all the characteristic values and/or vectors is "
"available"
msgstr ""

#: ../../manual/linear-algebra.rst:117
msgid "e.g. ``eigvals(M)``"
msgstr ""

#: ../../manual/linear-algebra.rst:119
msgid "R (range)"
msgstr ""

#: ../../manual/linear-algebra.rst:119
msgid ""
"An optimized method to find the ``il``:sup:`th` through the ``ih``:sup:`th` "
"characteristic values are available"
msgstr ""

#: ../../manual/linear-algebra.rst:119
msgid "``eigvals(M, il, ih)``"
msgstr ""

#: ../../manual/linear-algebra.rst:121
msgid "I (interval)"
msgstr ""

#: ../../manual/linear-algebra.rst:121
msgid ""
"An optimized method to find the characteristic values in the interval "
"[``vl``, ``vh``] is available"
msgstr ""

#: ../../manual/linear-algebra.rst:121
msgid "``eigvals(M, vl, vh)``"
msgstr ""

#: ../../manual/linear-algebra.rst:123
msgid "V (vectors)"
msgstr ""

#: ../../manual/linear-algebra.rst:123
msgid ""
"An optimized method to find the characteristic vectors corresponding to the "
"characteristic values ``x=[x1, x2,...]`` is available"
msgstr ""

#: ../../manual/linear-algebra.rst:123
msgid "``eigvecs(M, x)``"
msgstr ""

#: ../../manual/linear-algebra.rst:127
msgid "The uniform scaling operator"
msgstr ""

#: ../../manual/linear-algebra.rst:128
msgid ""
"A ``UniformScaling`` operator represents a scalar times the identity "
"operator, ``λ*I``. The identity operator ``I`` is defined as a constant and "
"is an instance of ``UniformScaling``. The size of these operators are "
"generic and match the other matrix in the binary operations ``+``, ``-``, "
"``*`` and ``\\``. For ``A+I`` and ``A-I`` this means that ``A`` must be "
"square. Multiplication with the identity operator ``I`` is a noop (except "
"for checking that the scaling factor is one) and therefore almost without "
"overhead."
msgstr ""

#: ../../manual/mathematical-operations.rst:5
msgid "Mathematical Operations and Elementary Functions"
msgstr ""

#: ../../manual/mathematical-operations.rst:7
msgid ""
"Julia provides a complete collection of basic arithmetic and bitwise "
"operators across all of its numeric primitive types, as well as providing "
"portable, efficient implementations of a comprehensive collection of "
"standard mathematical functions."
msgstr ""

#: ../../manual/mathematical-operations.rst:13
msgid "Arithmetic Operators"
msgstr ""

#: ../../manual/mathematical-operations.rst:15
msgid ""
"The following `arithmetic operators "
"<http://en.wikipedia.org/wiki/Arithmetic#Arithmetic_operations>`_ are "
"supported on all primitive numeric types:"
msgstr ""

#: ../../manual/mathematical-operations.rst:22
msgid "``+x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:22
msgid "unary plus"
msgstr ""

#: ../../manual/mathematical-operations.rst:22
msgid "the identity operation"
msgstr ""

#: ../../manual/mathematical-operations.rst:23
msgid "``-x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:23
msgid "unary minus"
msgstr ""

#: ../../manual/mathematical-operations.rst:23
msgid "maps values to their additive inverses"
msgstr ""

#: ../../manual/mathematical-operations.rst:24
msgid "``x + y``"
msgstr ""

#: ../../manual/mathematical-operations.rst:24
msgid "binary plus"
msgstr ""

#: ../../manual/mathematical-operations.rst:24
msgid "performs addition"
msgstr ""

#: ../../manual/mathematical-operations.rst:25
msgid "``x - y``"
msgstr ""

#: ../../manual/mathematical-operations.rst:25
msgid "binary minus"
msgstr ""

#: ../../manual/mathematical-operations.rst:25
msgid "performs subtraction"
msgstr ""

#: ../../manual/mathematical-operations.rst:26
msgid "``x * y``"
msgstr ""

#: ../../manual/mathematical-operations.rst:26
msgid "times"
msgstr ""

#: ../../manual/mathematical-operations.rst:26
msgid "performs multiplication"
msgstr ""

#: ../../manual/mathematical-operations.rst:27
msgid "``x / y``"
msgstr ""

#: ../../manual/mathematical-operations.rst:27
msgid "divide"
msgstr ""

#: ../../manual/mathematical-operations.rst:27
msgid "performs division"
msgstr ""

#: ../../manual/mathematical-operations.rst:28
msgid "``x \\ y``"
msgstr ""

#: ../../manual/mathematical-operations.rst:28
msgid "inverse divide"
msgstr ""

#: ../../manual/mathematical-operations.rst:28
msgid "equivalent to ``y / x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:29
msgid "``x ^ y``"
msgstr ""

#: ../../manual/mathematical-operations.rst:29
msgid "power"
msgstr ""

#: ../../manual/mathematical-operations.rst:29
msgid "raises ``x`` to the ``y``\\ th power"
msgstr ""

#: ../../manual/mathematical-operations.rst:30
msgid "``x % y``"
msgstr ""

#: ../../manual/mathematical-operations.rst:30
msgid "remainder"
msgstr ""

#: ../../manual/mathematical-operations.rst:30
msgid "equivalent to ``rem(x,y)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:33
msgid "as well as the negation on ``Bool`` types:"
msgstr ""

#: ../../manual/mathematical-operations.rst:38
msgid "``!x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:38
msgid "negation"
msgstr ""

#: ../../manual/mathematical-operations.rst:38
msgid "changes ``true`` to ``false`` and vice versa"
msgstr ""

#: ../../manual/mathematical-operations.rst:41
msgid ""
"Julia's promotion system makes arithmetic operations on mixtures of argument"
" types \"just work\" naturally and automatically. See :ref:`man-conversion-"
"and-promotion` for details of the promotion system."
msgstr ""

#: ../../manual/mathematical-operations.rst:45
msgid "Here are some simple examples using arithmetic operators:"
msgstr ""

#: ../../manual/mathematical-operations.rst:58
msgid ""
"(By convention, we tend to space less tightly binding operators less "
"tightly, but there are no syntactic constraints.)"
msgstr ""

#: ../../manual/mathematical-operations.rst:62
msgid "Bitwise Operators"
msgstr ""

#: ../../manual/mathematical-operations.rst:64
msgid ""
"The following `bitwise operators "
"<http://en.wikipedia.org/wiki/Bitwise_operation#Bitwise_operators>`_ are "
"supported on all primitive integer types:"
msgstr ""

#: ../../manual/mathematical-operations.rst:71
msgid "``~x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:71
msgid "bitwise not"
msgstr ""

#: ../../manual/mathematical-operations.rst:72
msgid "``x & y``"
msgstr ""

#: ../../manual/mathematical-operations.rst:72
msgid "bitwise and"
msgstr ""

#: ../../manual/mathematical-operations.rst:73
msgid "``x | y``"
msgstr ""

#: ../../manual/mathematical-operations.rst:73
msgid "bitwise or"
msgstr ""

#: ../../manual/mathematical-operations.rst:74
msgid "``x $ y``"
msgstr ""

#: ../../manual/mathematical-operations.rst:74
msgid "bitwise xor (exclusive or)"
msgstr ""

#: ../../manual/mathematical-operations.rst:75
msgid "``x >>> y``"
msgstr ""

#: ../../manual/mathematical-operations.rst:75
msgid "`logical shift <http://en.wikipedia.org/wiki/Logical_shift>`_ right"
msgstr ""

#: ../../manual/mathematical-operations.rst:76
msgid "``x >> y``"
msgstr ""

#: ../../manual/mathematical-operations.rst:76
msgid ""
"`arithmetic shift <http://en.wikipedia.org/wiki/Arithmetic_shift>`_ right"
msgstr ""

#: ../../manual/mathematical-operations.rst:77
msgid "``x << y``"
msgstr ""

#: ../../manual/mathematical-operations.rst:77
msgid "logical/arithmetic shift left"
msgstr ""

#: ../../manual/mathematical-operations.rst:80
msgid "Here are some examples with bitwise operators:"
msgstr ""

#: ../../manual/mathematical-operations.rst:103
msgid "Updating operators"
msgstr ""

#: ../../manual/mathematical-operations.rst:104
msgid ""
"Every binary arithmetic and bitwise operator also has an updating version "
"that assigns the result of the operation back into its left operand. The "
"updating version of the binary operator is formed by placing a ``=`` "
"immediately after the operator. For example, writing ``x += 3`` is "
"equivalent to writing ``x = x + 3``::"
msgstr ""

#: ../../manual/mathematical-operations.rst:119
msgid ""
"The updating versions of all the binary arithmetic and bitwise operators "
"are::"
msgstr ""

#: ../../manual/mathematical-operations.rst:126
msgid ""
"An updating operator rebinds the variable on the left-hand side. As a "
"result, the type of the variable may change."
msgstr ""

#: ../../manual/mathematical-operations.rst:143
msgid "Numeric Comparisons"
msgstr ""

#: ../../manual/mathematical-operations.rst:145
msgid ""
"Standard comparison operations are defined for all the primitive numeric "
"types:"
msgstr ""

#: ../../manual/mathematical-operations.rst:149
msgid "Operator"
msgstr ""

#: ../../manual/mathematical-operations.rst:151
msgid "``==``"
msgstr ""

#: ../../manual/mathematical-operations.rst:151
msgid "equality"
msgstr ""

#: ../../manual/mathematical-operations.rst:152
msgid "``!=`` ``≠``"
msgstr ""

#: ../../manual/mathematical-operations.rst:152
msgid "inequality"
msgstr ""

#: ../../manual/mathematical-operations.rst:153
msgid "``<``"
msgstr ""

#: ../../manual/mathematical-operations.rst:153
msgid "less than"
msgstr ""

#: ../../manual/mathematical-operations.rst:154
msgid "``<=`` ``≤``"
msgstr ""

#: ../../manual/mathematical-operations.rst:154
msgid "less than or equal to"
msgstr ""

#: ../../manual/mathematical-operations.rst:155
msgid "``>``"
msgstr ""

#: ../../manual/mathematical-operations.rst:155
msgid "greater than"
msgstr ""

#: ../../manual/mathematical-operations.rst:156
msgid "``>=`` ``≥``"
msgstr ""

#: ../../manual/mathematical-operations.rst:156
msgid "greater than or equal to"
msgstr ""

#: ../../manual/mathematical-operations.rst:159
msgid "Here are some simple examples:"
msgstr ""

#: ../../manual/mathematical-operations.rst:196
msgid ""
"Integers are compared in the standard manner — by comparison of bits. "
"Floating-point numbers are compared according to the `IEEE 754 standard "
"<http://en.wikipedia.org/wiki/IEEE_754-2008>`_:"
msgstr ""

#: ../../manual/mathematical-operations.rst:200
msgid "Finite numbers are ordered in the usual manner."
msgstr ""

#: ../../manual/mathematical-operations.rst:201
msgid "Positive zero is equal but not greater than negative zero."
msgstr ""

#: ../../manual/mathematical-operations.rst:202
msgid ""
"``Inf`` is equal to itself and greater than everything else except ``NaN``."
msgstr ""

#: ../../manual/mathematical-operations.rst:203
msgid ""
"``-Inf`` is equal to itself and less then everything else except ``NaN``."
msgstr ""

#: ../../manual/mathematical-operations.rst:204
msgid ""
"``NaN`` is not equal to, not less than, and not greater than anything, "
"including itself."
msgstr ""

#: ../../manual/mathematical-operations.rst:207
msgid "The last point is potentially surprising and thus worth noting:"
msgstr ""

#: ../../manual/mathematical-operations.rst:223
msgid "and can cause especial headaches with :ref:`Arrays <man-arrays>`:"
msgstr ""

#: ../../manual/mathematical-operations.rst:230
msgid ""
"Julia provides additional functions to test numbers for special values, "
"which can be useful in situations like hash key comparisons:"
msgstr ""

#: ../../manual/mathematical-operations.rst:234
msgid "Tests if"
msgstr ""

#: ../../manual/mathematical-operations.rst:236
msgid "``isequal(x, y)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:236
msgid "``x`` and ``y`` are identical"
msgstr ""

#: ../../manual/mathematical-operations.rst:237
msgid "``isfinite(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:237
msgid "``x`` is a finite number"
msgstr ""

#: ../../manual/mathematical-operations.rst:238
msgid "``isinf(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:238
msgid "``x`` is infinite"
msgstr ""

#: ../../manual/mathematical-operations.rst:239
msgid "``isnan(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:239
msgid "``x`` is not a number"
msgstr ""

#: ../../manual/mathematical-operations.rst:242
msgid "``isequal`` considers ``NaN``\\ s equal to each other:"
msgstr ""

#: ../../manual/mathematical-operations.rst:255
msgid "``isequal`` can also be used to distinguish signed zeros:"
msgstr ""

#: ../../manual/mathematical-operations.rst:265
msgid ""
"Mixed-type comparisons between signed integers, unsigned integers, and "
"floats can be tricky. A great deal of care has been taken to ensure that "
"Julia does them correctly."
msgstr ""

#: ../../manual/mathematical-operations.rst:269
msgid ""
"For other types, `isequal` defaults to calling `==`, so if you want to "
"define equality for your own types then you only need to add a `==` method."
"  If you define your own equality function, you should probably define a "
"corresponding `hash` function to ensure that `isequal(x,y)` implies `hash(x)"
" == hash(y)`."
msgstr ""

#: ../../manual/mathematical-operations.rst:276
msgid "Chaining comparisons"
msgstr ""

#: ../../manual/mathematical-operations.rst:278
msgid ""
"Unlike most languages, with the `notable exception of Python "
"<http://en.wikipedia.org/wiki/Python_syntax_and_semantics#Comparison_operators>`_,"
" comparisons can be arbitrarily chained:"
msgstr ""

#: ../../manual/mathematical-operations.rst:287
msgid ""
"Chaining comparisons is often quite convenient in numerical code. Chained "
"comparisons use the ``&&`` operator for scalar comparisons, and the ``&`` "
"operator for elementwise comparisons, which allows them to work on arrays. "
"For example, ``0 .< A .< 1`` gives a boolean array whose entries are true "
"where the corresponding elements of ``A`` are between 0 and 1."
msgstr ""

#: ../../manual/mathematical-operations.rst:294
msgid ""
"The operator ``.<`` is intended for array objects; the operation ``A .< B`` "
"is valid only if ``A`` and ``B`` have the same dimensions.  The operator "
"returns an array with boolean entries and with the same dimensions as ``A`` "
"and ``B``.  Such operators are called *elementwise*; Julia offers a suite of"
" elementwise operators: ``.*``, ``.+``, etc.  Some of the elementwise "
"operators can take a scalar operand such as the example ``0 .< A .< 1`` in "
"the preceding paragraph. This notation means that the scalar operand should "
"be replicated for each entry of the array."
msgstr ""

#: ../../manual/mathematical-operations.rst:304
msgid "Note the evaluation behavior of chained comparisons::"
msgstr ""

#: ../../manual/mathematical-operations.rst:319
msgid ""
"The middle expression is only evaluated once, rather than twice as it would "
"be if the expression were written as ``v(1) < v(2) && v(2) <= v(3)``. "
"However, the order of evaluations in a chained comparison is undefined. It "
"is strongly recommended not to use expressions with side effects (such as "
"printing) in chained comparisons. If side effects are required, the short-"
"circuit ``&&`` operator should be used explicitly (see :ref:`man-short-"
"circuit-evaluation`)."
msgstr ""

#: ../../manual/mathematical-operations.rst:328
msgid "Operator Precedence"
msgstr ""

#: ../../manual/mathematical-operations.rst:330
msgid ""
"Julia applies the following order of operations, from highest precedence to "
"lowest:"
msgstr ""

#: ../../manual/mathematical-operations.rst:334
msgid "Category"
msgstr ""

#: ../../manual/mathematical-operations.rst:334
msgid "Operators"
msgstr ""

#: ../../manual/mathematical-operations.rst:336
#: ../../manual/mathematical-operations.rst:342
msgid "Syntax"
msgstr ""

#: ../../manual/mathematical-operations.rst:336
msgid "``.`` followed by ``::``"
msgstr ""

#: ../../manual/mathematical-operations.rst:337
msgid "Exponentiation"
msgstr ""

#: ../../manual/mathematical-operations.rst:337
msgid "``^`` and its elementwise equivalent ``.^``"
msgstr ""

#: ../../manual/mathematical-operations.rst:338
msgid "Fractions"
msgstr ""

#: ../../manual/mathematical-operations.rst:338
msgid "``//`` and ``.//``"
msgstr ""

#: ../../manual/mathematical-operations.rst:339
msgid "Multiplication"
msgstr ""

#: ../../manual/mathematical-operations.rst:339
msgid "``* / % & \\`` and  ``.* ./ .% .\\``"
msgstr ""

#: ../../manual/mathematical-operations.rst:340
msgid "Bitshifts"
msgstr ""

#: ../../manual/mathematical-operations.rst:340
msgid "``<< >> >>>`` and ``.<< .>> .>>>``"
msgstr ""

#: ../../manual/mathematical-operations.rst:341
msgid "Addition"
msgstr ""

#: ../../manual/mathematical-operations.rst:341
msgid "``+ - | $`` and ``.+ .-``"
msgstr ""

#: ../../manual/mathematical-operations.rst:342
msgid "``: ..`` followed by ``|>``"
msgstr ""

#: ../../manual/mathematical-operations.rst:343
msgid "Comparisons"
msgstr ""

#: ../../manual/mathematical-operations.rst:343
msgid "``> < >= <= == === != !== <:`` and ``.> .< .>= .<= .== .!=``"
msgstr ""

#: ../../manual/mathematical-operations.rst:344
msgid "Control flow"
msgstr ""

#: ../../manual/mathematical-operations.rst:344
msgid "``&&`` followed by ``||`` followed by ``?``"
msgstr ""

#: ../../manual/mathematical-operations.rst:345
msgid "Assignments"
msgstr ""

#: ../../manual/mathematical-operations.rst:345
msgid ""
"``= += -= *= /= //= \\= ^= ÷= %= |= &= $= <<= >>= >>>=`` and ``.+= .-= .*= "
"./= .//= .\\= .^= .÷= .%=``"
msgstr ""

#: ../../manual/mathematical-operations.rst:351
msgid "Elementary Functions"
msgstr ""

#: ../../manual/mathematical-operations.rst:353
msgid ""
"Julia provides a comprehensive collection of mathematical functions and "
"operators. These mathematical operations are defined over as broad a class "
"of numerical values as permit sensible definitions, including integers, "
"floating-point numbers, rationals, and complexes, wherever such definitions "
"make sense."
msgstr ""

#: ../../manual/mathematical-operations.rst:360
msgid "Rounding functions"
msgstr ""

#: ../../manual/mathematical-operations.rst:363
msgid "Return type"
msgstr ""

#: ../../manual/mathematical-operations.rst:365
msgid "``round(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:365
#: ../../manual/mathematical-operations.rst:366
msgid "round ``x`` to the nearest integer"
msgstr ""

#: ../../manual/mathematical-operations.rst:365
#: ../../manual/mathematical-operations.rst:367
#: ../../manual/mathematical-operations.rst:369
#: ../../manual/mathematical-operations.rst:371
msgid "``typeof(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:366
msgid "``round(T, x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:366
#: ../../manual/mathematical-operations.rst:368
#: ../../manual/mathematical-operations.rst:370
#: ../../manual/mathematical-operations.rst:372
msgid "``T``"
msgstr ""

#: ../../manual/mathematical-operations.rst:367
msgid "``floor(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:367
#: ../../manual/mathematical-operations.rst:368
msgid "round ``x`` towards ``-Inf``"
msgstr ""

#: ../../manual/mathematical-operations.rst:368
msgid "``floor(T, x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:369
msgid "``ceil(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:369
#: ../../manual/mathematical-operations.rst:370
msgid "round ``x`` towards ``+Inf``"
msgstr ""

#: ../../manual/mathematical-operations.rst:370
msgid "``ceil(T, x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:371
msgid "``trunc(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:371
#: ../../manual/mathematical-operations.rst:372
msgid "round ``x`` towards zero"
msgstr ""

#: ../../manual/mathematical-operations.rst:372
msgid "``trunc(T, x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:376
msgid "Division functions"
msgstr ""

#: ../../manual/mathematical-operations.rst:381
msgid "``div(x,y)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:381
msgid "truncated division; quotient rounded towards zero"
msgstr ""

#: ../../manual/mathematical-operations.rst:382
msgid "``fld(x,y)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:382
msgid "floored division; quotient rounded towards ``-Inf``"
msgstr ""

#: ../../manual/mathematical-operations.rst:383
msgid "``cld(x,y)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:383
msgid "ceiling division; quotient rounded towards ``+Inf``"
msgstr ""

#: ../../manual/mathematical-operations.rst:384
msgid "``rem(x,y)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:384
msgid ""
"remainder; satisfies ``x == div(x,y)*y + rem(x,y)``; sign matches ``x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:385
msgid "``divrem(x,y)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:385
msgid "returns ``(div(x,y),rem(x,y))``"
msgstr ""

#: ../../manual/mathematical-operations.rst:386
msgid "``mod(x,y)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:386
msgid "modulus; satisfies ``x == fld(x,y)*y + mod(x,y)``; sign matches ``y``"
msgstr ""

#: ../../manual/mathematical-operations.rst:387
msgid "``mod2pi(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:387
msgid "modulus with respect to 2pi;  ``0 <= mod2pi(x)  < 2pi``"
msgstr ""

#: ../../manual/mathematical-operations.rst:388
msgid "``gcd(x,y...)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:388
msgid "greatest common divisor of ``x``, ``y``,...; sign matches ``x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:389
msgid "``lcm(x,y...)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:389
msgid "least common multiple of ``x``, ``y``,...; sign matches ``x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:393
msgid "Sign and absolute value functions"
msgstr ""

#: ../../manual/mathematical-operations.rst:398
msgid "``abs(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:398
msgid "a positive value with the magnitude of ``x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:399
msgid "``abs2(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:399
msgid "the squared magnitude of ``x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:400
msgid "``sign(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:400
msgid "indicates the sign of ``x``, returning -1, 0, or +1"
msgstr ""

#: ../../manual/mathematical-operations.rst:401
msgid "``signbit(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:401
msgid "indicates whether the sign bit is on (true) or off (false)"
msgstr ""

#: ../../manual/mathematical-operations.rst:402
msgid "``copysign(x,y)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:402
msgid "a value with the magnitude of ``x`` and the sign of ``y``"
msgstr ""

#: ../../manual/mathematical-operations.rst:403
msgid "``flipsign(x,y)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:403
msgid "a value with the magnitude of ``x`` and the sign of ``x*y``"
msgstr ""

#: ../../manual/mathematical-operations.rst:407
msgid "Powers, logs and roots"
msgstr ""

#: ../../manual/mathematical-operations.rst:412
msgid "``sqrt(x)`` ``√x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:412
msgid "the square root of ``x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:413
msgid "``cbrt(x)`` ``∛x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:413
msgid "the cube root of ``x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:414
msgid "``hypot(x,y)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:414
msgid ""
"hypotenuse of right-angled triangle with other sides of length ``x`` and "
"``y``"
msgstr ""

#: ../../manual/mathematical-operations.rst:415
msgid "``exp(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:415
msgid "the natural exponential function at ``x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:416
msgid "``expm1(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:416
msgid "accurate ``exp(x)-1`` for ``x`` near zero"
msgstr ""

#: ../../manual/mathematical-operations.rst:417
msgid "``ldexp(x,n)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:417
msgid "``x*2^n`` computed efficiently for integer values of ``n``"
msgstr ""

#: ../../manual/mathematical-operations.rst:418
msgid "``log(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:418
msgid "the natural logarithm of ``x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:419
msgid "``log(b,x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:419
msgid "the base ``b`` logarithm of ``x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:420
msgid "``log2(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:420
msgid "the base 2 logarithm of ``x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:421
msgid "``log10(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:421
msgid "the base 10 logarithm of ``x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:422
msgid "``log1p(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:422
msgid "accurate ``log(1+x)`` for ``x`` near zero"
msgstr ""

#: ../../manual/mathematical-operations.rst:423
msgid "``exponent(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:423
msgid "returns the binary exponent of ``x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:424
msgid "``significand(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:424
msgid ""
"returns the binary significand (a.k.a. mantissa) of a floating-point number "
"``x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:427
msgid ""
"For an overview of why functions like ``hypot``, ``expm1``, and ``log1p`` "
"are necessary and useful, see John D. Cook's excellent pair of blog posts on"
" the subject: `expm1, log1p, erfc <http://www.johndcook.com/blog/2010/06/07"
"/math-library-functions-that-seem-unnecessary/>`_, and `hypot "
"<http://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-"
"finding-a-hypotenuse/>`_."
msgstr ""

#: ../../manual/mathematical-operations.rst:435
msgid "Trigonometric and hyperbolic functions"
msgstr ""

#: ../../manual/mathematical-operations.rst:437
msgid ""
"All the standard trigonometric and hyperbolic functions are also defined::"
msgstr ""

#: ../../manual/mathematical-operations.rst:445
msgid ""
"These are all single-argument functions, with the exception of `atan2 "
"<http://en.wikipedia.org/wiki/Atan2>`_, which gives the angle in `radians "
"<http://en.wikipedia.org/wiki/Radian>`_ between the *x*-axis and the point "
"specified by its arguments, interpreted as *x* and *y* coordinates."
msgstr ""

#: ../../manual/mathematical-operations.rst:451
msgid ""
"Additionally, ``sinpi(x)`` and ``cospi(x)`` are provided for more accurate "
"computations of ``sin(pi*x)`` and ``cos(pi*x)`` respectively."
msgstr ""

#: ../../manual/mathematical-operations.rst:454
msgid ""
"In order to compute trigonometric functions with degrees instead of radians,"
" suffix the function with ``d``. For example, ``sind(x)`` computes the sine "
"of ``x`` where ``x`` is specified in degrees. The complete list of "
"trigonometric functions with degree variants is::"
msgstr ""

#: ../../manual/mathematical-operations.rst:463
msgid "Special functions"
msgstr ""

#: ../../manual/mathematical-operations.rst:468
msgid "``erf(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:468
msgid ""
"the `error function <http://en.wikipedia.org/wiki/Error_function>`_ at ``x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:469
msgid "``erfc(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:469
msgid ""
"the complementary error function, i.e. the accurate version of ``1-erf(x)`` "
"for large ``x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:470
msgid "``erfinv(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:470
msgid "the inverse function to ``erf``"
msgstr ""

#: ../../manual/mathematical-operations.rst:471
msgid "``erfcinv(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:471
msgid "the inverse function to ``erfc``"
msgstr ""

#: ../../manual/mathematical-operations.rst:472
msgid "``erfi(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:472
msgid ""
"the imaginary error function defined as ``-im * erf(x * im)``, where ``im`` "
"is the imaginary unit"
msgstr ""

#: ../../manual/mathematical-operations.rst:473
msgid "``erfcx(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:473
msgid ""
"the scaled complementary error function, i.e. accurate ``exp(x^2) * "
"erfc(x)`` for large ``x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:474
msgid "``dawson(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:474
msgid ""
"the scaled imaginary error function, a.k.a. Dawson function, i.e. accurate "
"``exp(-x^2) * erfi(x) * sqrt(pi) / 2`` for large ``x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:475
msgid "``gamma(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:475
msgid ""
"the `gamma function <http://en.wikipedia.org/wiki/Gamma_function>`_ at ``x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:476
msgid "``lgamma(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:476
msgid "accurate ``log(gamma(x))`` for large ``x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:477
msgid "``lfact(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:477
msgid ""
"accurate ``log(factorial(x))`` for large ``x``; same as ``lgamma(x+1)`` for "
"``x > 1``, zero otherwise"
msgstr ""

#: ../../manual/mathematical-operations.rst:478
msgid "``digamma(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:478
msgid ""
"the `digamma function <http://en.wikipedia.org/wiki/Digamma_function>`_ "
"(i.e. the derivative of ``lgamma``) at ``x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:479
msgid "``beta(x,y)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:479
msgid ""
"the `beta function <http://en.wikipedia.org/wiki/Beta_function>`_ at ``x,y``"
msgstr ""

#: ../../manual/mathematical-operations.rst:480
msgid "``lbeta(x,y)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:480
msgid "accurate ``log(beta(x,y))`` for large ``x`` or ``y``"
msgstr ""

#: ../../manual/mathematical-operations.rst:481
msgid "``eta(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:481
msgid ""
"the `Dirichlet eta function "
"<http://en.wikipedia.org/wiki/Dirichlet_eta_function>`_ at ``x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:482
msgid "``zeta(x)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:482
msgid ""
"the `Riemann zeta function "
"<http://en.wikipedia.org/wiki/Riemann_zeta_function>`_ at ``x``"
msgstr ""

#: ../../manual/mathematical-operations.rst:483
msgid "|airylist|"
msgstr ""

#: ../../manual/mathematical-operations.rst:483
msgid ""
"the `Airy Ai function <http://en.wikipedia.org/wiki/Airy_function>`_ at "
"``z``"
msgstr ""

#: ../../manual/mathematical-operations.rst:484
msgid "|airyprimelist|"
msgstr ""

#: ../../manual/mathematical-operations.rst:484
msgid "the derivative of the Airy Ai function at ``z``"
msgstr ""

#: ../../manual/mathematical-operations.rst:485
msgid "``airybi(z)``, ``airy(2,z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:485
msgid ""
"the `Airy Bi function <http://en.wikipedia.org/wiki/Airy_function>`_ at "
"``z``"
msgstr ""

#: ../../manual/mathematical-operations.rst:486
msgid "``airybiprime(z)``, ``airy(3,z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:486
msgid "the derivative of the Airy Bi function at ``z``"
msgstr ""

#: ../../manual/mathematical-operations.rst:487
msgid "``airyx(z)``, ``airyx(k,z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:487
msgid "the scaled Airy AI function and ``k`` th derivatives at ``z``"
msgstr ""

#: ../../manual/mathematical-operations.rst:488
msgid "``besselj(nu,z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:488
msgid ""
"the `Bessel function <http://en.wikipedia.org/wiki/Bessel_function>`_ of the"
" first kind of order ``nu`` at ``z``"
msgstr ""

#: ../../manual/mathematical-operations.rst:489
msgid "``besselj0(z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:489
msgid "``besselj(0,z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:490
msgid "``besselj1(z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:490
msgid "``besselj(1,z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:491
msgid "``besseljx(nu,z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:491
msgid "the scaled Bessel function of the first kind of order ``nu`` at ``z``"
msgstr ""

#: ../../manual/mathematical-operations.rst:492
msgid "``bessely(nu,z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:492
msgid ""
"the `Bessel function <http://en.wikipedia.org/wiki/Bessel_function>`_ of the"
" second kind of order ``nu`` at ``z``"
msgstr ""

#: ../../manual/mathematical-operations.rst:493
msgid "``bessely0(z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:493
msgid "``bessely(0,z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:494
msgid "``bessely1(z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:494
msgid "``bessely(1,z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:495
msgid "``besselyx(nu,z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:495
msgid "the scaled Bessel function of the second kind of order ``nu`` at ``z``"
msgstr ""

#: ../../manual/mathematical-operations.rst:496
msgid "``besselh(nu,k,z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:496
msgid ""
"the `Bessel function <http://en.wikipedia.org/wiki/Bessel_function>`_ of the"
" third kind (a.k.a. Hankel function) of order ``nu`` at ``z``; ``k`` must be"
" either ``1`` or ``2``"
msgstr ""

#: ../../manual/mathematical-operations.rst:497
msgid "``hankelh1(nu,z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:497
msgid "``besselh(nu, 1, z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:498
msgid "``hankelh1x(nu,z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:498
msgid "scaled ``besselh(nu, 1, z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:499
msgid "``hankelh2(nu,z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:499
msgid "``besselh(nu, 2, z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:500
msgid "``hankelh2x(nu,z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:500
msgid "scaled ``besselh(nu, 2, z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:501
msgid "``besseli(nu,z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:501
msgid ""
"the modified `Bessel function "
"<http://en.wikipedia.org/wiki/Bessel_function>`_ of the first kind of order "
"``nu`` at ``z``"
msgstr ""

#: ../../manual/mathematical-operations.rst:502
msgid "``besselix(nu,z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:502
msgid ""
"the scaled modified Bessel function of the first kind of order ``nu`` at "
"``z``"
msgstr ""

#: ../../manual/mathematical-operations.rst:503
msgid "``besselk(nu,z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:503
msgid ""
"the modified `Bessel function "
"<http://en.wikipedia.org/wiki/Bessel_function>`_ of the second kind of order"
" ``nu`` at ``z``"
msgstr ""

#: ../../manual/mathematical-operations.rst:504
msgid "``besselkx(nu,z)``"
msgstr ""

#: ../../manual/mathematical-operations.rst:504
msgid ""
"the scaled modified Bessel function of the second kind of order ``nu`` at "
"``z``"
msgstr ""

#: ../../manual/metaprogramming.rst:7
msgid "Metaprogramming"
msgstr ""

#: ../../manual/metaprogramming.rst:9
msgid ""
"The strongest legacy of Lisp in the Julia language is its metaprogramming "
"support. Like Lisp, Julia represents its own code as a data structure of the"
" language itself. Since code is represented by objects that can be created "
"and manipulated from within the language, it is possible for a program to "
"transform and generate its own code. This allows sophisticated code "
"generation without extra build steps, and also allows true Lisp-style "
"macros, as compared to preprocessor \"macro\" systems, like that of C and "
"C++, that perform superficial textual manipulation as a separate pass before"
" any real parsing or interpretation occurs. Another aspect of "
"metaprogramming is reflection: the ability of a running program to "
"dynamically discover properties of itself. Reflection emerges naturally from"
" the fact that all data types and code are represented by normal Julia data "
"structures, so the structure of the program and its types can be explored "
"programmatically just like any other data."
msgstr ""

#: ../../manual/metaprogramming.rst:26
msgid "Expressions and Eval"
msgstr ""

#: ../../manual/metaprogramming.rst:28
msgid ""
"Julia code is represented as a syntax tree built out of Julia data "
"structures of type ``Expr``. This makes it easy to construct and manipulate "
"Julia code from within Julia, without generating or parsing source text. "
"Here is the definition of the ``Expr`` type::"
msgstr ""

#: ../../manual/metaprogramming.rst:39
msgid ""
"The ``head`` is a symbol identifying the kind of expression, and ``args`` is"
" an array of subexpressions, which may be symbols referencing the values of "
"variables at evaluation time, may be nested ``Expr`` objects, or may be "
"actual values of objects. The ``typ`` field is used by type inference to "
"store type annotations, and can generally be ignored."
msgstr ""

#: ../../manual/metaprogramming.rst:46
msgid ""
"There is special syntax for \"quoting\" code (analogous to quoting strings) "
"that makes it easy to create expression objects without explicitly "
"constructing ``Expr`` objects. There are two forms: a short form for inline "
"expressions using ``:`` followed by a single expression, and a long form for"
" blocks of code, enclosed in ``quote ... end``. Here is an example of the "
"short form used to quote an arithmetic expression:"
msgstr ""

#: ../../manual/metaprogramming.rst:86
msgid ""
"Expressions provided by the parser generally only have symbols, other "
"expressions, and literal values as their args, whereas expressions "
"constructed by Julia code can easily have arbitrary run-time values without "
"literal forms as args. In this specific example, ``+`` and ``a`` are "
"symbols, ``*(b,c)`` is a subexpression, and ``1`` is a literal 64-bit signed"
" integer. Here's an example of the longer expression quoting form:"
msgstr ""

#: ../../manual/metaprogramming.rst:108
msgid "Symbols"
msgstr ""

#: ../../manual/metaprogramming.rst:110
msgid ""
"When the argument to ``:`` is just a symbol, a ``Symbol`` object results "
"instead of an ``Expr``:"
msgstr ""

#: ../../manual/metaprogramming.rst:121
msgid ""
"In the context of an expression, symbols are used to indicate access to "
"variables, and when an expression is evaluated, a symbol evaluates to the "
"value bound to that symbol in the appropriate :ref:`scope <man-variables-"
"and-scoping>`."
msgstr ""

#: ../../manual/metaprogramming.rst:126
msgid ""
"Sometimes extra parentheses around the argument to ``:`` are needed to avoid"
" ambiguity in parsing.:"
msgstr ""

#: ../../manual/metaprogramming.rst:137
msgid ""
"``Symbol``\\ s can also be created using the ``symbol`` function, which "
"takes a character or string as its argument:"
msgstr ""

#: ../../manual/metaprogramming.rst:149
msgid "``eval`` and Interpolation"
msgstr ""

#: ../../manual/metaprogramming.rst:151
msgid ""
"Given an expression object, one can cause Julia to evaluate (execute) it at "
"global scope using the ``eval`` function:"
msgstr ""

#: ../../manual/metaprogramming.rst:173
msgid ""
"Every :ref:`module <man-modules>` has its own ``eval`` function that "
"evaluates expressions in its global scope. Expressions passed to ``eval`` "
"are not limited to returning values — they can also have side-effects that "
"alter the state of the enclosing module's environment:"
msgstr ""

#: ../../manual/metaprogramming.rst:193
msgid ""
"Here, the evaluation of an expression object causes a value to be assigned "
"to the global variable ``x``."
msgstr ""

#: ../../manual/metaprogramming.rst:196
msgid ""
"Since expressions are just ``Expr`` objects which can be constructed "
"programmatically and then evaluated, one can, from within Julia code, "
"dynamically generate arbitrary code which can then be run using ``eval``. "
"Here is a simple example:"
msgstr ""

#: ../../manual/metaprogramming.rst:213
msgid ""
"The value of ``a`` is used to construct the expression ``ex`` which applies "
"the ``+`` function to the value 1 and the variable ``b``. Note the important"
" distinction between the way ``a`` and ``b`` are used:"
msgstr ""

#: ../../manual/metaprogramming.rst:217
msgid ""
"The value of the *variable* ``a`` at expression construction time is used as"
" an immediate value in the expression. Thus, the value of ``a`` when the "
"expression is evaluated no longer matters: the value in the expression is "
"already ``1``, independent of whatever the value of ``a`` might be."
msgstr ""

#: ../../manual/metaprogramming.rst:222
msgid ""
"On the other hand, the *symbol* ``:b`` is used in the expression "
"construction, so the value of the variable ``b`` at that time is irrelevant "
"— ``:b`` is just a symbol and the variable ``b`` need not even be defined. "
"At expression evaluation time, however, the value of the symbol ``:b`` is "
"resolved by looking up the value of the variable ``b``."
msgstr ""

#: ../../manual/metaprogramming.rst:229
msgid ""
"Constructing ``Expr`` objects like this is powerful, but somewhat tedious "
"and ugly. Since the Julia parser is already excellent at producing "
"expression objects, Julia allows \"splicing\" or interpolation of expression"
" objects, prefixed with ``$``, into quoted expressions, written using normal"
" syntax. The above example can be written more clearly and concisely using "
"interpolation:"
msgstr ""

#: ../../manual/metaprogramming.rst:243
msgid ""
"This syntax is automatically rewritten to the form above where we explicitly"
" called ``Expr``. The use of ``$`` for expression interpolation is "
"intentionally reminiscent of :ref:`string interpolation <man-string-"
"interpolation>` and :ref:`command interpolation <man-command-"
"interpolation>`. Expression interpolation allows convenient, readable "
"programmatic construction of complex Julia expressions."
msgstr ""

#: ../../manual/metaprogramming.rst:252
msgid "Code Generation"
msgstr ""

#: ../../manual/metaprogramming.rst:254
msgid ""
"When a significant amount of repetitive boilerplate code is required, it is "
"common to generate it programmatically to avoid redundancy. In most "
"languages, this requires an extra build step, and a separate program to "
"generate the repetitive code. In Julia, expression interpolation and eval "
"allow such code generation to take place in the normal course of program "
"execution. For example, the following code defines a series of operators on "
"three arguments in terms of their 2-argument forms::"
msgstr ""

#: ../../manual/metaprogramming.rst:268
msgid ""
"In this manner, Julia acts as its own preprocessor, and allows code "
"generation from inside the language. The above code could be written "
"slightly more tersely using the ``:`` prefix quoting form::"
msgstr ""

#: ../../manual/metaprogramming.rst:276
msgid ""
"This sort of in-language code generation, however, using the "
"``eval(quote(...))`` pattern, is common enough that Julia comes with a macro"
" to abbreviate this pattern::"
msgstr ""

#: ../../manual/metaprogramming.rst:284
msgid ""
"The ``@eval`` macro rewrites this call to be precisely equivalent to the "
"above longer versions. For longer blocks of generated code, the expression "
"argument given to ``@eval`` can be a block::"
msgstr ""

#: ../../manual/metaprogramming.rst:292
msgid ""
"Interpolating into an unquoted expression is not supported and will cause a "
"compile-time error:"
msgstr ""

#: ../../manual/metaprogramming.rst:303
msgid "Macros"
msgstr ""

#: ../../manual/metaprogramming.rst:305
msgid ""
"Macros are the analogue of functions for expression generation at compile "
"time. Just as functions map a tuple of argument values to a return value, "
"macros map a tuple of argument *expressions* to a returned *expression*. "
"They allow the programmer to arbitrarily transform the written code to a "
"resulting expression, which then takes the place of the macro call in the "
"final syntax tree. Macros are invoked with the following general syntax::"
msgstr ""

#: ../../manual/metaprogramming.rst:316
msgid ""
"Note the distinguishing ``@`` before the macro name and the lack of commas "
"between the argument expressions in the first form, and the lack of "
"whitespace after ``@name`` in the second form. The two styles should not be "
"mixed. For example, the following syntax is different from the examples "
"above; it passes the tuple ``(expr1, expr2, ...)`` as one argument to the "
"macro::"
msgstr ""

#: ../../manual/metaprogramming.rst:325
msgid ""
"Before the program runs, this statement will be replaced with the returned "
"result of calling an expander function for ``@name`` on the expression "
"arguments. Expanders are defined with the ``macro`` keyword::"
msgstr ""

#: ../../manual/metaprogramming.rst:334
msgid ""
"Here, for example, is a simplified definition of Julia's ``@assert`` macro::"
msgstr ""

#: ../../manual/metaprogramming.rst:340
msgid "This macro can be used like this:"
msgstr ""

#: ../../manual/metaprogramming.rst:350
msgid ""
"In place of the written syntax, the macro call is expanded at parse time to "
"its returned result. This is equivalent to writing::"
msgstr ""

#: ../../manual/metaprogramming.rst:356
msgid ""
"That is, in the first call, the expression ``:(1==1.0)`` is spliced into the"
" test condition slot, while the value of ``string(:(1==1.0))`` is spliced "
"into the assertion message slot. The entire expression, thus constructed, is"
" placed into the syntax tree where the ``@assert`` macro call occurs. Then "
"at execution time, if the test expression evaluates to true, then "
"``nothing`` is returned, whereas if the test is false, an error is raised "
"indicating the asserted expression that was false. Notice that it would not "
"be possible to write this as a function, since only the *value* of the "
"condition is available and it would be impossible to display the expression "
"that computed it in the error message."
msgstr ""

#: ../../manual/metaprogramming.rst:367
msgid ""
"The actual definition of ``@assert`` in the standard library is more "
"complicated. It allows the user to optionally specify their own error "
"message, instead of just printing the failed expression. Just like in "
"functions with a variable number of arguments, this is specified with an "
"ellipses following the last argument::"
msgstr ""

#: ../../manual/metaprogramming.rst:379
msgid ""
"Now ``@assert`` has two modes of operation, depending upon the number of "
"arguments it receives! If there's only one argument, the tuple of "
"expressions captured by ``msgs`` will be empty and it will behave the same "
"as the simpler definition above. But now if the user specifies a second "
"argument, it is printed in the message body instead of the failing "
"expression. You can inspect the result of a macro expansion with the aptly "
"named :func:`macroexpand` function:"
msgstr ""

#: ../../manual/metaprogramming.rst:403
msgid ""
"There is yet another case that the actual ``@assert`` macro handles: what "
"if, in addition to printing \"a should equal b,\" we wanted to print their "
"values? One might naively try to use string interpolation in the custom "
"message, e.g., ``@assert a==b \"a ($a) should equal b ($b)!\"``, but this "
"won't work as expected with the above macro. Can you see why? Recall from "
":ref:`string interpolation <man-string-interpolation>` that an interpolated "
"string is rewritten to a call to the ``string`` function. Compare:"
msgstr ""

#: ../../manual/metaprogramming.rst:431
msgid ""
"So now instead of getting a plain string in ``msg_body``, the macro is "
"receiving a full expression that will need to be evaluated in order to "
"display as expected. This can be spliced directly into the returned "
"expression as an argument to the ``string`` call; see `error.jl "
"<https://github.com/JuliaLang/julia/blob/master/base/error.jl>`_ for the "
"complete implementation."
msgstr ""

#: ../../manual/metaprogramming.rst:438
msgid ""
"The ``@assert`` macro makes great use of splicing into quoted expressions to"
" simplify the manipulation of expressions inside the macro body."
msgstr ""

#: ../../manual/metaprogramming.rst:443
msgid "Hygiene"
msgstr ""

#: ../../manual/metaprogramming.rst:445
msgid ""
"An issue that arises in more complex macros is that of `hygiene "
"<http://en.wikipedia.org/wiki/Hygienic_macro>`_. In short, macros must "
"ensure that the variables they introduce in their returned expressions do "
"not accidentally clash with existing variables in the surrounding code they "
"expand into. Conversely, the expressions that are passed into a macro as "
"arguments are often *expected* to evaluate in the context of the surrounding"
" code, interacting with and modifying the existing variables. Another "
"concern arises from the fact that a macro may be called in a different "
"module from where it was defined. In this case we need to ensure that all "
"global variables are resolved to the correct module. Julia already has a "
"major advantage over languages with textual macro expansion (like C) in that"
" it only needs to consider the returned expression. All the other variables "
"(such as ``msg`` in ``@assert`` above) follow the :ref:`normal scoping block"
" behavior <man-variables-and-scoping>`."
msgstr ""

#: ../../manual/metaprogramming.rst:460
msgid ""
"To demonstrate these issues, let us consider writing a ``@time`` macro that "
"takes an expression as its argument, records the time, evaluates the "
"expression, records the time again, prints the difference between the before"
" and after times, and then has the value of the expression as its final "
"value. The macro might look like this::"
msgstr ""

#: ../../manual/metaprogramming.rst:477
msgid ""
"Here, we want ``t0``, ``t1``, and ``val`` to be private temporary variables,"
" and we want ``time`` to refer to the ``time`` function in the standard "
"library, not to any ``time`` variable the user might have (the same applies "
"to ``println``). Imagine the problems that could occur if the user "
"expression ``ex`` also contained assignments to a variable called ``t0``, or"
" defined its own ``time`` variable. We might get errors, or mysteriously "
"incorrect behavior."
msgstr ""

#: ../../manual/metaprogramming.rst:485
msgid ""
"Julia's macro expander solves these problems in the following way. First, "
"variables within a macro result are classified as either local or global. A "
"variable is considered local if it is assigned to (and not declared global),"
" declared local, or used as a function argument name. Otherwise, it is "
"considered global. Local variables are then renamed to be unique (using the "
"``gensym`` function, which generates new symbols), and global variables are "
"resolved within the macro definition environment. Therefore both of the "
"above concerns are handled; the macro's locals will not conflict with any "
"user variables, and ``time`` and ``println`` will refer to the standard "
"library definitions."
msgstr ""

#: ../../manual/metaprogramming.rst:496
msgid ""
"One problem remains however. Consider the following use of this macro::"
msgstr ""

#: ../../manual/metaprogramming.rst:506
msgid ""
"Here the user expression ``ex`` is a call to ``time``, but not the same "
"``time`` function that the macro uses. It clearly refers to "
"``MyModule.time``. Therefore we must arrange for the code in ``ex`` to be "
"resolved in the macro call environment. This is done by \"escaping\" the "
"expression with the ``esc`` function::"
msgstr ""

#: ../../manual/metaprogramming.rst:518
msgid ""
"An expression wrapped in this manner is left alone by the macro expander and"
" simply pasted into the output verbatim. Therefore it will be resolved in "
"the macro call environment."
msgstr ""

#: ../../manual/metaprogramming.rst:522
msgid ""
"This escaping mechanism can be used to \"violate\" hygiene when necessary, "
"in order to introduce or manipulate user variables. For example, the "
"following macro sets ``x`` to zero in the call environment::"
msgstr ""

#: ../../manual/metaprogramming.rst:536
msgid ""
"This kind of manipulation of variables should be used judiciously, but is "
"occasionally quite handy."
msgstr ""

#: ../../manual/metaprogramming.rst:542 ../../manual/strings.rst:525
msgid "Non-Standard AbstractString Literals"
msgstr ""

#: ../../manual/metaprogramming.rst:544
msgid ""
"Recall from :ref:`Strings <man-non-standard-string-literals>` that string "
"literals prefixed by an identifier are called non-standard string literals, "
"and can have different semantics than un-prefixed string literals. For "
"example:"
msgstr ""

#: ../../manual/metaprogramming.rst:549
msgid ""
"``r\"^\\s*(?:#|$)\"`` produces a regular expression object rather than a "
"string"
msgstr ""

#: ../../manual/metaprogramming.rst:551
msgid ""
"``b\"DATA\\xff\\u2200\"`` is a byte array literal for "
"``[68,65,84,65,255,226,136,128]``."
msgstr ""

#: ../../manual/metaprogramming.rst:554
msgid ""
"Perhaps surprisingly, these behaviors are not hard-coded into the Julia "
"parser or compiler. Instead, they are custom behaviors provided by a general"
" mechanism that anyone can use: prefixed string literals are parsed as calls"
" to specially-named macros. For example, the regular expression macro is "
"just the following::"
msgstr ""

#: ../../manual/metaprogramming.rst:564
msgid ""
"That's all. This macro says that the literal contents of the string literal "
"``r\"^\\s*(?:#|$)\"`` should be passed to the ``@r_str`` macro and the "
"result of that expansion should be placed in the syntax tree where the "
"string literal occurs. In other words, the expression ``r\"^\\s*(?:#|$)\"`` "
"is equivalent to placing the following object directly into the syntax "
"tree::"
msgstr ""

#: ../../manual/metaprogramming.rst:573
msgid ""
"Not only is the string literal form shorter and far more convenient, but it "
"is also more efficient: since the regular expression is compiled and the "
"``Regex`` object is actually created *when the code is compiled*, the "
"compilation occurs only once, rather than every time the code is executed. "
"Consider if the regular expression occurs in a loop::"
msgstr ""

#: ../../manual/metaprogramming.rst:588
msgid ""
"Since the regular expression ``r\"^\\s*(?:#|$)\"`` is compiled and inserted "
"into the syntax tree when this code is parsed, the expression is only "
"compiled once instead of each time the loop is executed. In order to "
"accomplish this without macros, one would have to write this loop like "
"this::"
msgstr ""

#: ../../manual/metaprogramming.rst:604
msgid ""
"Moreover, if the compiler could not determine that the regex object was "
"constant over all loops, certain optimizations might not be possible, making"
" this version still less efficient than the more convenient literal form "
"above. Of course, there are still situations where the non-literal form is "
"more convenient: if one needs to interpolate a variable into the regular "
"expression, one must take this more verbose approach; in cases where the "
"regular expression pattern itself is dynamic, potentially changing upon each"
" loop iteration, a new regular expression object must be constructed on each"
" iteration. In the vast majority of use cases, however, regular expressions "
"are not constructed based on run-time data. In this majority of cases, the "
"ability to write regular expressions as compile-time values is invaluable."
msgstr ""

#: ../../manual/metaprogramming.rst:617
msgid ""
"The mechanism for user-defined string literals is deeply, profoundly "
"powerful. Not only are Julia's non-standard literals implemented using it, "
"but also the command literal syntax (```echo \"Hello, $person\"```) is "
"implemented with the following innocuous-looking macro::"
msgstr ""

#: ../../manual/metaprogramming.rst:626
msgid ""
"Of course, a large amount of complexity is hidden in the functions used in "
"this macro definition, but they are just functions, written entirely in "
"Julia. You can read their source and see precisely what they do — and all "
"they do is construct expression objects to be inserted into your program's "
"syntax tree."
msgstr ""

#: ../../manual/metaprogramming.rst:633
msgid "Reflection"
msgstr ""

#: ../../manual/metaprogramming.rst:635
msgid ""
"In addition to the syntax-level introspection utilized in metaprogramming, "
"Julia provides several other runtime reflection capabilities."
msgstr ""

#: ../../manual/metaprogramming.rst:638
msgid ""
"**Type fields** The names of data type fields (or module members) may be "
"interrogated using the ``names`` function. For example, given the following "
"type::"
msgstr ""

#: ../../manual/metaprogramming.rst:646
msgid ""
"``names(Point)`` will return the array ``Any[:x, :y]``. The type of each "
"field in a ``Point`` is stored in the ``types`` field of the Point object::"
msgstr ""

#: ../../manual/metaprogramming.rst:654
msgid ""
"**Subtypes** The *direct* subtypes of any DataType may be listed using "
"``subtypes(t::DataType)``. For example, the abstract DataType "
"``FloatingPoint`` has four (concrete) subtypes::"
msgstr ""

#: ../../manual/metaprogramming.rst:665
msgid ""
"Any abstract subtype will also be included in this list, but further "
"subtypes thereof will not; recursive applications of ``subtypes`` allow to "
"build the full type tree."
msgstr ""

#: ../../manual/metaprogramming.rst:669
msgid ""
"**Type internals** The internal representation of types is critically "
"important when interfacing with C code. ``isbits(T::DataType)`` returns true"
" if `T` is stored with C-compatible alignment. The offsets of each field may"
" be listed using ``fieldoffsets(T::DataType)``."
msgstr ""

#: ../../manual/metaprogramming.rst:674
msgid ""
"**Function methods** The methods of any function may be listed using "
"``methods(f::Function)``."
msgstr ""

#: ../../manual/metaprogramming.rst:677
msgid ""
"**Function representations** Functions may be introspected at several levels"
" of representation. The lowered form of a function is available using "
"``code_lowered(f::Function, (Args...))``, and the type-inferred lowered form"
" is available using ``code_typed(f::Function, (Args...))``."
msgstr ""

#: ../../manual/metaprogramming.rst:682
msgid ""
"Closer to the machine, the LLVM Intermediate Representation of a function is"
" printed by ``code_llvm(f::Function, (Args...))``, and finally the resulting"
" assembly instructions (after JIT'ing step) are available using "
"``code_native(f::Function, (Args...)``."
msgstr ""

#: ../../manual/methods.rst:5
msgid "Methods"
msgstr ""

#: ../../manual/methods.rst:7
msgid ""
"Recall from :ref:`man-functions` that a function is an object that maps a "
"tuple of arguments to a return value, or throws an exception if no "
"appropriate value can be returned. It is common for the same conceptual "
"function or operation to be implemented quite differently for different "
"types of arguments: adding two integers is very different from adding two "
"floating-point numbers, both of which are distinct from adding an integer to"
" a floating-point number. Despite their implementation differences, these "
"operations all fall under the general concept of \"addition\". Accordingly, "
"in Julia, these behaviors all belong to a single object: the ``+`` function."
msgstr ""

#: ../../manual/methods.rst:18
msgid ""
"To facilitate using many different implementations of the same concept "
"smoothly, functions need not be defined all at once, but can rather be "
"defined piecewise by providing specific behaviors for certain combinations "
"of argument types and counts. A definition of one possible behavior for a "
"function is called a *method*. Thus far, we have presented only examples of "
"functions defined with a single method, applicable to all types of "
"arguments. However, the signatures of method definitions can be annotated to"
" indicate the types of arguments in addition to their number, and more than "
"a single method definition may be provided. When a function is applied to a "
"particular tuple of arguments, the most specific method applicable to those "
"arguments is applied. Thus, the overall behavior of a function is a "
"patchwork of the behaviors of its various method definitions. If the "
"patchwork is well designed, even though the implementations of the methods "
"may be quite different, the outward behavior of the function will appear "
"seamless and consistent."
msgstr ""

#: ../../manual/methods.rst:35
msgid ""
"The choice of which method to execute when a function is applied is called "
"*dispatch*. Julia allows the dispatch process to choose which of a "
"function's methods to call based on the number of arguments given, and on "
"the types of all of the function's arguments. This is different than "
"traditional object-oriented languages, where dispatch occurs based only on "
"the first argument, which often has a special argument syntax, and is "
"sometimes implied rather than explicitly written as an argument. [#]_ Using "
"all of a function's arguments to choose which method should be invoked, "
"rather than just the first, is known as `multiple dispatch "
"<http://en.wikipedia.org/wiki/Multiple_dispatch>`_. Multiple dispatch is "
"particularly useful for mathematical code, where it makes little sense to "
"artificially deem the operations to \"belong\" to one argument more than any"
" of the others: does the addition operation in ``x + y`` belong to ``x`` any"
" more than it does to ``y``? The implementation of a mathematical operator "
"generally depends on the types of all of its arguments. Even beyond "
"mathematical operations, however, multiple dispatch ends up being a powerful"
" and convenient paradigm for structuring and organizing programs."
msgstr ""

#: ../../manual/methods.rst:55
msgid ""
"In C++ or Java, for example, in a method call like ``obj.meth(arg1,arg2)``, "
"the object obj \"receives\" the method call and is implicitly passed to the "
"method via the ``this`` keyword, rather then as an explicit method argument."
" When the current ``this`` object is the receiver of a method call, it can "
"be omitted altogether, writing just ``meth(arg1,arg2)``, with this implied "
"as the receiving object."
msgstr ""

#: ../../manual/methods.rst:64
msgid "Defining Methods"
msgstr ""

#: ../../manual/methods.rst:66
msgid ""
"Until now, we have, in our examples, defined only functions with a single "
"method having unconstrained argument types. Such functions behave just like "
"they would in traditional dynamically typed languages. Nevertheless, we have"
" used multiple dispatch and methods almost continually without being aware "
"of it: all of Julia's standard functions and operators, like the "
"aforementioned ``+`` function, have many methods defining their behavior "
"over various possible combinations of argument type and count."
msgstr ""

#: ../../manual/methods.rst:75
msgid ""
"When defining a function, one can optionally constrain the types of "
"parameters it is applicable to, using the ``::`` type-assertion operator, "
"introduced in the section on :ref:`man-composite-types`:"
msgstr ""

#: ../../manual/methods.rst:83
msgid ""
"This function definition applies only to calls where ``x`` and ``y`` are "
"both values of type ``Float64``:"
msgstr ""

#: ../../manual/methods.rst:91
msgid ""
"Applying it to any other types of arguments will result in a \"no method\" "
"error:"
msgstr ""

#: ../../manual/methods.rst:108
msgid ""
"As you can see, the arguments must be precisely of type ``Float64``. Other "
"numeric types, such as integers or 32-bit floating-point values, are not "
"automatically converted to 64-bit floating-point, nor are strings parsed as "
"numbers. Because ``Float64`` is a concrete type and concrete types cannot be"
" subclassed in Julia, such a definition can only be applied to arguments "
"that are exactly of type ``Float64``. It may often be useful, however, to "
"write more general methods where the declared parameter types are abstract:"
msgstr ""

#: ../../manual/methods.rst:124
msgid ""
"This method definition applies to any pair of arguments that are instances "
"of ``Number``. They need not be of the same type, so long as they are each "
"numeric values. The problem of handling disparate numeric types is delegated"
" to the arithmetic operations in the expression ``2x - y``."
msgstr ""

#: ../../manual/methods.rst:130
msgid ""
"To define a function with multiple methods, one simply defines the function "
"multiple times, with different numbers and types of arguments. The first "
"method definition for a function creates the function object, and subsequent"
" method definitions add new methods to the existing function object. The "
"most specific method definition matching the number and types of the "
"arguments will be executed when the function is applied. Thus, the two "
"method definitions above, taken together, define the behavior for ``f`` over"
" all pairs of instances of the abstract type ``Number`` — but with a "
"different behavior specific to pairs of ``Float64`` values. If one of the "
"arguments is a 64-bit float but the other one is not, then the "
"``f(Float64,Float64)`` method cannot be called and the more general "
"``f(Number,Number)`` method must be used:"
msgstr ""

#: ../../manual/methods.rst:157
msgid ""
"The ``2x + y`` definition is only used in the first case, while the ``2x - "
"y`` definition is used in the others. No automatic casting or conversion of "
"function arguments is ever performed: all conversion in Julia is non-magical"
" and completely explicit. :ref:`man-conversion-and-promotion`, however, "
"shows how clever application of sufficiently advanced technology can be "
"indistinguishable from magic. [Clarke61]_"
msgstr ""

#: ../../manual/methods.rst:164
msgid ""
"For non-numeric values, and for fewer or more than two arguments, the "
"function ``f`` remains undefined, and applying it will still result in a "
"\"no method\" error:"
msgstr ""

#: ../../manual/methods.rst:176
msgid ""
"You can easily see which methods exist for a function by entering the "
"function object itself in an interactive session:"
msgstr ""

#: ../../manual/methods.rst:184
msgid ""
"This output tells us that ``f`` is a function object with two methods. To "
"find out what the signatures of those methods are, use the ``methods`` "
"function:"
msgstr ""

#: ../../manual/methods.rst:195
msgid ""
"which shows that f has two methods, one taking two ``Float64`` arguments and"
" one taking arguments of type ``Number``. It also indicates the file and "
"line number where the methods were defined: because these methods were "
"defined at the REPL, we get the apparent line number ``none:1``."
msgstr ""

#: ../../manual/methods.rst:201
msgid ""
"In the absence of a type declaration with ``::``, the type of a method "
"parameter is ``Any`` by default, meaning that it is unconstrained since all "
"values in Julia are instances of the abstract type ``Any``. Thus, we can "
"define a catch-all method for ``f`` like so:"
msgstr ""

#: ../../manual/methods.rst:213
msgid ""
"This catch-all is less specific than any other possible method definition "
"for a pair of parameter values, so it is only be called on pairs of "
"arguments to which no other method definition applies."
msgstr ""

#: ../../manual/methods.rst:217
msgid ""
"Although it seems a simple concept, multiple dispatch on the types of values"
" is perhaps the single most powerful and central feature of the Julia "
"language. Core operations typically have dozens of methods::"
msgstr ""

#: ../../manual/methods.rst:349
msgid ""
"Multiple dispatch together with the flexible parametric type system give "
"Julia its ability to abstractly express high-level algorithms decoupled from"
" implementation details, yet generate efficient, specialized code to handle "
"each case at run time."
msgstr ""

#: ../../manual/methods.rst:355
msgid "Method Ambiguities"
msgstr ""

#: ../../manual/methods.rst:357
msgid ""
"It is possible to define a set of function methods such that there is no "
"unique most specific method applicable to some combinations of arguments:"
msgstr ""

#: ../../manual/methods.rst:383
msgid ""
"Here the call ``g(2.0, 3.0)`` could be handled by either the ``g(Float64, "
"Any)`` or the ``g(Any, Float64)`` method, and neither is more specific than "
"the other. In such cases, Julia warns you about this ambiguity, but allows "
"you to proceed, arbitrarily picking a method. You should avoid method "
"ambiguities by specifying an appropriate method for the intersection case:"
msgstr ""

#: ../../manual/methods.rst:407
msgid ""
"To suppress Julia's warning, the disambiguating method must be defined "
"first, since otherwise the ambiguity exists, if transiently, until the more "
"specific method is defined."
msgstr ""

#: ../../manual/methods.rst:414
msgid "Parametric Methods"
msgstr ""

#: ../../manual/methods.rst:416
msgid ""
"Method definitions can optionally have type parameters immediately after the"
" method name and before the parameter tuple:"
msgstr ""

#: ../../manual/methods.rst:425
msgid ""
"The first method applies whenever both arguments are of the same concrete "
"type, regardless of what type that is, while the second method acts as a "
"catch-all, covering all other cases. Thus, overall, this defines a boolean "
"function that checks whether its two arguments are of the same type:"
msgstr ""

#: ../../manual/methods.rst:451
msgid ""
"This kind of definition of function behavior by dispatch is quite common — "
"idiomatic, even — in Julia. Method type parameters are not restricted to "
"being used as the types of parameters: they can be used anywhere a value "
"would be in the signature of the function or body of the function. Here's an"
" example where the method type parameter ``T`` is used as the type parameter"
" to the parametric type ``Vector{T}`` in the method signature:"
msgstr ""

#: ../../manual/methods.rst:484
msgid ""
"As you can see, the type of the appended element must match the element type"
" of the vector it is appended to, or a \"no method\" error is raised. In the"
" following example, the method type parameter ``T`` is used as the return "
"value:"
msgstr ""

#: ../../manual/methods.rst:500
msgid ""
"Just as you can put subtype constraints on type parameters in type "
"declarations (see :ref:`man-parametric-types`), you can also constrain type "
"parameters of methods::"
msgstr ""

#: ../../manual/methods.rst:525
msgid ""
"The ``same_type_numeric`` function behaves much like the ``same_type`` "
"function defined above, but is only defined for pairs of numbers."
msgstr ""

#: ../../manual/methods.rst:529
msgid "Note on Optional and keyword Arguments"
msgstr ""

#: ../../manual/methods.rst:531
msgid ""
"As mentioned briefly in :ref:`man-functions`, optional arguments are "
"implemented as syntax for multiple method definitions. For example, this "
"definition::"
msgstr ""

#: ../../manual/methods.rst:537
msgid "translates to the following three methods::"
msgstr ""

#: ../../manual/methods.rst:543
msgid ""
"Keyword arguments behave quite differently from ordinary positional "
"arguments. In particular, they do not participate in method dispatch. "
"Methods are dispatched based only on positional arguments, with keyword "
"arguments processed after the matching method is identified."
msgstr ""

#: ../../manual/methods.rst:548
msgid "Arthur C. Clarke, *Profiles of the Future* (1961): Clarke's Third Law."
msgstr ""

#: ../../manual/modules.rst:5
msgid "Modules"
msgstr ""

#: ../../manual/modules.rst:9
msgid ""
"Modules in Julia are separate global variable workspaces. They are delimited"
" syntactically, inside ``module Name ... end``. Modules allow you to create "
"top-level definitions without worrying about name conflicts when your code "
"is used together with somebody else's. Within a module, you can control "
"which names from other modules are visible (via importing), and specify "
"which of your names are intended to be public (via exporting)."
msgstr ""

#: ../../manual/modules.rst:16
msgid ""
"The following example demonstrates the major features of modules. It is not "
"meant to be run, but is shown for illustrative purposes::"
msgstr ""

#: ../../manual/modules.rst:40
msgid ""
"Note that the style is not to indent the body of the module, since that "
"would typically lead to whole files being indented."
msgstr ""

#: ../../manual/modules.rst:43
msgid ""
"This module defines a type ``MyType``, and two functions. Function ``foo`` "
"and type ``MyType`` are exported, and so will be available for importing "
"into other modules.  Function ``bar`` is private to ``MyModule``."
msgstr ""

#: ../../manual/modules.rst:48
msgid ""
"The statement ``using Lib`` means that a module called ``Lib`` will be "
"available for resolving names as needed. When a global variable is "
"encountered that has no definition in the current module, the system will "
"search for it among variables exported by ``Lib`` and import it if it is "
"found there. This means that all uses of that global within the current "
"module will resolve to the definition of that variable in ``Lib``."
msgstr ""

#: ../../manual/modules.rst:56
msgid ""
"The statement ``using BigLib: thing1, thing2`` is a syntactic shortcut for "
"``using BigLib.thing1, BigLib.thing2``."
msgstr ""

#: ../../manual/modules.rst:59
msgid ""
"The ``import`` keyword supports all the same syntax as ``using``, but only "
"operates on a single name at a time. It does not add modules to be searched "
"the way ``using`` does. ``import`` also differs from ``using`` in that "
"functions must be imported using ``import`` to be extended with new methods."
msgstr ""

#: ../../manual/modules.rst:64
msgid ""
"In ``MyModule`` above we wanted to add a method to the standard ``show`` "
"function, so we had to write ``import Base.show``. Functions whose names are"
" only visible via ``using`` cannot be extended."
msgstr ""

#: ../../manual/modules.rst:68
msgid ""
"The keyword ``importall`` explicitly imports all names exported by the "
"specified module, as if ``import`` were individually used on all of them."
msgstr ""

#: ../../manual/modules.rst:71
msgid ""
"Once a variable is made visible via ``using`` or ``import``, a module may "
"not create its own variable with the same name. Imported variables are read-"
"only; assigning to a global variable always affects a variable owned by the "
"current module, or else raises an error."
msgstr ""

#: ../../manual/modules.rst:78
msgid "Summary of module usage"
msgstr ""

#: ../../manual/modules.rst:80
msgid ""
"To load a module, two main keywords can be used: ``using`` and ``import``. "
"To understand their differences, consider the following example::"
msgstr ""

#: ../../manual/modules.rst:92
msgid ""
"In this module we export the ``x`` and ``y`` functions (with the keyword "
"``export``), and also have the non-exported function ``p``. There are "
"several different ways to load the Module and its inner functions into the "
"current workspace:"
msgstr ""

#: ../../manual/modules.rst:95
msgid "Import Command"
msgstr ""

#: ../../manual/modules.rst:95
msgid "What is brought into scope"
msgstr ""

#: ../../manual/modules.rst:95
msgid "Available for method extension"
msgstr ""

#: ../../manual/modules.rst:97
msgid "``using MyModule``"
msgstr ""

#: ../../manual/modules.rst:97
msgid ""
"All ``export`` ed names (``x`` and ``y``), ``MyModule.x``, ``MyModule.y`` "
"and ``MyModule.p``"
msgstr ""

#: ../../manual/modules.rst:97 ../../manual/modules.rst:103
#: ../../manual/modules.rst:103
msgid "``MyModule.x``, ``MyModule.y`` and ``MyModule.p``"
msgstr ""

#: ../../manual/modules.rst:99
msgid "``using MyModule.x, MyModule.p``"
msgstr ""

#: ../../manual/modules.rst:99 ../../manual/modules.rst:101
#: ../../manual/modules.rst:105 ../../manual/modules.rst:105
#: ../../manual/modules.rst:107 ../../manual/modules.rst:107
msgid "``x`` and ``p``"
msgstr ""

#: ../../manual/modules.rst:101
msgid "``using MyModule: x, p``"
msgstr ""

#: ../../manual/modules.rst:103
msgid "``import MyModule``"
msgstr ""

#: ../../manual/modules.rst:105
msgid "``import MyModule.x, MyModule.p``"
msgstr ""

#: ../../manual/modules.rst:107
msgid "``import MyModule: x, p``"
msgstr ""

#: ../../manual/modules.rst:109
msgid "``importall MyModule``"
msgstr ""

#: ../../manual/modules.rst:109
msgid "All ``export`` ed names (``x`` and ``y``)"
msgstr ""

#: ../../manual/modules.rst:109
msgid "``x`` and ``y``"
msgstr ""

#: ../../manual/modules.rst:114
msgid "Modules and files"
msgstr ""

#: ../../manual/modules.rst:116
msgid ""
"Files and file names are mostly unrelated to modules; modules are associated"
" only with module expressions. One can have multiple files per module, and "
"multiple modules per file::"
msgstr ""

#: ../../manual/modules.rst:127
msgid ""
"Including the same code in different modules provides mixin-like behavior. "
"One could use this to run the same code with different base definitions, for"
" example testing code by running it with \"safe\" versions of some "
"operators::"
msgstr ""

#: ../../manual/modules.rst:143
msgid "Standard modules"
msgstr ""

#: ../../manual/modules.rst:145
msgid "There are three important standard modules: Main, Core, and Base."
msgstr ""

#: ../../manual/modules.rst:147
msgid ""
"Main is the top-level module, and Julia starts with Main set as the current "
"module.  Variables defined at the prompt go in Main, and ``whos()`` lists "
"variables in Main."
msgstr ""

#: ../../manual/modules.rst:151
msgid ""
"Core contains all identifiers considered \"built in\" to the language, i.e. "
"part of the core language and not libraries. Every module implicitly "
"specifies ``using Core``, since you can't do anything without those "
"definitions."
msgstr ""

#: ../../manual/modules.rst:156
msgid ""
"Base is the standard library (the contents of base/). All modules implicitly"
" contain ``using Base``, since this is needed in the vast majority of cases."
msgstr ""

#: ../../manual/modules.rst:161
msgid "Default top-level definitions and bare modules"
msgstr ""

#: ../../manual/modules.rst:163
msgid ""
"In addition to ``using Base``, all operators are explicitly imported, since "
"one typically wants to extend operators rather than creating entirely new "
"definitions of them. A module also automatically contains a definition of "
"the ``eval`` function, which evaluates expressions within the context of "
"that module."
msgstr ""

#: ../../manual/modules.rst:169
msgid ""
"If these definitions are not wanted, modules can be defined using the "
"keyword ``baremodule`` instead. In terms of ``baremodule``, a standard "
"``module`` looks like this::"
msgstr ""

#: ../../manual/modules.rst:188
msgid "Relative and absolute module paths"
msgstr ""

#: ../../manual/modules.rst:190
msgid ""
"Given the statement ``using Foo``, the system looks for ``Foo`` within "
"``Main``. If the module does not exist, the system attempts to "
"``require(\"Foo\")``, which typically results in loading code from an "
"installed package."
msgstr ""

#: ../../manual/modules.rst:195
msgid ""
"However, some modules contain submodules, which means you sometimes need to "
"access a module that is not directly available in ``Main``. There are two "
"ways to do this. The first is to use an absolute path, for example ``using "
"Base.Sort``. The second is to use a relative path, which makes it easier to "
"import submodules of the current module or any of its enclosing modules::"
msgstr ""

#: ../../manual/modules.rst:213
msgid ""
"Here module ``Parent`` contains a submodule ``Utils``, and code in "
"``Parent`` wants the contents of ``Utils`` to be visible. This is done by "
"starting the ``using`` path with a period. Adding more leading periods moves"
" up additional levels in the module hierarchy. For example ``using ..Utils``"
" would look for ``Utils`` in ``Parent``'s enclosing module rather than in "
"``Parent`` itself."
msgstr ""

#: ../../manual/modules.rst:222
msgid "Module file paths"
msgstr ""

#: ../../manual/modules.rst:224
msgid ""
"The global variable LOAD_PATH contains the directories Julia searches for "
"modules when calling ``require``. It can be extended using ``push!``::"
msgstr ""

#: ../../manual/modules.rst:229
msgid ""
"Putting this statement in the file ``~/.juliarc.jl`` will extend LOAD_PATH "
"on every Julia startup. Alternatively, the module load path can be extended "
"by defining the environment variable JULIA_LOAD_PATH."
msgstr ""

#: ../../manual/modules.rst:235
msgid "Namespace miscellanea"
msgstr ""

#: ../../manual/modules.rst:237
msgid ""
"If a name is qualified (e.g. ``Base.sin``), then it can be accessed even if "
"it is not exported. This is often useful when debugging."
msgstr ""

#: ../../manual/modules.rst:240
msgid ""
"Macro names are written with ``@`` in import and export statements, e.g. "
"``import Mod.@mac``. Macros in other modules can be invoked as ``Mod.@mac`` "
"or ``@Mod.mac``."
msgstr ""

#: ../../manual/modules.rst:244
msgid ""
"The syntax ``M.x = y`` does not work to assign a global in another module; "
"global assignment is always module-local."
msgstr ""

#: ../../manual/modules.rst:247
msgid ""
"A variable can be \"reserved\" for the current module without assigning to "
"it by declaring it as ``global x`` at the top level. This can be used to "
"prevent name conflicts for globals initialized after load time."
msgstr ""

#: ../../manual/modules.rst:252
msgid "Module initialization and precompilation"
msgstr ""

#: ../../manual/modules.rst:254
msgid ""
"Large modules can take several second to load because executing all of the "
"statements in a module often involves compiling a large amount of code.  "
"However, Julia is progressively gaining more ability to cache the parsed and"
" compiled binary image of a package.  Currently, this requires one to "
"recompile Julia after modifying the file ``base/userimg.jl`` to require the "
"desired modules, but in a future version of Julia the module caching will be"
" simpler and more automated.  In order to make your module work with "
"precompilation, however, you may need to change your module to explicitly "
"separate any initialization steps that must occur at *runtime* from steps "
"that can occur at *compile time*.  For this purpose, Julia allows you to "
"define an ``__init__()`` function in your module that executes any "
"initialization steps that must occur at runtime."
msgstr ""

#: ../../manual/modules.rst:268
msgid ""
"In particular, if you define a ``function __init__()`` in a module, then "
"Julia will call ``__init__()`` immediately *after* the module is loaded "
"(e.g., by ``import``, ``using``, or ``require``) at runtime for the *first* "
"time (i.e., ``__init__`` is only called once, and only after all statements "
"in the module have been executed).  Because it is called after the module is"
" fully imported, any submodules or other imported modules have their "
"``__init__`` functions called *before* the ``__init__`` of the enclosing "
"module."
msgstr ""

#: ../../manual/modules.rst:277
msgid ""
"Two typical uses of ``__init__`` are calling runtime initialization "
"functions of external C libraries and initializing global constants that "
"involve pointers returned by external libraries.  For example, suppose that "
"we are calling a C library ``libfoo`` that requires us to call a "
"``foo_init()`` initialization function at runtime.   Suppose that we also "
"want to define a global constant ``foo_data_ptr`` that holds the return "
"value of a ``void *foo_data()`` function defined by ``libfoo`` — this "
"constant must be initialized at runtime (not at compile time) because the "
"pointer address will change from run to run.  You could accomplish this by "
"defining the following ``__init__`` function in your module::"
msgstr ""

#: ../../manual/modules.rst:294
msgid ""
"(Notice that it is perfectly possible to define a global constant inside a "
"function like ``__init__``; this is one of the advantages of using a dynamic"
" language.)   Obviously, any other constant in your module that depends on "
"``foo_data_ptr`` would also have to be initialized in ``__init__``."
msgstr ""

#: ../../manual/modules.rst:299
msgid ""
"Constants involving most Julia objects that are not produced by ``ccall`` do"
" not need to be placed in ``__init__``: their definitions can be precompiled"
" and loaded from the cached module image.  (This includes complicated heap-"
"allocated objects like arrays.)  However, any routine that returns a raw "
"pointer value must be called at runtime for precompilation to work.  This "
"includes the Julia functions ``cfunction`` and ``pointer``."
msgstr ""

#: ../../manual/modules.rst:307
msgid ""
"Dictionary and set types, or in general anything that depends on the output "
"of a ``hash(key)`` method, are a trickier case.  In the common case where "
"the keys are numbers, strings, symbols, ranges, ``Expr``, or compositions of"
" these types (via arrays, tuples, sets, pairs, etc.) they are safe to "
"precompile.  However, for a few other key types, such as ``Function`` or "
"``DataType`` and generic user-defined types where you haven't defined a "
"``hash`` method, the fallback ``hash`` method depends on the memory address "
"of the object (via its ``object_id``) and hence may change from run to run."
"  If you have one of these key types, or if you aren't sure, to be safe you "
"can initialize dictionary and set globals from within your ``__init__`` "
"function. Alternatively, you can use the ``ObjectIdDict`` dictionary type, "
"which is specially handled by precompilation so that it is safe to "
"initialize at compile-time."
msgstr ""

#: ../../manual/modules.rst:7
msgid "module"
msgstr ""

#: ../../manual/modules.rst:7
msgid "baremodule"
msgstr ""

#: ../../manual/modules.rst:7
msgid "using"
msgstr ""

#: ../../manual/modules.rst:7
msgid "import"
msgstr ""

#: ../../manual/modules.rst:7
msgid "export"
msgstr ""

#: ../../manual/modules.rst:7
msgid "importall"
msgstr ""

#: ../../manual/networking-and-streams.rst:5
msgid "Networking and Streams"
msgstr ""

#: ../../manual/networking-and-streams.rst:7
msgid ""
"Julia provides a rich interface to deal with streaming I/O objects such as "
"Terminals, Pipes and Tcp Sockets. This interface, though asynchronous at the"
" system level, is presented in a synchronous manner to the programmer and it"
" is usually unnecessary to think about the underlying asynchronous "
"operation. This is achieved by making heavy use of Julia cooperative "
"threading (coroutine) functionality."
msgstr ""

#: ../../manual/networking-and-streams.rst:15
msgid "Basic Stream I/O"
msgstr ""

#: ../../manual/networking-and-streams.rst:17
msgid ""
"All Julia streams expose at least a `read` and a `write` method, taking the "
"stream as their first argument, e.g.::"
msgstr ""

#: ../../manual/networking-and-streams.rst:26
msgid ""
"Note that I pressed enter again so that Julia would read the newline. Now, "
"as you can see from this example, the `write` method takes the data to write"
" as its second argument, while the read method takes the type of the data to"
" be read as the second argument. For example, to read a simple byte array, "
"we could do::"
msgstr ""

#: ../../manual/networking-and-streams.rst:45
msgid ""
"However, since this is slightly cumbersome, there are several convenience "
"methods provided. For example, we could have written the above as::"
msgstr ""

#: ../../manual/networking-and-streams.rst:56
msgid "or if we had wanted to read the entire line instead::"
msgstr ""

#: ../../manual/networking-and-streams.rst:62
msgid ""
"Note that depending on your terminal settings, your TTY may be line buffered"
" and might thus require an additional enter before the data is sent to "
"julia."
msgstr ""

#: ../../manual/networking-and-streams.rst:65
msgid "To read every line from STDIN you can use the eachline method::"
msgstr ""

#: ../../manual/networking-and-streams.rst:71
msgid "or if you wanted to read by character instead::"
msgstr ""

#: ../../manual/networking-and-streams.rst:79
msgid "Text I/O"
msgstr ""

#: ../../manual/networking-and-streams.rst:81
msgid ""
"Note that the write method mentioned above operates on binary streams. In "
"particular, values do not get converted to any canoncical text "
"representation but are written out as is::"
msgstr ""

#: ../../manual/networking-and-streams.rst:87
msgid ""
"For Text I/O, use the `print` or `show` methods, depending on your needs "
"(see the standard library reference for a detailed discussion of the "
"difference between the two)::"
msgstr ""

#: ../../manual/networking-and-streams.rst:94
msgid "Working with Files"
msgstr ""

#: ../../manual/networking-and-streams.rst:96
msgid ""
"Like many other environments, Julia has an `open` function, which takes a "
"filename and returns an `IOStream` object that you can use to read and write"
" things from the file. For example if we have a file, `hello.txt`, whose "
"contents are \"Hello, World!\"::"
msgstr ""

#: ../../manual/networking-and-streams.rst:107
msgid ""
"If you want to write to a file, you can open it with the write (`\"w\"`) "
"flag::"
msgstr ""

#: ../../manual/networking-and-streams.rst:115
msgid ""
"If you examine the contents of `hello.txt` at this point, you will notice "
"that it is empty; nothing has actually been written to disk yet. This is "
"because the IOStream must be closed before the write is actually flushed to "
"disk::"
msgstr ""

#: ../../manual/networking-and-streams.rst:120
msgid "Examining hello.txt again will show it's contents have been changed."
msgstr ""

#: ../../manual/networking-and-streams.rst:122
msgid ""
"Opening a file, doing something to it's contents, and closing it again is a "
"very common pattern. To make this easier, there exists another invocation of"
" `open` which takes a function as it's first argument and filename as it's "
"second, opens the file, calls the function with the file as an argument, and"
" then closes it again. For example, given a function::"
msgstr ""

#: ../../manual/networking-and-streams.rst:131
msgid "You can call::"
msgstr ""

#: ../../manual/networking-and-streams.rst:136
msgid ""
"to open `hello.txt`, call `read_and_capitalize on it`, close `hello.txt`. "
"and return the capitalized contents."
msgstr ""

#: ../../manual/networking-and-streams.rst:138
msgid ""
"To avoid even having to define a named function, you can use the `do` "
"syntax, which creates an anonymous function on the fly::"
msgstr ""

#: ../../manual/networking-and-streams.rst:148
msgid "A simple TCP example"
msgstr ""

#: ../../manual/networking-and-streams.rst:150
msgid ""
"Let's jump right in with a simple example involving Tcp Sockets. Let's first"
" create a simple server::"
msgstr ""

#: ../../manual/networking-and-streams.rst:163
msgid ""
"To those familiar with the Unix socket API, the method names will feel "
"familiar, though their usage is somewhat simpler than the raw Unix socket "
"API. The first call to `listen` will create a server waiting for incoming "
"connections on the specified port (2000) in this case. The same function may"
" also be used to create various other kinds of servers::"
msgstr ""

#: ../../manual/networking-and-streams.rst:187
msgid ""
"Note that the return type of the last invocation is different. This is "
"because this server does not listen on TCP, but rather on a Named Pipe "
"(Windows terminology) - also called a Domain Socket (UNIX Terminology). The "
"difference is subtle and has to do with the `accept` and `connect` methods. "
"The `accept` method retrieves a connection to the client that is connecting "
"on the server we just created, while the `connect` function connects to a "
"server using the specified method. The `connect` function takes the same "
"arguments as `listen`, so, assuming the environment (i.e. host, cwd, etc.) "
"is the same you should be able to pass the same arguments to `connect` as "
"you did to listen to establish the connection. So let's try that out (after "
"having created the server above)::"
msgstr ""

#: ../../manual/networking-and-streams.rst:203
msgid ""
"As expected we saw \"Hello World\" printed. So, let's actually analyze what "
"happened behind the scenes. When we called connect, we connect to the server"
" we had just created. Meanwhile, the accept function returns a server-side "
"connection to the newly created socket and prints \"Hello World\" to "
"indicate that the connection was successful."
msgstr ""

#: ../../manual/networking-and-streams.rst:205
msgid ""
"A great strength of Julia is that since the API is exposed synchronously "
"even though the I/O is actually happening asynchronously, we didn't have to "
"worry callbacks or even making sure that the server gets to run. When we "
"called `connect` the current task waited for the connection to be "
"established and only continued executing after that was done. In this pause,"
" the server task resumed execution (because a connection request was now "
"available), accepted the connection, printed the message and waited for the "
"next client. Reading and writing works in the same way. To see this, "
"consider the following simple echo server::"
msgstr ""

#: ../../manual/networking-and-streams.rst:230
msgid "Resolving IP Addresses"
msgstr ""

#: ../../manual/networking-and-streams.rst:232
msgid ""
"One of the `connect` methods that does not follow the `listen` methods is "
"`connect(host::ASCIIString,port)`, which will attempt to connect to the host"
" given by the `host` parameter on the port given by the port parameter. It "
"allows you to do things like::"
msgstr ""

#: ../../manual/networking-and-streams.rst:239
msgid ""
"At the base of this functionality is the getaddrinfo function which will do "
"the appropriate address resolution::"
msgstr ""

#: ../../manual/noteworthy-differences.rst:5
msgid "Noteworthy Differences from other Languages"
msgstr ""

#: ../../manual/noteworthy-differences.rst:8
msgid "Noteworthy differences from MATLAB"
msgstr ""

#: ../../manual/noteworthy-differences.rst:10
msgid ""
"Although MATLAB users may find Julia's syntax familiar, Julia is in no way a"
" MATLAB clone. There are major syntactic and functional differences. The "
"following are some noteworthy differences that may trip up Julia users "
"accustomed to MATLAB:"
msgstr ""

#: ../../manual/noteworthy-differences.rst:15
msgid "Arrays are indexed with square brackets, ``A[i,j]``."
msgstr ""

#: ../../manual/noteworthy-differences.rst:16
msgid ""
"Arrays are assigned by reference. After ``A=B``, assigning into ``B`` will "
"modify ``A`` as well."
msgstr ""

#: ../../manual/noteworthy-differences.rst:18
msgid ""
"Values are passed and assigned by reference. If a function modifies an "
"array, the changes will be visible in the caller."
msgstr ""

#: ../../manual/noteworthy-differences.rst:20
msgid ""
"Matlab combines allocation and assignment into single statements, e.g., "
"``a(4) = 3.2`` creates the array ``a = [0 0 0 3.2]`` and ``a(5) = 7`` grows "
"it. Julia separates allocation and assignment: if ``a`` is of length 4, "
"``a[5] = 7`` yields an error. Julia has a ``push!`` function which grows "
"``Vectors`` much more efficiently than Matlab's ``a(end+1) = val``."
msgstr ""

#: ../../manual/noteworthy-differences.rst:26
msgid "The imaginary unit ``sqrt(-1)`` is represented in julia with ``im``."
msgstr ""

#: ../../manual/noteworthy-differences.rst:27
msgid ""
"Literal numbers without a decimal point (such as ``42``) create integers "
"instead of floating point numbers. Arbitrarily large integer literals are "
"supported. But this means that some operations such as ``2^-1`` will throw a"
" domain error as the result is not an integer (see :ref:`the FAQ entry on "
"domain errors <man-domain-error>` for details)."
msgstr ""

#: ../../manual/noteworthy-differences.rst:32
msgid ""
"Multiple values are returned and assigned with parentheses, ``return (a, "
"b)`` and ``(a, b) = f(x)``."
msgstr ""

#: ../../manual/noteworthy-differences.rst:34
msgid ""
"Julia has 1-dimensional arrays. Column vectors are of size ``N``, not "
"``Nx1``. For example, ``rand(N)`` makes a 1-dimensional array."
msgstr ""

#: ../../manual/noteworthy-differences.rst:36
msgid ""
"Concatenating scalars and arrays with the syntax ``[x,y,z]`` concatenates in"
" the first dimension (\"vertically\"). For the second dimension "
"(\"horizontally\"), use spaces as in ``[x y z]``. To construct block "
"matrices (concatenating in the first two dimensions), the syntax ``[a b; c "
"d]`` is used to avoid confusion."
msgstr ""

#: ../../manual/noteworthy-differences.rst:41
msgid ""
"Colons ``a:b`` and ``a:b:c`` construct ``Range`` objects. To construct a "
"full vector, use ``linspace``, or \"concatenate\" the range by enclosing it "
"in brackets, ``[a:b]``."
msgstr ""

#: ../../manual/noteworthy-differences.rst:44
msgid ""
"Functions return values using the ``return`` keyword, instead of by listing "
"their names in the function definition (see :ref:`man-return-keyword` for "
"details)."
msgstr ""

#: ../../manual/noteworthy-differences.rst:47
msgid ""
"A file may contain any number of functions, and all definitions will be "
"externally visible when the file is loaded."
msgstr ""

#: ../../manual/noteworthy-differences.rst:49
msgid ""
"Reductions such as ``sum``, ``prod``, and ``max`` are performed over every "
"element of an array when called with a single argument as in ``sum(A)``."
msgstr ""

#: ../../manual/noteworthy-differences.rst:52
msgid ""
"Functions such as ``sort`` that operate column-wise by default (``sort(A)`` "
"is equivalent to ``sort(A,1)``) do not have special behavior for 1xN arrays;"
" the argument is returned unmodified since it still performs ``sort(A,1)``. "
"To sort a 1xN matrix like a vector, use ``sort(A,2)``."
msgstr ""

#: ../../manual/noteworthy-differences.rst:57
msgid ""
"If ``A`` is a 2-dimensional array ``fft(A)`` computes a 2D FFT. In "
"particular, it is not equivalent to ``fft(A,1)``, which computes a 1D FFT "
"acting column-wise."
msgstr ""

#: ../../manual/noteworthy-differences.rst:59
msgid ""
"Parentheses must be used to call a function with zero arguments, as in "
"``tic()`` and ``toc()``."
msgstr ""

#: ../../manual/noteworthy-differences.rst:61
msgid ""
"Do not use semicolons to end statements. The results of statements are not "
"automatically printed (except at the interactive prompt), and lines of code "
"do not need to end with semicolons. The function ``println`` can be used to "
"print a value followed by a newline."
msgstr ""

#: ../../manual/noteworthy-differences.rst:65
msgid ""
"If ``A`` and ``B`` are arrays, ``A == B`` doesn't return an array of "
"booleans. Use ``A .== B`` instead. Likewise for the other boolean operators,"
" ``<``, ``>``, ``!=``, etc."
msgstr ""

#: ../../manual/noteworthy-differences.rst:68
msgid ""
"The operators ``&``, ``|``, and ``$`` perform the bitwise operations and, "
"or, and xor, respectively, and have precedence similar to Python's bitwise "
"operators (not like C). They can operate on scalars or elementwise across "
"arrays and can be used to combine logical arrays, but note the difference in"
" order of operations—parentheses may be required (e.g., to select elements "
"of ``A`` equal to 1 or 2 use ``(A .== 1) | (A .== 2)``)."
msgstr ""

#: ../../manual/noteworthy-differences.rst:74
msgid ""
"The elements of a collection can be passed as arguments to a function using "
"``...``, as in ``xs=[1,2]; f(xs...)``."
msgstr ""

#: ../../manual/noteworthy-differences.rst:76
msgid ""
"Julia's ``svd`` returns singular values as a vector instead of as a full "
"diagonal matrix."
msgstr ""

#: ../../manual/noteworthy-differences.rst:78
msgid ""
"In Julia, ``...`` is not used to continue lines of code. Instead, incomplete"
" expressions automatically continue onto the next line."
msgstr ""

#: ../../manual/noteworthy-differences.rst:80
msgid ""
"The variable ``ans`` is set to the value of the last expression issued in an"
" interactive session, but not set when Julia code is run in other ways."
msgstr ""

#: ../../manual/noteworthy-differences.rst:83
msgid ""
"The closest analog to Julia's ``types`` are Matlab's ``classes``. Matlab's "
"``structs`` behave somewhere between Julia's ``types`` and ``Dicts``; in "
"particular, if you need to be able to add fields to a ``struct`` on-the-fly,"
" use a ``Dict`` rather than a ``type``."
msgstr ""

#: ../../manual/noteworthy-differences.rst:91
msgid "Noteworthy differences from R"
msgstr ""

#: ../../manual/noteworthy-differences.rst:93
msgid ""
"One of Julia's goals is to provide an effective language for data analysis "
"and statistical programming. For users coming to Julia from R, these are "
"some noteworthy differences:"
msgstr ""

#: ../../manual/noteworthy-differences.rst:95
msgid ""
"Julia uses ``=`` for assignment. Julia does not provide any operator like "
"``<-`` or ``<<-``."
msgstr ""

#: ../../manual/noteworthy-differences.rst:96
msgid ""
"Julia constructs vectors using brackets. Julia's ``[1, 2, 3]`` is the "
"equivalent of R's ``c(1, 2, 3)``."
msgstr ""

#: ../../manual/noteworthy-differences.rst:97
msgid ""
"Julia's matrix operations are more like traditional mathematical notation "
"than R's. If ``A`` and ``B`` are matrices, then ``A * B`` defines a matrix "
"multiplication in Julia equivalent to R's ``A %*% B``. In R, this same "
"notation would perform an elementwise Hadamard product. To get the "
"elementwise multiplication operation, you need to write ``A .* B`` in Julia."
msgstr ""

#: ../../manual/noteworthy-differences.rst:98
msgid ""
"Julia performs matrix transposition using the ``'`` operator. Julia's ``A'``"
" is therefore equivalent to R's ``t(A)``."
msgstr ""

#: ../../manual/noteworthy-differences.rst:99
msgid ""
"Julia does not require parentheses when writing ``if`` statements or ``for``"
" loops: use ``for i in [1, 2, 3]`` instead of ``for (i in c(1, 2, 3))`` and "
"``if i == 1`` instead of ``if (i == 1)``."
msgstr ""

#: ../../manual/noteworthy-differences.rst:100
msgid ""
"Julia does not treat the numbers ``0`` and ``1`` as Booleans. You cannot "
"write ``if (1)`` in Julia, because ``if`` statements accept only booleans. "
"Instead, you can write ``if true``."
msgstr ""

#: ../../manual/noteworthy-differences.rst:101
msgid ""
"Julia does not provide ``nrow`` and ``ncol``. Instead, use ``size(M, 1)`` "
"for ``nrow(M)`` and ``size(M, 2)`` for ``ncol(M)``."
msgstr ""

#: ../../manual/noteworthy-differences.rst:102
msgid ""
"Julia's SVD is not thinned by default, unlike R. To get results like R's, "
"you will often want to call ``svd(X, true)`` on a matrix ``X``."
msgstr ""

#: ../../manual/noteworthy-differences.rst:103
msgid ""
"Julia is careful to distinguish scalars, vectors and matrices. In R, ``1`` "
"and ``c(1)`` are the same. In Julia, they can not be used interchangeably. "
"One potentially confusing result of this is that ``x' * y`` for vectors "
"``x`` and ``y`` is a 1-element vector, not a scalar. To get a scalar, use "
"``dot(x, y)``."
msgstr ""

#: ../../manual/noteworthy-differences.rst:104
msgid "Julia's ``diag()`` and ``diagm()`` are not like R's."
msgstr ""

#: ../../manual/noteworthy-differences.rst:105
msgid ""
"Julia cannot assign to the results of function calls on the left-hand of an "
"assignment operation: you cannot write ``diag(M) = ones(n)``."
msgstr ""

#: ../../manual/noteworthy-differences.rst:106
msgid ""
"Julia discourages populating the main namespace with functions. Most "
"statistical functionality for Julia is found in `packages "
"<http://pkg.julialang.org/>`_ like the DataFrames and Distributions "
"packages:"
msgstr ""

#: ../../manual/noteworthy-differences.rst:110
msgid ""
"Distributions functions are found in the `Distributions package "
"<https://github.com/JuliaStats/Distributions.jl>`_."
msgstr ""

#: ../../manual/noteworthy-differences.rst:111
msgid ""
"The `DataFrames package <https://github.com/JuliaStats/DataFrames.jl>`_ "
"provides data frames."
msgstr ""

#: ../../manual/noteworthy-differences.rst:112
msgid ""
"Generalized linear models are provided by the `GLM package "
"<https://github.com/JuliaStats/GLM.jl>`_."
msgstr ""

#: ../../manual/noteworthy-differences.rst:114
msgid ""
"Julia provides tuples and real hash tables, but not R's lists. When "
"returning multiple items, you should typically use a tuple: instead of "
"``list(a = 1, b = 2)``, use ``(1, 2)``."
msgstr ""

#: ../../manual/noteworthy-differences.rst:115
msgid ""
"Julia encourages all users to write their own types. Julia's types are much "
"easier to use than S3 or S4 objects in R. Julia's multiple dispatch system "
"means that ``table(x::TypeA)`` and ``table(x::TypeB)`` act like R's "
"``table.TypeA(x)`` and ``table.TypeB(x)``."
msgstr ""

#: ../../manual/noteworthy-differences.rst:116
msgid ""
"In Julia, values are passed and assigned by reference. If a function "
"modifies an array, the changes will be visible in the caller. This is very "
"different from R and allows new functions to operate on large data "
"structures much more efficiently."
msgstr ""

#: ../../manual/noteworthy-differences.rst:117
msgid ""
"Concatenation of vectors and matrices is done using ``hcat`` and ``vcat``, "
"not ``c``, ``rbind`` and ``cbind``."
msgstr ""

#: ../../manual/noteworthy-differences.rst:118
msgid ""
"A Julia range object like ``a:b`` is not shorthand for a vector like in R, "
"but is a specialized type of object that is used for iteration without high "
"memory overhead. To convert a range into a vector, you need to wrap the "
"range with brackets ``[a:b]``."
msgstr ""

#: ../../manual/noteworthy-differences.rst:119
msgid ""
"``max``, ``min`` are the equivalent of ``pmax`` and ``pmin`` in R, but both "
"arguments need to have the same dimensions.  While ``maximum``, ``minimum`` "
"replace ``max`` and ``min`` in R, there are important differences."
msgstr ""

#: ../../manual/noteworthy-differences.rst:120
msgid ""
"The functions ``sum``, ``prod``, ``maximum``, ``minimum`` are different from"
" their counterparts in R. They all accept one or two arguments. The first "
"argument is an iterable collection such as an array.  If there is a second "
"argument, then this argument indicates the dimensions, over which the "
"operation is carried out.  For instance, let ``A=[[1 2],[3 4]]`` in Julia "
"and ``B=rbind(c(1,2),c(3,4))`` be the same matrix in R.  Then ``sum(A)`` "
"gives the same result as ``sum(B)``, but ``sum(A,1)`` is a row vector "
"containing the sum over each column and ``sum(A,2)`` is a column vector "
"containing the sum over each row.  This contrasts to the behavior of R, "
"where ``sum(B,1)=11`` and ``sum(B,2)=12``.  If the second argument is a "
"vector, then it specifies all the dimensions over which the sum is "
"performed, e.g., ``sum(A,[1,2])=10``.  It should be noted that there is no "
"error checking regarding the second argument."
msgstr ""

#: ../../manual/noteworthy-differences.rst:121
msgid ""
"Julia has several functions that can mutate their arguments. For example, it"
" has ``sort(v)`` and ``sort!(v)``."
msgstr ""

#: ../../manual/noteworthy-differences.rst:122
msgid "``colMeans()`` and ``rowMeans()``, ``size(m, 1)`` and ``size(m, 2)``"
msgstr ""

#: ../../manual/noteworthy-differences.rst:123
msgid ""
"In R, performance requires vectorization. In Julia, almost the opposite is "
"true: the best performing code is often achieved by using devectorized "
"loops."
msgstr ""

#: ../../manual/noteworthy-differences.rst:124
msgid ""
"Unlike R, there is no delayed evaluation in Julia. For most users, this "
"means that there are very few unquoted expressions or column names."
msgstr ""

#: ../../manual/noteworthy-differences.rst:125
msgid "Julia does not support the ``NULL`` type."
msgstr ""

#: ../../manual/noteworthy-differences.rst:126
msgid "There is no equivalent of R's ``assign`` or ``get`` in Julia."
msgstr ""

#: ../../manual/noteworthy-differences.rst:129
msgid "Noteworthy differences from Python"
msgstr ""

#: ../../manual/noteworthy-differences.rst:131
msgid "Indexing of arrays, strings, etc. in Julia is 1-based not 0-based."
msgstr ""

#: ../../manual/noteworthy-differences.rst:132
msgid ""
"The last element of a list or array is indexed with ``end`` in Julia, not -1"
" as in Python."
msgstr ""

#: ../../manual/noteworthy-differences.rst:134
msgid ""
"Comprehensions in Julia do not (yet) have the optional if clause found in "
"Python."
msgstr ""

#: ../../manual/noteworthy-differences.rst:136
msgid ""
"For, if, while, etc. blocks in Julia are terminated by ``end``; indentation "
"is not significant."
msgstr ""

#: ../../manual/noteworthy-differences.rst:138
msgid ""
"Julia has no line continuation syntax: if, at the end of a line, the input "
"so far is a complete expression, it is considered done; otherwise the input "
"continues. One way to force an expression to continue is to wrap it in "
"parentheses."
msgstr ""

#: ../../manual/noteworthy-differences.rst:142
msgid ""
"Julia arrays are column-major (Fortran ordered) whereas `numpy` arrays are "
"row-major (C-ordered) by default. To get optimal performance when looping "
"over arrays, the order of the loops should be reversed in Julia relative to "
"`numpy` (see relevant section of :ref:`man-performance-tips`)."
msgstr ""

#: ../../manual/packages.rst:5
msgid "Packages"
msgstr ""

#: ../../manual/packages.rst:7
msgid ""
"Julia has a built-in package manager for installing add-on functionality "
"written in Julia. It can also install external libraries using your "
"operating system's standard system for doing so, or by compiling from "
"source. The list of registered Julia packages can be found at "
"`<http://pkg.julialang.org>`_. All package manager commands are found in the"
" ``Pkg`` module, included in Julia's Base install."
msgstr ""

#: ../../manual/packages.rst:13
msgid "Package Status"
msgstr ""

#: ../../manual/packages.rst:15
msgid ""
"The ``Pkg.status()`` function prints out a summary of the state of packages "
"you have installed. Initially, you'll have no packages installed::"
msgstr ""

#: ../../manual/packages.rst:23
msgid ""
"Your package directory is automatically initialized the first time you run a"
" ``Pkg`` command that expects it to exist – which includes ``Pkg.status()``."
" Here's an example non-trivial set of required and additional packages::"
msgstr ""

#: ../../manual/packages.rst:34
msgid ""
"These packages are all on registered versions, managed by ``Pkg``. Packages "
"can be in more complicated states, indicated by annotations to the right of "
"the installed package version; we will explain these states and annotations "
"as we encounter them. For programmatic usage, ``Pkg.installed()`` returns a "
"dictionary, mapping installed package names to the version of that package "
"which is installed::"
msgstr ""

#: ../../manual/packages.rst:46
msgid "Adding and Removing Packages"
msgstr ""

#: ../../manual/packages.rst:48
msgid ""
"Julia's package manager is a little unusual in that it is declarative rather"
" than imperative. This means that you tell it what you want and it figures "
"out what versions to install (or remove) to satisfy those requirements "
"optimally – and minimally. So rather than installing a package, you just add"
" it to the list of requirements and then \"resolve\" what needs to be "
"installed. In particular, this means that if some package had been installed"
" because it was needed by a previous version of something you wanted, and a "
"newer version doesn't have that requirement anymore, updating will actually "
"remove that package."
msgstr ""

#: ../../manual/packages.rst:53
msgid ""
"Your package requirements are in the file ``~/.julia/v0.3/REQUIRE``. You can"
" edit this file by hand and then call ``Pkg.resolve()`` to install, upgrade "
"or remove packages to optimally satisfy the requirements, or you can do "
"``Pkg.edit()``, which will open ``REQUIRE`` in your editor (configured via "
"the ``EDITOR`` or ``VISUAL`` environment variables), and then automatically "
"call ``Pkg.resolve()`` afterwards if necessary. If you only want to add or "
"remove the requirement for a single package, you can also use the non-"
"interactive ``Pkg.add`` and ``Pkg.rm`` commands, which add or remove a "
"single requirement to ``REQUIRE`` and then call ``Pkg.resolve()``."
msgstr ""

#: ../../manual/packages.rst:57
msgid ""
"You can add a package to the list of requirements with the ``Pkg.add`` "
"function, and the package and all the packages that it depends on will be "
"installed::"
msgstr ""

#: ../../manual/packages.rst:78
msgid ""
"What this is doing is first adding ``Distributions`` to your "
"``~/.julia/v0.3/REQUIRE`` file::"
msgstr ""

#: ../../manual/packages.rst:83
msgid ""
"It then runs ``Pkg.resolve()`` using these new requirements, which leads to "
"the conclusion that the ``Distributions`` package should be installed since "
"it is required but not installed. As stated before, you can accomplish the "
"same thing by editing your ``~/.julia/v0.3/REQUIRE`` file by hand and then "
"running ``Pkg.resolve()`` yourself::"
msgstr ""

#: ../../manual/packages.rst:100
msgid ""
"This is functionally equivalent to calling ``Pkg.add(\"UTF16\")``, except "
"that ``Pkg.add`` doesn't change ``REQUIRE`` until *after* installation has "
"completed, so if there are problems, ``REQUIRE`` will be left as it was "
"before calling ``Pkg.add``. The format of the ``REQUIRE`` file is described "
"in `Requirements Specification`_; it allows, among other things, requiring "
"specific ranges of versions of packages."
msgstr ""

#: ../../manual/packages.rst:104
msgid ""
"When you decide that you don't want to have a package around any more, you "
"can use ``Pkg.rm`` to remove the requirement for it from the ``REQUIRE`` "
"file::"
msgstr ""

#: ../../manual/packages.rst:123
msgid ""
"Once again, this is equivalent to editing the ``REQUIRE`` file to remove the"
" line with each package name on it then running ``Pkg.resolve()`` to update "
"the set of installed packages to match. While ``Pkg.add`` and ``Pkg.rm`` are"
" convenient for adding and removing requirements for a single package, when "
"you want to add or remove multiple packages, you can call ``Pkg.edit()`` to "
"manually change the contents of ``REQUIRE`` and then update your packages "
"accordingly. ``Pkg.edit()`` does not roll back the contents of ``REQUIRE`` "
"if ``Pkg.resolve()`` fails – rather, you have to run ``Pkg.edit()`` again to"
" fix the files contents yourself."
msgstr ""

#: ../../manual/packages.rst:127
msgid ""
"Because the package manager uses git internally to manage the package git "
"repositories, users may run into protocol issues (if behind a firewall, for "
"example), when running ``Pkg.add``. The following command can be run from "
"the command line to tell git to use 'https' instead of the 'git' protocol "
"when cloning repositories::"
msgstr ""

#: ../../manual/packages.rst:132
msgid "Installing Unregistered Packages"
msgstr ""

#: ../../manual/packages.rst:134
msgid ""
"Julia packages are simply git repositories, clonable via any of the "
"`protocols <https://www.kernel.org/pub/software/scm/git/docs/git-"
"clone.html#URLS>`_ that git supports, and containing Julia code that follows"
" certain layout conventions. Official Julia packages are registered in the "
"`METADATA.jl <https://github.com/JuliaLang/METADATA.jl>`_ repository, "
"available at a well-known location [1]_. The ``Pkg.add`` and ``Pkg.rm`` "
"commands in the previous section interact with registered packages, but the "
"package manager can install and work with unregistered packages too. To "
"install an unregistered package, use ``Pkg.clone(url)``, where ``url`` is a "
"git URL from which the package can be cloned::"
msgstr ""

#: ../../manual/packages.rst:148
msgid ""
"By convention, Julia repository names end with ``.jl`` (the additional "
"``.git`` indicates a \"bare\" git repository), which keeps them from "
"colliding with repositories for other languages, and also makes Julia "
"packages easy to find in search engines. When packages are installed in your"
" ``.julia/v0.3`` directory, however, the extension is redundant so we leave "
"it off."
msgstr ""

#: ../../manual/packages.rst:151
msgid ""
"If unregistered packages contain a ``REQUIRE`` file at the top of their "
"source tree, that file will be used to determine which registered packages "
"the unregistered package depends on, and they will automatically be "
"installed. Unregistered packages participate in the same version resolution "
"logic as registered packages, so installed package versions will be adjusted"
" as necessary to satisfy the requirements of both registered and "
"unregistered packages."
msgstr ""

#: ../../manual/packages.rst:154
msgid ""
"The official set of packages is at https://github.com/JuliaLang/METADATA.jl,"
" but individuals and organizations can easily use a different metadata "
"repository. This allows control which packages are available for automatic "
"installation. One can allow only audited and approved package versions, and "
"make private packages or forks available."
msgstr ""

#: ../../manual/packages.rst:157
msgid "Updating Packages"
msgstr ""

#: ../../manual/packages.rst:159
msgid ""
"When package developers publish new registered versions of packages that "
"you're using, you will, of course, want the new shiny versions. To get the "
"latest and greatest versions of all your packages, just do "
"``Pkg.update()``::"
msgstr ""

#: ../../manual/packages.rst:168
msgid ""
"The first step of updating packages is to pull new changes to "
"``~/.julia/v0.3/METADATA`` and see if any new registered package versions "
"have been published. After this, ``Pkg.update()`` attempts to update "
"packages that are checked out on a branch and not dirty (i.e. no changes "
"have been made to files tracked by git) by pulling changes from the "
"package's upstream repository. Upstream changes will only be applied if no "
"merging or rebasing is necessary – i.e. if the branch can be `\"fast-"
"forwarded\" <http://git-scm.com/book/en/Git-Branching-Basic-Branching-and-"
"Merging>`_. If the branch cannot be fast-forwarded, it is assumed that "
"you're working on it and will update the repository yourself."
msgstr ""

#: ../../manual/packages.rst:173
msgid ""
"Finally, the update process recomputes an optimal set of package versions to"
" have installed to satisfy your top-level requirements and the requirements "
"of \"fixed\" packages. A package is considered fixed if it is one of the "
"following:"
msgstr ""

#: ../../manual/packages.rst:176
msgid ""
"**Unregistered:** the package is not in ``METADATA`` – you installed it with"
" ``Pkg.clone``."
msgstr ""

#: ../../manual/packages.rst:177
msgid "**Checked out:** the package repo is on a development branch."
msgstr ""

#: ../../manual/packages.rst:178
msgid "**Dirty:** changes have been made to files in the repo."
msgstr ""

#: ../../manual/packages.rst:180
msgid ""
"If any of these are the case, the package manager cannot freely change the "
"installed version of the package, so its requirements must be satisfied by "
"whatever other package versions it picks. The combination of top-level "
"requirements in ``~/.julia/v0.3/REQUIRE`` and the requirement of fixed "
"packages are used to determine what should be installed."
msgstr ""

#: ../../manual/packages.rst:184
msgid "Checkout, Pin and Free"
msgstr ""

#: ../../manual/packages.rst:186
msgid ""
"You may want to use the ``master`` version of a package rather than one of "
"its registered versions. There might be fixes or functionality on master "
"that you need that aren't yet published in any registered versions, or you "
"may be a developer of the package and need to make changes on ``master`` or "
"some other development branch. In such cases, you can do "
"``Pkg.checkout(pkg)`` to checkout the ``master`` branch of ``pkg`` or "
"``Pkg.checkout(pkg,branch)`` to checkout some other branch::"
msgstr ""

#: ../../manual/packages.rst:214
msgid ""
"Immediately after installing ``Distributions`` with ``Pkg.add`` it is on the"
" current most recent registered version – ``0.2.9`` at the time of writing "
"this. Then after running ``Pkg.checkout(\"Distributions\")``, you can see "
"from the output of ``Pkg.status()`` that ``Distributions`` is on an "
"unregistered version greater than ``0.2.9``, indicated by the \"pseudo-"
"version\" number ``0.2.9+``."
msgstr ""

#: ../../manual/packages.rst:217
msgid ""
"When you checkout an unregistered version of a package, the copy of the "
"``REQUIRE`` file in the package repo takes precedence over any requirements "
"registered in ``METADATA``, so it is important that developers keep this "
"file accurate and up-to-date, reflecting the actual requirements of the "
"current version of the package. If the ``REQUIRE`` file in the package repo "
"is incorrect or missing, dependencies may be removed when the package is "
"checked out. This file is also used to populate newly published versions of "
"the package if you use the API that ``Pkg`` provides for this (described "
"below)."
msgstr ""

#: ../../manual/packages.rst:221
msgid ""
"When you decide that you no longer want to have a package checked out on a "
"branch, you can \"free\" it back to the control of the package manager with "
"``Pkg.free(pkg)``::"
msgstr ""

#: ../../manual/packages.rst:234
msgid ""
"After this, since the package is on a registered version and not on a "
"branch, its version will be updated as new registered versions of the "
"package are published."
msgstr ""

#: ../../manual/packages.rst:236
msgid ""
"If you want to pin a package at a specific version so that calling "
"``Pkg.update()`` won't change the version the package is on, you can use the"
" ``Pkg.pin`` function::"
msgstr ""

#: ../../manual/packages.rst:248
msgid ""
"After this, the ``Stats`` package will remain pinned at version ``0.2.7`` – "
"or more specifically, at commit ``47c198b1``, but since versions are "
"permanently associated a given git hash, this is the same thing. ``Pkg.pin``"
" works by creating a throw-away branch for the commit you want to pin the "
"package at and then checking that branch out. By default, it pins a package "
"at the current commit, but you can choose a different version by passing a "
"second argument::"
msgstr ""

#: ../../manual/packages.rst:263
msgid ""
"Now the ``Stats`` package is pinned at commit ``1fd0983b``, which "
"corresponds to version ``0.2.5``. When you decide to \"unpin\" a package and"
" let the package manager update it again, you can use ``Pkg.free`` like you "
"would to move off of any branch::"
msgstr ""

#: ../../manual/packages.rst:277
msgid ""
"After this, the ``Stats`` package is managed by the package manager again, "
"and future calls to ``Pkg.update()`` will upgrade it to newer versions when "
"they are published. The throw-away ``pinned.1fd0983b.tmp`` branch remains in"
" your local ``Stats`` repo, but since git branches are extremely "
"lightweight, this doesn't really matter; if you feel like cleaning them up, "
"you can go into the repo and delete those branches."
msgstr ""

#: ../../manual/packages.rst:281
msgid ""
"Packages that aren't on branches will also be marked as dirty if you make "
"changes in the repo, but that's a less common thing to do."
msgstr ""

#: ../../manual/packages.rst:285
msgid "Package Development"
msgstr ""

#: ../../manual/packages.rst:287
msgid ""
"Julia's package manager is designed so that when you have a package "
"installed, you are already in a position to look at its source code and full"
" development history. You are also able to make changes to packages, commit "
"them using git, and easily contribute fixes and enhancements upstream. "
"Similarly, the system is designed so that if you want to create a new "
"package, the simplest way to do so is within the infrastructure provided by "
"the package manager."
msgstr ""

#: ../../manual/packages.rst:292
msgid "Initial Setup"
msgstr ""

#: ../../manual/packages.rst:294
msgid ""
"Since packages are git repositories, before doing any package development "
"you should setup the following standard global git configuration settings::"
msgstr ""

#: ../../manual/packages.rst:299
msgid ""
"where ``FULL NAME`` is your actual full name (spaces are allowed between the"
" double quotes) and ``EMAIL`` is your actual email address. Although it "
"isn't necessary to use `GitHub <https://github.com/>`_ to create or publish "
"Julia packages, most Julia packages as of writing this are hosted on GitHub "
"and the package manager knows how to format origin URLs correctly and "
"otherwise work with the service smoothly. We recommend that you create a "
"`free account <https://github.com/join>`_ on GitHub and then do::"
msgstr ""

#: ../../manual/packages.rst:305
msgid ""
"where ``USERNAME`` is your actual GitHub user name. Once you do this, the "
"package manager knows your GitHub user name and can configure things "
"accordingly. You should also `upload <https://github.com/settings/ssh>`_ "
"your public SSH key to GitHub and set up an `SSH agent "
"<http://linux.die.net/man/1/ssh-agent>`_ on your development machine so that"
" you can push changes with minimal hassle. In the future, we will make this "
"system extensible and support other common git hosting options like "
"`BitBucket <https://bitbucket.org>`_ and allow developers to choose their "
"favorite."
msgstr ""

#: ../../manual/packages.rst:311
msgid "Generating a New Package"
msgstr ""

#: ../../manual/packages.rst:313
msgid ""
"Suppose you want to create a new Julia package called ``FooBar``. To get "
"started, do ``Pkg.generate(pkg,license)`` where ``pkg`` is the new package "
"name and ``license`` is the name of a license that the package generator "
"knows about::"
msgstr ""

#: ../../manual/packages.rst:326
msgid ""
"This creates the directory ``~/.julia/v0.3/FooBar``, initializes it as a git"
" repository, generates a bunch of files that all packages should have, and "
"commits them to the repository::"
msgstr ""

#: ../../manual/packages.rst:350
msgid ""
"At the moment, the package manager knows about the MIT \"Expat\" License, "
"indicated by ``\"MIT\"``, the Simplified BSD License, indicated by "
"``\"BSD\"``, and version 2.0 of the Apache Software License, indicated by "
"``\"ASL\"``. If you want to use a different license, you can ask us to add "
"it to the package generator, or just pick one of these three and then modify"
" the ``~/.julia/v0.3/PACKAGE/LICENSE.md`` file after it has been generated."
msgstr ""

#: ../../manual/packages.rst:353
msgid ""
"If you created a GitHub account and configured git to know about it, "
"``Pkg.generate`` will set an appropriate origin URL for you. It will also "
"automatically generate a ``.travis.yml`` file for using the `Travis <https"
"://travis-ci.org>`_ automated testing service. You will have to enable "
"testing on the Travis website for your package repository, but once you've "
"done that, it will already have working tests. Of course, all the default "
"testing does is verify that ``using FooBar`` in Julia works."
msgstr ""

#: ../../manual/packages.rst:359
msgid "Making Your Package Available"
msgstr ""

#: ../../manual/packages.rst:361
msgid ""
"Once you've made some commits and you're happy with how ``FooBar`` is "
"working, you may want to get some other people to try it out. First you'll "
"need to create the remote repository and push your code to it; we don't yet "
"automatically do this for you, but we will in the future and it's not too "
"hard to figure out [3]_. Once you've done this, letting people try out your "
"code is as simple as sending them the URL of the published repo – in this "
"case::"
msgstr ""

#: ../../manual/packages.rst:368
msgid ""
"For your package, it will be your GitHub user name and the name of your "
"package, but you get the idea. People you send this URL to can use "
"``Pkg.clone`` to install the package and try it out::"
msgstr ""

#: ../../manual/packages.rst:374
msgid ""
"Installing and using GitHub's `\"hub\" tool "
"<https://github.com/github/hub>`_ is highly recommended. It allows you to do"
" things like run ``hub create`` in the package repo and have it "
"automatically created via GitHub's API."
msgstr ""

#: ../../manual/packages.rst:377
msgid "Publishing Your Package"
msgstr ""

#: ../../manual/packages.rst:379
msgid ""
"Once you've decided that ``FooBar`` is ready to be registered as an official"
" package, you can add it to your local copy of ``METADATA`` using "
"``Pkg.register``::"
msgstr ""

#: ../../manual/packages.rst:385
msgid "This creates a commit in the ``~/.julia/v0.3/METADATA`` repo::"
msgstr ""

#: ../../manual/packages.rst:403
msgid ""
"This commit is only locally visible, however.  In order to make it visible "
"to the world, you need to merge your local ``METADATA`` upstream into the "
"official repo.  The ``Pkg.publish()`` command will fork the ``METADATA`` "
"repository on GitHub, push your changes to your fork, and open a pull "
"request::"
msgstr ""

#: ../../manual/packages.rst:418
msgid ""
"For various reasons ``Pkg.publish()`` sometimes does not succeed. In those "
"cases, you may make a pull request on GitHub, which is `not difficult "
"<https://help.github.com/articles/creating-a-pull-request>`_."
msgstr ""

#: ../../manual/packages.rst:421
msgid ""
"Once the package URL for ``FooBar`` is registered in the official "
"``METADATA`` repo, people know where to clone the package from, but there "
"still aren't any registered versions available. This means that "
"``Pkg.add(\"FooBar\")`` won't work yet since it only installs official "
"versions. ``Pkg.clone(\"FooBar\")`` without having to specify a URL for it. "
"Moreover, when they run ``Pkg.update()``, they will get the latest version "
"of ``FooBar`` that you've pushed to the repo. This is a good way to have "
"people test out your packages as you work on them, before they're ready for "
"an official release."
msgstr ""

#: ../../manual/packages.rst:428
msgid "Tagging Package Versions"
msgstr ""

#: ../../manual/packages.rst:430
msgid ""
"Once you are ready to make an official version your package, you can tag and"
" register it with the ``Pkg.tag`` command::"
msgstr ""

#: ../../manual/packages.rst:436
msgid "This tags ``v0.0.1`` in the ``FooBar`` repo::"
msgstr ""

#: ../../manual/packages.rst:441
msgid ""
"It also creates a new version entry in your local ``METADATA`` repo for "
"``FooBar``::"
msgstr ""

#: ../../manual/packages.rst:458
msgid ""
"If there is a ``REQUIRE`` file in your package repo, it will be copied into "
"the appropriate spot in ``METADATA`` when you tag a version. Package "
"developers should make sure that the ``REQUIRE`` file in their package "
"correctly reflects the requirements of their package, which will "
"automatically flow into the official metadata if you're using ``Pkg.tag``. "
"See the `Requirements Specification <#man-package-requirements>`_ for the "
"full format of ``REQUIRE``."
msgstr ""

#: ../../manual/packages.rst:462
msgid ""
"The ``Pkg.tag`` command takes an optional second argument that is either an "
"explicit version number object like ``v\"0.0.1\"`` or one of the symbols "
"``:patch``, ``:minor`` or ``:major``. These increment the patch, minor or "
"major version number of your package intelligently."
msgstr ""

#: ../../manual/packages.rst:465
msgid ""
"As with ``Pkg.register``, these changes to ``METADATA`` aren't available to "
"anyone else until they've been included upstream.  Again, use the "
"``Pkg.publish()`` command, which first makes sure that individual package "
"repos have been tagged, pushes them if they haven't already been, and then "
"opens a pull request to ``METADATA``::"
msgstr ""

#: ../../manual/packages.rst:482
msgid "Fixing Package Requirements"
msgstr ""

#: ../../manual/packages.rst:484
msgid ""
"If you need to fix the registered requirements of an already-published "
"package version, you can do so just by editing the metadata for that "
"version, which will still have the same commit hash – the hash associated "
"with a version is permanent::"
msgstr ""

#: ../../manual/packages.rst:490
msgid ""
"Since the commit hash stays the same, the contents of the ``REQUIRE`` file "
"that will be checked out in the repo will **not** match the requirements in "
"``METADATA`` after such a change; this is unavoidable. When you fix the "
"requirements in ``METADATA`` for a previous version of a package, however, "
"you should also fix the ``REQUIRE`` file in the current version of the "
"package."
msgstr ""

#: ../../manual/packages.rst:497
msgid "Requirements Specification"
msgstr ""

#: ../../manual/packages.rst:499
msgid ""
"The ``~/.julia/v0.3/REQUIRE`` file, the ``REQUIRE`` file inside packages, "
"and the ``METADATA`` package ``requires`` files use a simple line-based "
"format to express the ranges of package versions which need to be installed."
"  Package ``REQUIRE`` and ``METADATA requires`` files should also include "
"the range of versions of ``julia`` the package is expected to work with."
msgstr ""

#: ../../manual/packages.rst:501
msgid "Here's how these files are parsed and interpreted."
msgstr ""

#: ../../manual/packages.rst:503
msgid "Everything after a ``#`` mark is stripped from each line as a comment."
msgstr ""

#: ../../manual/packages.rst:504
msgid "If nothing but whitespace is left, the line is ignored."
msgstr ""

#: ../../manual/packages.rst:505
msgid ""
"If there are non-whitespace characters remaining, the line is a requirement "
"and the is split on whitespace into words."
msgstr ""

#: ../../manual/packages.rst:507
msgid ""
"The simplest possible requirement is just the name of a package name on a "
"line by itself::"
msgstr ""

#: ../../manual/packages.rst:511
msgid ""
"This requirement is satisfied by any version of the ``Distributions`` "
"package. The package name can be followed by zero or more version numbers in"
" ascending order, indicating acceptable intervals of versions of that "
"package. One version opens an interval, while the next closes it, and the "
"next opens a new interval, and so on; if an odd number of version numbers "
"are given, then arbitrarily large versions will satisfy; if an even number "
"of version numbers are given, the last one is an upper limit on acceptable "
"version numbers. For example, the line::"
msgstr ""

#: ../../manual/packages.rst:520
msgid ""
"is satisfied by any version of ``Distributions`` greater than or equal to "
"``0.1.0``. Suffixing a version with `-` allows any pre-release versions as "
"well. For example::"
msgstr ""

#: ../../manual/packages.rst:525
msgid ""
"is satisfied by pre-release versions such as ``0.1-dev`` or ``0.1-rc1``, or "
"by any version greater than or equal to ``0.1.0``."
msgstr ""

#: ../../manual/packages.rst:527
msgid "This requirement entry::"
msgstr ""

#: ../../manual/packages.rst:531
msgid ""
"is satisfied by versions from ``0.1.0`` up to, but not including ``0.2.5``. "
"If you want to indicate that any ``0.1.x`` version will do, you will want to"
" write::"
msgstr ""

#: ../../manual/packages.rst:536
msgid ""
"If you want to start accepting versions after ``0.2.7``, you can write::"
msgstr ""

#: ../../manual/packages.rst:540
msgid ""
"If a requirement line has leading words that begin with ``@``, it is a "
"system-dependent requirement. If your system matches these system "
"conditionals, the requirement is included, if not, the requirement is "
"ignored. For example::"
msgstr ""

#: ../../manual/packages.rst:546
msgid ""
"will require the ``Homebrew`` package only on systems where the operating "
"system is OS X. The system conditions that are currently supported are::"
msgstr ""

#: ../../manual/packages.rst:554
msgid ""
"The ``@unix`` condition is satisfied on all UNIX systems, including OS X, "
"Linux and FreeBSD. Negated system conditionals are also supported by adding "
"a ``!`` after the leading ``@``. Examples::"
msgstr ""

#: ../../manual/packages.rst:561
msgid ""
"The first condition applies to any system but Windows and the second "
"condition applies to any UNIX system besides OS X."
msgstr ""

#: ../../manual/packages.rst:563
msgid ""
"Runtime checks for the current version of Julia can be made using the built-"
"in ``VERSION`` variable, which is of type ``VersionNumber``. Such code is "
"occasionally necessary to keep track of new or deprecated functionality "
"between various releases of Julia. Examples of runtime checks::"
msgstr ""

#: ../../manual/packages.rst:576
msgid ""
"See the section on :ref:`version number literals <man-version-number-"
"literals>` for a more complete description."
msgstr ""

#: ../../manual/parallel-computing.rst:5
msgid "Parallel Computing"
msgstr ""

#: ../../manual/parallel-computing.rst:7
msgid ""
"Most modern computers possess more than one CPU, and several computers can "
"be combined together in a cluster. Harnessing the power of these multiple "
"CPUs allows many computations to be completed more quickly. There are two "
"major factors that influence performance: the speed of the CPUs themselves, "
"and the speed of their access to memory. In a cluster, it's fairly obvious "
"that a given CPU will have fastest access to the RAM within the same "
"computer (node). Perhaps more surprisingly, similar issues are relevant on a"
" typical multicore laptop, due to differences in the speed of main memory "
"and the `cache <http://www.akkadia.org/drepper/cpumemory.pdf>`_. "
"Consequently, a good multiprocessing environment should allow control over "
"the \"ownership\" of a chunk of memory by a particular CPU. Julia provides a"
" multiprocessing environment based on message passing to allow programs to "
"run on multiple processes in separate memory domains at once."
msgstr ""

#: ../../manual/parallel-computing.rst:22
msgid ""
"Julia's implementation of message passing is different from other "
"environments such as MPI [#mpi2rma]_. Communication in Julia is generally "
"\"one-sided\", meaning that the programmer needs to explicitly manage only "
"one process in a two-process operation. Furthermore, these operations "
"typically do not look like \"message send\" and \"message receive\" but "
"rather resemble higher-level operations like calls to user functions."
msgstr ""

#: ../../manual/parallel-computing.rst:30
msgid ""
"Parallel programming in Julia is built on two primitives: *remote "
"references* and *remote calls*. A remote reference is an object that can be "
"used from any process to refer to an object stored on a particular process. "
"A remote call is a request by one process to call a certain function on "
"certain arguments on another (possibly the same) process. A remote call "
"returns a remote reference to its result. Remote calls return immediately; "
"the process that made the call proceeds to its next operation while the "
"remote call happens somewhere else. You can wait for a remote call to finish"
" by calling ``wait`` on its remote reference, and you can obtain the full "
"value of the result using ``fetch``. You can store a value to a remote "
"reference using ``put!``."
msgstr ""

#: ../../manual/parallel-computing.rst:42
msgid ""
"Let's try this out. Starting with ``julia -p n`` provides ``n`` worker "
"processes on the local machine. Generally it makes sense for ``n`` to equal "
"the number of CPU cores on the machine."
msgstr ""

#: ../../manual/parallel-computing.rst:66
msgid ""
"The first argument to ``remotecall`` is the index of the process that will "
"do the work. Most parallel programming in Julia does not reference specific "
"processes or the number of processes available, but ``remotecall`` is "
"considered a low-level interface providing finer control. The second "
"argument to ``remotecall`` is the function to call, and the remaining "
"arguments will be passed to this function. As you can see, in the first line"
" we asked process 2 to construct a 2-by-2 random matrix, and in the second "
"line we asked it to add 1 to it. The result of both calculations is "
"available in the two remote references, ``r`` and ``s``. The ``@spawnat`` "
"macro evaluates the expression in the second argument on the process "
"specified by the first argument."
msgstr ""

#: ../../manual/parallel-computing.rst:79
msgid ""
"Occasionally you might want a remotely-computed value immediately. This "
"typically happens when you read from a remote object to obtain data needed "
"by the next local operation. The function ``remotecall_fetch`` exists for "
"this purpose. It is equivalent to ``fetch(remotecall(...))`` but is more "
"efficient."
msgstr ""

#: ../../manual/parallel-computing.rst:90
msgid ""
"Remember that ``getindex(r,1,1)`` is :ref:`equivalent <man-array-indexing>` "
"to ``r[1,1]``, so this call fetches the first element of the remote "
"reference ``r``."
msgstr ""

#: ../../manual/parallel-computing.rst:94
msgid ""
"The syntax of ``remotecall`` is not especially convenient. The macro "
"``@spawn`` makes things easier. It operates on an expression rather than a "
"function, and picks where to do the operation for you::"
msgstr ""

#: ../../manual/parallel-computing.rst:108
msgid ""
"Note that we used ``1 .+ fetch(r)`` instead of ``1 .+ r``. This is because "
"we do not know where the code will run, so in general a ``fetch`` might be "
"required to move ``r`` to the process doing the addition. In this case, "
"``@spawn`` is smart enough to perform the computation on the process that "
"owns ``r``, so the ``fetch`` will be a no-op."
msgstr ""

#: ../../manual/parallel-computing.rst:114
msgid ""
"(It is worth noting that ``@spawn`` is not built-in but defined in Julia as "
"a :ref:`macro <man-macros>`. It is possible to define your own such "
"constructs.)"
msgstr ""

#: ../../manual/parallel-computing.rst:120
msgid "Code Availability and Loading Packages"
msgstr ""

#: ../../manual/parallel-computing.rst:122
msgid ""
"Your code must be available on any process that runs it. For example, type "
"the following into the julia prompt::"
msgstr ""

#: ../../manual/parallel-computing.rst:142
msgid "Process 1 knew about the function ``rand2``, but process 2 did not."
msgstr ""

#: ../../manual/parallel-computing.rst:144
msgid ""
"Most commonly you'll be loading code from files or packages, and you have a "
"considerable amount of flexibility in controlling which processes load code."
"  Consider a file, ``\"DummyModule.jl\"``, containing the following code::"
msgstr ""

#: ../../manual/parallel-computing.rst:163
msgid ""
"Starting julia with ``julia -p 2``, you can use this to verify the "
"following:"
msgstr ""

#: ../../manual/parallel-computing.rst:165
msgid ""
"``include(\"DummyModule.jl\")`` loads the file on just a single process "
"(whichever one executes the statement)."
msgstr ""

#: ../../manual/parallel-computing.rst:166
msgid ""
"``using DummyModule`` causes the module to be loaded on all processes; "
"however, the module is brought into scope only on the one executing the "
"statement."
msgstr ""

#: ../../manual/parallel-computing.rst:167
msgid "As long as ``DummyModule`` is loaded on process 2, commands like ::"
msgstr ""

#: ../../manual/parallel-computing.rst:172
msgid ""
"allow you to store an object of type ``MyType`` on process 2 even if "
"``DummyModule`` is not in scope on process 2."
msgstr ""

#: ../../manual/parallel-computing.rst:174
msgid ""
"You can force a command to run on all processes using the ``@everywhere`` "
"macro. Consequently, an easy way to load *and* use a package on all "
"processes is::"
msgstr ""

#: ../../manual/parallel-computing.rst:179
msgid ""
"``@everywhere`` can also be used to directly define a function on all "
"processes::"
msgstr ""

#: ../../manual/parallel-computing.rst:186
msgid ""
"A file can also be preloaded on multiple processes at startup, and a driver "
"script can be used to drive the computation::"
msgstr ""

#: ../../manual/parallel-computing.rst:190
msgid ""
"Each process has an associated identifier. The process providing the "
"interactive julia prompt always has an id equal to 1, as would the julia "
"process running the driver script in the example above. The processes used "
"by default for parallel operations are referred to as ``workers``. When "
"there is only one process, process 1 is considered a worker. Otherwise, "
"workers are considered to be all processes other than process 1."
msgstr ""

#: ../../manual/parallel-computing.rst:197
msgid ""
"The base Julia installation has in-built support for two types of clusters:"
msgstr ""

#: ../../manual/parallel-computing.rst:199
msgid "A local cluster specified with the ``-p`` option as shown above."
msgstr ""

#: ../../manual/parallel-computing.rst:201
msgid ""
"A cluster spanning machines using the ``--machinefile`` option. This uses a "
"passwordless ``ssh`` login to start julia worker processes (from the same "
"path as the current host) on the specified machines."
msgstr ""

#: ../../manual/parallel-computing.rst:205
msgid ""
"Functions ``addprocs``, ``rmprocs``, ``workers``, and others are available "
"as a programmatic means of adding, removing and querying the processes in a "
"cluster."
msgstr ""

#: ../../manual/parallel-computing.rst:208
msgid ""
"Other types of clusters can be supported by writing your own custom "
"``ClusterManager``, as described below in the :ref:`man-clustermanagers` "
"section."
msgstr ""

#: ../../manual/parallel-computing.rst:213
msgid "Data Movement"
msgstr ""

#: ../../manual/parallel-computing.rst:215
msgid ""
"Sending messages and moving data constitute most of the overhead in a "
"parallel program. Reducing the number of messages and the amount of data "
"sent is critical to achieving performance and scalability. To this end, it "
"is important to understand the data movement performed by Julia's various "
"parallel programming constructs."
msgstr ""

#: ../../manual/parallel-computing.rst:221
msgid ""
"``fetch`` can be considered an explicit data movement operation, since it "
"directly asks that an object be moved to the local machine. ``@spawn`` (and "
"a few related constructs) also moves data, but this is not as obvious, hence"
" it can be called an implicit data movement operation. Consider these two "
"approaches to constructing and squaring a random matrix::"
msgstr ""

#: ../../manual/parallel-computing.rst:239
msgid ""
"The difference seems trivial, but in fact is quite significant due to the "
"behavior of ``@spawn``. In the first method, a random matrix is constructed "
"locally, then sent to another process where it is squared. In the second "
"method, a random matrix is both constructed and squared on another process. "
"Therefore the second method sends much less data than the first."
msgstr ""

#: ../../manual/parallel-computing.rst:246
msgid ""
"In this toy example, the two methods are easy to distinguish and choose "
"from. However, in a real program designing data movement might require more "
"thought and likely some measurement. For example, if the first process needs"
" matrix ``A`` then the first method might be better. Or, if computing ``A`` "
"is expensive and only the current process has it, then moving it to another "
"process might be unavoidable. Or, if the current process has very little to "
"do between the ``@spawn`` and ``fetch(Bref)`` then it might be better to "
"eliminate the parallelism altogether. Or imagine ``rand(1000,1000)`` is "
"replaced with a more expensive operation. Then it might make sense to add "
"another ``@spawn`` statement just for this step."
msgstr ""

#: ../../manual/parallel-computing.rst:259
msgid "Parallel Map and Loops"
msgstr ""

#: ../../manual/parallel-computing.rst:261
msgid ""
"Fortunately, many useful parallel computations do not require data movement."
" A common example is a Monte Carlo simulation, where multiple processes can "
"handle independent simulation trials simultaneously. We can use ``@spawn`` "
"to flip coins on two processes. First, write the following function in "
"``count_heads.jl``::"
msgstr ""

#: ../../manual/parallel-computing.rst:275
msgid ""
"The function ``count_heads`` simply adds together ``n`` random bits. Here is"
" how we can perform some trials on two machines, and add together the "
"results::"
msgstr ""

#: ../../manual/parallel-computing.rst:285
msgid ""
"This example demonstrates a powerful and often-used parallel programming "
"pattern. Many iterations run independently over several processes, and then "
"their results are combined using some function. The combination process is "
"called a *reduction*, since it is generally tensor-rank-reducing: a vector "
"of numbers is reduced to a single number, or a matrix is reduced to a single"
" row or column, etc. In code, this typically looks like the pattern ``x = "
"f(x,v[i])``, where ``x`` is the accumulator, ``f`` is the reduction "
"function, and the ``v[i]`` are the elements being reduced. It is desirable "
"for ``f`` to be associative, so that it does not matter what order the "
"operations are performed in."
msgstr ""

#: ../../manual/parallel-computing.rst:297
msgid ""
"Notice that our use of this pattern with ``count_heads`` can be generalized."
" We used two explicit ``@spawn`` statements, which limits the parallelism to"
" two processes. To run on any number of processes, we can use a *parallel "
"for loop*, which can be written in Julia like this::"
msgstr ""

#: ../../manual/parallel-computing.rst:307
msgid ""
"This construct implements the pattern of assigning iterations to multiple "
"processes, and combining them with a specified reduction (in this case "
"``(+)``). The result of each iteration is taken as the value of the last "
"expression inside the loop. The whole parallel loop expression itself "
"evaluates to the final answer."
msgstr ""

#: ../../manual/parallel-computing.rst:313
msgid ""
"Note that although parallel for loops look like serial for loops, their "
"behavior is dramatically different. In particular, the iterations do not "
"happen in a specified order, and writes to variables or arrays will not be "
"globally visible since iterations run on different processes. Any variables "
"used inside the parallel loop will be copied and broadcast to each process."
msgstr ""

#: ../../manual/parallel-computing.rst:320
msgid "For example, the following code will not work as intended::"
msgstr ""

#: ../../manual/parallel-computing.rst:327
msgid ""
"However, this code will not initialize all of ``a``, since each process will"
" have a separate copy of it. Parallel for loops like these must be avoided. "
"Fortunately, distributed arrays can be used to get around this limitation, "
"as we will see in the next section."
msgstr ""

#: ../../manual/parallel-computing.rst:332
msgid ""
"Using \"outside\" variables in parallel loops is perfectly reasonable if the"
" variables are read-only::"
msgstr ""

#: ../../manual/parallel-computing.rst:340
msgid ""
"Here each iteration applies ``f`` to a randomly-chosen sample from a vector "
"``a`` shared by all processes."
msgstr ""

#: ../../manual/parallel-computing.rst:343
msgid ""
"As you could see, the reduction operator can be omitted if it is not needed."
" In that case, the loop executes asynchronously, i.e. it spawns independent "
"tasks on all available workers and returns an array of ``RemoteRef`` "
"immediately without waiting for completion. The caller can wait for the "
"``RemoteRef`` completions at a later point by calling ``fetch`` on them, or "
"wait for completion at the end of the loop by prefixing it with ``@sync``, "
"like ``@sync @parallel for``."
msgstr ""

#: ../../manual/parallel-computing.rst:351
msgid ""
"In some cases no reduction operator is needed, and we merely wish to apply a"
" function to all integers in some range (or, more generally, to all elements"
" in some collection). This is another useful operation called *parallel "
"map*, implemented in Julia as the ``pmap`` function. For example, we could "
"compute the singular values of several large random matrices in parallel as "
"follows::"
msgstr ""

#: ../../manual/parallel-computing.rst:361
msgid ""
"Julia's ``pmap`` is designed for the case where each function call does a "
"large amount of work. In contrast, ``@parallel for`` can handle situations "
"where each iteration is tiny, perhaps merely summing two numbers. Only "
"worker processes are used by both ``pmap`` and ``@parallel for`` for the "
"parallel computation. In case of ``@parallel for``, the final reduction is "
"done on the calling process."
msgstr ""

#: ../../manual/parallel-computing.rst:371
msgid "Synchronization With Remote References"
msgstr ""

#: ../../manual/parallel-computing.rst:374
msgid "Scheduling"
msgstr ""

#: ../../manual/parallel-computing.rst:376
msgid ""
"Julia's parallel programming platform uses :ref:`man-tasks` to switch among "
"multiple computations. Whenever code performs a communication operation like"
" ``fetch`` or ``wait``, the current task is suspended and a scheduler picks "
"another task to run. A task is restarted when the event it is waiting for "
"completes."
msgstr ""

#: ../../manual/parallel-computing.rst:383
msgid ""
"For many problems, it is not necessary to think about tasks directly. "
"However, they can be used to wait for multiple events at the same time, "
"which provides for *dynamic scheduling*. In dynamic scheduling, a program "
"decides what to compute or where to compute it based on when other jobs "
"finish. This is needed for unpredictable or unbalanced workloads, where we "
"want to assign more work to processes only when they finish their current "
"tasks."
msgstr ""

#: ../../manual/parallel-computing.rst:391
msgid ""
"As an example, consider computing the singular values of matrices of "
"different sizes::"
msgstr ""

#: ../../manual/parallel-computing.rst:397
msgid ""
"If one process handles both 800x800 matrices and another handles both "
"600x600 matrices, we will not get as much scalability as we could. The "
"solution is to make a local task to \"feed\" work to each process when it "
"completes its current task. This can be seen in the implementation of "
"``pmap``::"
msgstr ""

#: ../../manual/parallel-computing.rst:429
msgid ""
"``@async`` is similar to ``@spawn``, but only runs tasks on the local "
"process. We use it to create a \"feeder\" task for each process. Each task "
"picks the next index that needs to be computed, then waits for its process "
"to finish, then repeats until we run out of indexes. Note that the feeder "
"tasks do not begin to execute until the main task reaches the end of the "
"``@sync`` block, at which point it surrenders control and waits for all the "
"local tasks to complete before returning from the function. The feeder tasks"
" are able to share state via ``nextidx()`` because they all run on the same "
"process. No locking is required, since the threads are scheduled "
"cooperatively and not preemptively. This means context switches only occur "
"at well-defined points: in this case, when ``remotecall_fetch`` is called."
msgstr ""

#: ../../manual/parallel-computing.rst:443
msgid "Distributed Arrays"
msgstr ""

#: ../../manual/parallel-computing.rst:445
msgid ""
"Large computations are often organized around large arrays of data. In these"
" cases, a particularly natural way to obtain parallelism is to distribute "
"arrays among several processes. This combines the memory resources of "
"multiple machines, allowing use of arrays too large to fit on one machine. "
"Each process operates on the part of the array it owns, providing a ready "
"answer to the question of how a program should be divided among machines."
msgstr ""

#: ../../manual/parallel-computing.rst:453
msgid ""
"Julia distributed arrays are implemented by the ``DArray`` type. A "
"``DArray`` has an element type and dimensions just like an ``Array``. A "
"``DArray`` can also use arbitrary array-like types to represent the local "
"chunks that store actual data. The data in a ``DArray`` is distributed by "
"dividing the index space into some number of blocks in each dimension."
msgstr ""

#: ../../manual/parallel-computing.rst:459
msgid ""
"Common kinds of arrays can be constructed with functions beginning with "
"``d``::"
msgstr ""

#: ../../manual/parallel-computing.rst:468
msgid ""
"In the last case, each element will be initialized to the specified value "
"``x``. These functions automatically pick a distribution for you. For more "
"control, you can specify which processes to use, and how the data should be "
"distributed::"
msgstr ""

#: ../../manual/parallel-computing.rst:475
msgid ""
"The second argument specifies that the array should be created on the first "
"four workers. When dividing data among a large number of processes, one "
"often sees diminishing returns in performance. Placing ``DArray``\\ s on a "
"subset of processes allows multiple ``DArray`` computations to happen at "
"once, with a higher ratio of work to communication on each process."
msgstr ""

#: ../../manual/parallel-computing.rst:482
msgid ""
"The third argument specifies a distribution; the nth element of this array "
"specifies how many pieces dimension n should be divided into. In this "
"example the first dimension will not be divided, and the second dimension "
"will be divided into 4 pieces. Therefore each local chunk will be of size "
"``(100,25)``. Note that the product of the distribution array must equal the"
" number of processes."
msgstr ""

#: ../../manual/parallel-computing.rst:489
msgid ""
"``distribute(a::Array)`` converts a local array to a distributed array."
msgstr ""

#: ../../manual/parallel-computing.rst:491
msgid ""
"``localpart(a::DArray)`` obtains the locally-stored portion of a ``DArray``."
msgstr ""

#: ../../manual/parallel-computing.rst:494
msgid ""
"``localindexes(a::DArray)`` gives a tuple of the index ranges owned by the "
"local process."
msgstr ""

#: ../../manual/parallel-computing.rst:497
msgid ""
"``convert(Array, a::DArray)`` brings all the data to the local process."
msgstr ""

#: ../../manual/parallel-computing.rst:499
msgid ""
"Indexing a ``DArray`` (square brackets) with ranges of indexes always "
"creates a ``SubArray``, not copying any data."
msgstr ""

#: ../../manual/parallel-computing.rst:504
msgid "Constructing Distributed Arrays"
msgstr ""

#: ../../manual/parallel-computing.rst:506
msgid ""
"The primitive ``DArray`` constructor has the following somewhat elaborate "
"signature::"
msgstr ""

#: ../../manual/parallel-computing.rst:510
msgid ""
"``init`` is a function that accepts a tuple of index ranges. This function "
"should allocate a local chunk of the distributed array and initialize it for"
" the specified indices. ``dims`` is the overall size of the distributed "
"array. ``procs`` optionally specifies a vector of process IDs to use. "
"``dist`` is an integer vector specifying how many chunks the distributed "
"array should be divided into in each dimension."
msgstr ""

#: ../../manual/parallel-computing.rst:517
msgid ""
"The last two arguments are optional, and defaults will be used if they are "
"omitted."
msgstr ""

#: ../../manual/parallel-computing.rst:520
msgid ""
"As an example, here is how to turn the local array constructor ``fill`` into"
" a distributed array constructor::"
msgstr ""

#: ../../manual/parallel-computing.rst:525
msgid ""
"In this case the ``init`` function only needs to call ``fill`` with the "
"dimensions of the local piece it is creating."
msgstr ""

#: ../../manual/parallel-computing.rst:529
msgid "Distributed Array Operations"
msgstr ""

#: ../../manual/parallel-computing.rst:531
msgid ""
"At this time, distributed arrays do not have much functionality. Their major"
" utility is allowing communication to be done via array indexing, which is "
"convenient for many problems. As an example, consider implementing the "
"\"life\" cellular automaton, where each cell in a grid is updated according "
"to its neighboring cells. To compute a chunk of the result of one iteration,"
" each process needs the immediate neighbor cells of its local chunk. The "
"following code accomplishes this::"
msgstr ""

#: ../../manual/parallel-computing.rst:561
msgid ""
"As you can see, we use a series of indexing expressions to fetch data into a"
" local array ``old``. Note that the ``do`` block syntax is convenient for "
"passing ``init`` functions to the ``DArray`` constructor. Next, the serial "
"function ``life_rule`` is called to apply the update rules to the data, "
"yielding the needed ``DArray`` chunk. Nothing about ``life_rule`` is "
"``DArray``\\ -specific, but we list it here for completeness::"
msgstr ""

#: ../../manual/parallel-computing.rst:585
msgid "Shared Arrays (Experimental)"
msgstr ""

#: ../../manual/parallel-computing.rst:587
msgid ""
"Shared Arrays use system shared memory to map the same array across many "
"processes.  While there are some similarities to a ``DArray``, the behavior "
"of a ``SharedArray`` is quite different. In a ``DArray``, each process has "
"local access to just a chunk of the data, and no two processes share the "
"same chunk; in contrast, in a ``SharedArray`` each \"participating\" process"
" has access to the entire array.  A ``SharedArray`` is a good choice when "
"you want to have a large amount of data jointly accessible to two or more "
"processes on the same machine."
msgstr ""

#: ../../manual/parallel-computing.rst:596
msgid ""
"``SharedArray`` indexing (assignment and accessing values) works just as "
"with regular arrays, and is efficient because the underlying memory is "
"available to the local process.  Therefore, most algorithms work naturally "
"on ``SharedArrays``, albeit in single-process mode.  In cases where an "
"algorithm insists on an ``Array`` input, the underlying array can be "
"retrieved from a ``SharedArray`` by calling ``sdata(S)``. For other "
"``AbstractArray`` types, ``sdata`` just returns the object itself, so it's "
"safe to use ``sdata`` on any Array-type object."
msgstr ""

#: ../../manual/parallel-computing.rst:605
msgid "The constructor for a shared array is of the form::"
msgstr ""

#: ../../manual/parallel-computing.rst:609
msgid ""
"which creates a shared array of a bitstype ``T`` and size ``dims`` across "
"the processes specified by ``pids``.  Unlike distributed arrays, a shared "
"array is accessible only from those participating workers specified by the "
"``pids`` named argument (and the creating process too, if it is on the same "
"host)."
msgstr ""

#: ../../manual/parallel-computing.rst:615
msgid ""
"If an ``init`` function, of signature ``initfn(S::SharedArray)``, is "
"specified, it is called on all the participating workers.  You can arrange "
"it so that each worker runs the ``init`` function on a distinct portion of "
"the array, thereby parallelizing initialization."
msgstr ""

#: ../../manual/parallel-computing.rst:620
msgid "Here's a brief example::"
msgstr ""

#: ../../manual/parallel-computing.rst:643
msgid ""
"``localindexes`` provides disjoint one-dimensional ranges of indexes, and is"
" sometimes convenient for splitting up tasks among processes. You can, of "
"course, divide the work any way you wish::"
msgstr ""

#: ../../manual/parallel-computing.rst:653
msgid ""
"Since all processes have access to the underlying data, you do have to be "
"careful not to set up conflicts.  For example::"
msgstr ""

#: ../../manual/parallel-computing.rst:664
msgid ""
"would result in undefined behavior: because each process fills the *entire* "
"array with its own ``pid``, whichever process is the last to execute (for "
"any particular element of ``S``) will have its ``pid`` retained."
msgstr ""

#: ../../manual/parallel-computing.rst:673
msgid "ClusterManagers"
msgstr ""

#: ../../manual/parallel-computing.rst:675
msgid ""
"Julia worker processes can also be spawned on arbitrary machines, enabling "
"Julia's natural parallelism to function quite transparently in a cluster "
"environment. The ``ClusterManager`` interface provides a way to specify a "
"means to launch and manage worker processes."
msgstr ""

#: ../../manual/parallel-computing.rst:680
msgid "Thus, a custom cluster manager would need to:"
msgstr ""

#: ../../manual/parallel-computing.rst:682
msgid "be a subtype of the abstract ``ClusterManager``"
msgstr ""

#: ../../manual/parallel-computing.rst:683
msgid "implement ``launch``, a method responsible for launching new workers"
msgstr ""

#: ../../manual/parallel-computing.rst:684
msgid ""
"implement ``manage``, which is called at various events during a worker's "
"lifetime"
msgstr ""

#: ../../manual/parallel-computing.rst:686
msgid "Julia provides two in-built cluster managers:"
msgstr ""

#: ../../manual/parallel-computing.rst:688
msgid ""
"``LocalManager`` used when ``addprocs()`` or ``addprocs(::Integer)`` are "
"called"
msgstr ""

#: ../../manual/parallel-computing.rst:689
msgid ""
"``SSHManager`` used when ``addprocs(::Array)`` is called with a list of "
"hostnames"
msgstr ""

#: ../../manual/parallel-computing.rst:691
msgid ""
"``addprocs(manager::FooManager)`` requires ``FooManager`` to implement::"
msgstr ""

#: ../../manual/parallel-computing.rst:702
msgid ""
"As an example let us see how the ``LocalManager``, the manager responsible "
"for starting workers on the same host, is implemented::"
msgstr ""

#: ../../manual/parallel-computing.rst:717
msgid "The ``launch`` method takes the following arguments:"
msgstr ""

#: ../../manual/parallel-computing.rst:719
msgid ""
"``manager::ClusterManager`` - the cluster manager ``addprocs`` is called "
"with"
msgstr ""

#: ../../manual/parallel-computing.rst:720
msgid "``params::Dict`` - all the keyword arguments passed to ``addprocs``"
msgstr ""

#: ../../manual/parallel-computing.rst:721
msgid ""
"``launched::Array`` - the array to append one or more ``WorkerConfig`` "
"objects to"
msgstr ""

#: ../../manual/parallel-computing.rst:722
msgid ""
"``c::Condition`` - the condition variable to be notified as and when workers"
" are launched"
msgstr ""

#: ../../manual/parallel-computing.rst:724
msgid ""
"The ``launch`` method is called asynchronously in a separate task. The "
"termination of this task signals that all requested workers have been "
"launched. Hence the ``launch`` function MUST exit as soon as all the "
"requested workers have been launched. The julia worker MUST be launched with"
" a ``--worker`` argument. Optionally ``--bind-to bind_addr[:port]`` may also"
" be specified to enable other workers to connect to it at the specified "
"``bind_addr`` and ``port``. Useful for multi-homed hosts."
msgstr ""

#: ../../manual/parallel-computing.rst:731
msgid ""
"For every worker launched, the ``launch`` method must add a "
"``WorkerConfig``object with appropriate fields initialized to ``launched``::"
msgstr ""

#: ../../manual/parallel-computing.rst:753
msgid "type WorkerConfig"
msgstr ""

#: ../../manual/parallel-computing.rst:735
msgid ""
"# Common fields relevant to all cluster managers io::Nullable{IO} "
"host::Nullable{AbstractString} port::Nullable{Integer}"
msgstr ""

#: ../../manual/parallel-computing.rst:740
msgid ""
"# Used when launching additional workers at a host "
"count::Nullable{Union(Int, Symbol)} exeflags::Nullable{Cmd}"
msgstr ""

#: ../../manual/parallel-computing.rst:744
msgid ""
"# External cluster managers can use this to store information at a per-"
"worker level # Can be a dict if multiple fields need to be stored. "
"userdata::Nullable{Any}"
msgstr ""

#: ../../manual/parallel-computing.rst:748
msgid ""
"# SSHManager / SSH tunnel connections to workers tunnel::Nullable{Bool} "
"bind_addr::Nullable{AbstractString} sshflags::Nullable{Cmd} "
"max_parallel::Nullable{Integer}"
msgstr ""

#: ../../manual/parallel-computing.rst:757
msgid ""
"Most of the fields in ``WorkerConfig`` are used by the inbuilt managers. "
"Custom cluster managers would typically specify only ``io`` or ``host`` / "
"``port``:"
msgstr ""

#: ../../manual/parallel-computing.rst:760
msgid ""
"If ``io`` is specified, it is used to read host/port information. A julia "
"worker prints out its bind address and port at startup. This allows julia "
"workers to listen on any free port available instead of requiring worker "
"ports to be configured manually."
msgstr ""

#: ../../manual/parallel-computing.rst:764
msgid "If ``io`` is not specfied, ``host`` and ``port`` are used to connect."
msgstr ""

#: ../../manual/parallel-computing.rst:766
msgid ""
"``count`` and ``exeflags`` are relevant for launching additional workers "
"from a worker. For example, a cluster manager may launch a single worker per"
" node, and use that to launch additional workers. ``count`` with an integer "
"value ``n`` will launch a total of ``n`` workers, while a value of ``:auto``"
" will launch as many workers as cores on that machine. ``exeflags`` should "
"be set to the required command line arguments for new workers."
msgstr ""

#: ../../manual/parallel-computing.rst:772
msgid ""
"``tunnel``, ``bind_addr``, ``sshflags`` and ``max_parallel`` are used when a"
" ssh tunnel is required to connect to the workers from the master process."
msgstr ""

#: ../../manual/parallel-computing.rst:775
msgid ""
"``userdata`` is provided for custom cluster managers to store their own "
"worker specific information."
msgstr ""

#: ../../manual/parallel-computing.rst:779
msgid ""
"``manage(manager::FooManager, id::Integer, config::WorkerConfig, "
"op::Symbol)`` is called at different times during the worker's lifetime with"
" different ``op`` values:"
msgstr ""

#: ../../manual/parallel-computing.rst:782
msgid ""
"with ``:register``/``:deregister`` when a worker is added / removed from the"
" Julia worker pool."
msgstr ""

#: ../../manual/parallel-computing.rst:784
msgid ""
"with ``:interrupt`` when ``interrupt(workers)`` is called. The "
"``ClusterManager`` should signal the appropriate worker with an interrupt "
"signal."
msgstr ""

#: ../../manual/parallel-computing.rst:787
msgid "with ``:finalize`` for cleanup purposes."
msgstr ""

#: ../../manual/parallel-computing.rst:790
msgid "Footnotes"
msgstr ""

#: ../../manual/parallel-computing.rst:791
msgid ""
"In this context, MPI refers to the MPI-1 standard. Beginning with MPI-2, the"
" MPI standards committee introduced a new set of communication mechanisms, "
"collectively referred to as Remote Memory Access (RMA). The motivation for "
"adding RMA to the MPI standard was to facilitate one-sided communication "
"patterns. For additional information on the latest MPI standard, see "
"http://www.mpi-forum.org/docs."
msgstr ""

#: ../../manual/performance-tips.rst:5
msgid "Performance Tips"
msgstr ""

#: ../../manual/performance-tips.rst:7
msgid ""
"In the following sections, we briefly go through a few techniques that can "
"help make your Julia code run as fast as possible."
msgstr ""

#: ../../manual/performance-tips.rst:11
msgid "Avoid global variables"
msgstr ""

#: ../../manual/performance-tips.rst:13
msgid ""
"A global variable might have its value, and therefore its type, change at "
"any point. This makes it difficult for the compiler to optimize code using "
"global variables. Variables should be local, or passed as arguments to "
"functions, whenever possible."
msgstr ""

#: ../../manual/performance-tips.rst:18
msgid ""
"Any code that is performance-critical or being benchmarked should be inside "
"a function."
msgstr ""

#: ../../manual/performance-tips.rst:21
msgid ""
"We find that global names are frequently constants, and declaring them as "
"such greatly improves performance::"
msgstr ""

#: ../../manual/performance-tips.rst:26
msgid ""
"Uses of non-constant globals can be optimized by annotating their types at "
"the point of use::"
msgstr ""

#: ../../manual/performance-tips.rst:32
msgid ""
"Writing functions is better style. It leads to more reusable code and "
"clarifies what steps are being done, and what their inputs and outputs are."
msgstr ""

#: ../../manual/performance-tips.rst:37
msgid ""
"Measure performance with ``@time`` and pay attention to memory allocation"
msgstr ""

#: ../../manual/performance-tips.rst:39
msgid ""
"The most useful tool for measuring performance is the ``@time`` macro. The "
"following example illustrates good working style::"
msgstr ""

#: ../../manual/performance-tips.rst:59
msgid ""
"On the first call (``@time f(1)``), ``f`` gets compiled.  (If you've not yet"
" used ``@time`` in this session, it will also compile functions needed for "
"timing.)  You should not take the results of this run seriously. For the "
"second run, note that in addition to reporting the time, it also indicated "
"that a large amount of memory was allocated. This is the single biggest "
"advantage of ``@time`` vs. functions like ``tic`` and ``toc``, which only "
"report time."
msgstr ""

#: ../../manual/performance-tips.rst:67
msgid ""
"Unexpected memory allocation is almost always a sign of some problem with "
"your code, usually a problem with type-stability. Consequently, in addition "
"to the allocation itself, it's very likely that the code generated for your "
"function is far from optimal. Take such indications seriously and follow the"
" advice below."
msgstr ""

#: ../../manual/performance-tips.rst:73
msgid ""
"As a teaser, note that an improved version of this function allocates no "
"memory (except to pass back the result back to the REPL) and has thirty-fold"
" faster execution::"
msgstr ""

#: ../../manual/performance-tips.rst:81
msgid ""
"Below you'll learn how to spot the problem with ``f`` and how to fix it."
msgstr ""

#: ../../manual/performance-tips.rst:83
msgid ""
"In some situations, your function may need to allocate memory as part of its"
" operation, and this can complicate the simple picture above. In such cases,"
" consider using one of the :ref:`tools <man-performance-tools>` below to "
"diagnose problems, or write a version of your function that separates "
"allocation from its algorithmic aspects (see :ref:`man-preallocation`)."
msgstr ""

#: ../../manual/performance-tips.rst:94
msgid "Tools"
msgstr ""

#: ../../manual/performance-tips.rst:96
msgid ""
"Julia and its package ecosystem includes tools that may help you diagnose "
"problems and improve the performance of your code:"
msgstr ""

#: ../../manual/performance-tips.rst:99
msgid ""
":ref:`stdlib-profiling` allows you to measure the performance of your "
"running code and identify lines that serve as bottlenecks.  For complex "
"projects, the `ProfileView <https://github.com/timholy/ProfileView.jl>`_ "
"package can help you visualize your profiling results."
msgstr ""

#: ../../manual/performance-tips.rst:105
msgid ""
"Unexpectedly-large memory allocations---as reported by ``@time``, "
"``@allocated``, or the profiler (through calls to the garbage-collection "
"routines)---hint that there might be issues with your code.  If you don't "
"see another reason for the allocations, suspect a type problem.  You can "
"also start julia with the ``--track-allocation=user`` option and examine the"
" resulting ``*.mem`` files to see information about where those allocations "
"occur.  See :ref:`stdlib-track-allocation`."
msgstr ""

#: ../../manual/performance-tips.rst:114
msgid ""
"The `TypeCheck <https://github.com/astrieanna/TypeCheck.jl>`_ package can "
"help identify certain kinds of type problems. A more laborious but "
"comprehensive tool is ``code_typed``.  Look particularly for variables that "
"have type ``Any`` (in the header) or statements declared as ``Union`` types."
"  Such problems can usually be fixed using the tips below."
msgstr ""

#: ../../manual/performance-tips.rst:121
msgid ""
"The `Lint <https://github.com/tonyhffong/Lint.jl>`_ package can also warn "
"you of certain types of programming errors."
msgstr ""

#: ../../manual/performance-tips.rst:127
msgid "Avoid containers with abstract type parameters"
msgstr ""

#: ../../manual/performance-tips.rst:129
msgid ""
"When working with parameterized types, including arrays, it is best to avoid"
" parameterizing with abstract types where possible."
msgstr ""

#: ../../manual/performance-tips.rst:132
msgid "Consider the following::"
msgstr ""

#: ../../manual/performance-tips.rst:139
msgid ""
"Because ``a`` is a an array of abstract type ``Real``, it must be able to "
"hold any Real value.  Since ``Real`` objects can be of arbitrary size and "
"structure, ``a`` must be represented as an array of pointers to individually"
" allocated ``Real`` objects.  Because ``f`` will always be a ``Float64``, we"
" should instead, use::"
msgstr ""

#: ../../manual/performance-tips.rst:147
msgid ""
"which will create a contiguous block of 64-bit floating-point values that "
"can be manipulated efficiently."
msgstr ""

#: ../../manual/performance-tips.rst:150
msgid "See also the discussion under :ref:`man-parametric-types`."
msgstr ""

#: ../../manual/performance-tips.rst:153
msgid "Type declarations"
msgstr ""

#: ../../manual/performance-tips.rst:155
msgid ""
"In many languages with optional type declarations, adding declarations is "
"the principal way to make code run faster. This is *not* the case in Julia. "
"In Julia, the compiler generally knows the types of all function arguments, "
"local variables, and expressions. However, there are a few specific "
"instances where declarations are helpful."
msgstr ""

#: ../../manual/performance-tips.rst:163
msgid "Declare specific types for fields of composite types"
msgstr ""

#: ../../manual/performance-tips.rst:165
msgid "Given a user-defined type like the following::"
msgstr ""

#: ../../manual/performance-tips.rst:171
msgid ""
"the compiler will not generally know the type of ``foo.field``, since it "
"might be modified at any time to refer to a value of a different type. It "
"will help to declare the most specific type possible, such as "
"``field::Float64`` or ``field::Array{Int64,1}``."
msgstr ""

#: ../../manual/performance-tips.rst:177
msgid "Annotate values taken from untyped locations"
msgstr ""

#: ../../manual/performance-tips.rst:179
msgid ""
"It is often convenient to work with data structures that may contain values "
"of any type, such as the original ``Foo`` type above, or cell arrays (arrays"
" of type ``Array{Any}``). But, if you're using one of these structures and "
"happen to know the type of an element, it helps to share this knowledge with"
" the compiler::"
msgstr ""

#: ../../manual/performance-tips.rst:191
msgid ""
"Here, we happened to know that the first element of ``a`` would be an "
"``Int32``. Making an annotation like this has the added benefit that it will"
" raise a run-time error if the value is not of the expected type, "
"potentially catching certain bugs earlier."
msgstr ""

#: ../../manual/performance-tips.rst:197
msgid "Declare types of keyword arguments"
msgstr ""

#: ../../manual/performance-tips.rst:199
msgid "Keyword arguments can have declared types::"
msgstr ""

#: ../../manual/performance-tips.rst:205
msgid ""
"Functions are specialized on the types of keyword arguments, so these "
"declarations will not affect performance of code inside the function. "
"However, they will reduce the overhead of calls to the function that include"
" keyword arguments."
msgstr ""

#: ../../manual/performance-tips.rst:210
msgid ""
"Functions with keyword arguments have near-zero overhead for call sites that"
" pass only positional arguments."
msgstr ""

#: ../../manual/performance-tips.rst:213
msgid ""
"Passing dynamic lists of keyword arguments, as in ``f(x; keywords...)``, can"
" be slow and should be avoided in performance-sensitive code."
msgstr ""

#: ../../manual/performance-tips.rst:217
msgid "Break functions into multiple definitions"
msgstr ""

#: ../../manual/performance-tips.rst:219
msgid ""
"Writing a function as many small definitions allows the compiler to directly"
" call the most applicable code, or even inline it."
msgstr ""

#: ../../manual/performance-tips.rst:222
msgid ""
"Here is an example of a \"compound function\" that should really be written "
"as multiple definitions::"
msgstr ""

#: ../../manual/performance-tips.rst:235
msgid "This can be written more concisely and efficiently as::"
msgstr ""

#: ../../manual/performance-tips.rst:241
msgid "Write \"type-stable\" functions"
msgstr ""

#: ../../manual/performance-tips.rst:243
msgid ""
"When possible, it helps to ensure that a function always returns a value of "
"the same type. Consider the following definition::"
msgstr ""

#: ../../manual/performance-tips.rst:248
msgid ""
"Although this seems innocent enough, the problem is that ``0`` is an integer"
" (of type ``Int``) and ``x`` might be of any type. Thus, depending on the "
"value of ``x``, this function might return a value of either of two types. "
"This behavior is allowed, and may be desirable in some cases. But it can "
"easily be fixed as follows::"
msgstr ""

#: ../../manual/performance-tips.rst:256
msgid ""
"There is also a ``one`` function, and a more general ``oftype(x,y)`` "
"function, which returns ``y`` converted to the type of ``x``."
msgstr ""

#: ../../manual/performance-tips.rst:260
msgid "Avoid changing the type of a variable"
msgstr ""

#: ../../manual/performance-tips.rst:262
msgid ""
"An analogous \"type-stability\" problem exists for variables used repeatedly"
" within a function::"
msgstr ""

#: ../../manual/performance-tips.rst:273
msgid ""
"Local variable ``x`` starts as an integer, and after one loop iteration "
"becomes a floating-point number (the result of the ``/`` operator). This "
"makes it more difficult for the compiler to optimize the body of the loop. "
"There are several possible fixes:"
msgstr ""

#: ../../manual/performance-tips.rst:278
msgid "Initialize ``x`` with ``x = 1.0``"
msgstr ""

#: ../../manual/performance-tips.rst:279
msgid "Declare the type of ``x``: ``x::Float64 = 1``"
msgstr ""

#: ../../manual/performance-tips.rst:280
msgid "Use an explicit conversion: ``x = one(T)``"
msgstr ""

#: ../../manual/performance-tips.rst:283
msgid "Separate kernel functions"
msgstr ""

#: ../../manual/performance-tips.rst:285
msgid ""
"Many functions follow a pattern of performing some set-up work, and then "
"running many iterations to perform a core computation. Where possible, it is"
" a good idea to put these core computations in separate functions. For "
"example, the following contrived function returns an array of a randomly-"
"chosen type::"
msgstr ""

#: ../../manual/performance-tips.rst:299
msgid "This should be written as::"
msgstr ""

#: ../../manual/performance-tips.rst:313
msgid ""
"Julia's compiler specializes code for argument types at function boundaries,"
" so in the original implementation it does not know the type of ``a`` during"
" the loop (since it is chosen randomly). Therefore the second version is "
"generally faster since the inner loop can be recompiled as part of "
"``fill_twos!`` for different types of ``a``."
msgstr ""

#: ../../manual/performance-tips.rst:319
msgid ""
"The second form is also often better style and can lead to more code reuse."
msgstr ""

#: ../../manual/performance-tips.rst:322
msgid ""
"This pattern is used in several places in the standard library. For example,"
" see ``hvcat_fill`` in `abstractarray.jl "
"<https://github.com/JuliaLang/julia/blob/master/base/abstractarray.jl>`_, or"
" the ``fill!`` function, which we could have used instead of writing our own"
" ``fill_twos!``."
msgstr ""

#: ../../manual/performance-tips.rst:328
msgid ""
"Functions like ``strange_twos`` occur when dealing with data of uncertain "
"type, for example data loaded from an input file that might contain either "
"integers, floats, strings, or something else."
msgstr ""

#: ../../manual/performance-tips.rst:333
msgid "Access arrays in memory order, along columns"
msgstr ""

#: ../../manual/performance-tips.rst:335
msgid ""
"Multidimensional arrays in Julia are stored in column-major order. This "
"means that arrays are stacked one column at a time. This can be verified "
"using the ``vec`` function or the syntax ``[:]`` as shown below (notice that"
" the array is ordered ``[1 3 2 4]``, not ``[1 2 3 4]``):"
msgstr ""

#: ../../manual/performance-tips.rst:354
msgid ""
"This convention for ordering arrays is common in many languages like "
"Fortran, Matlab, and R (to name a few). The alternative to column-major "
"ordering is row-major ordering, which is the convention adopted by C and "
"Python (``numpy``) among other languages. Remembering the ordering of arrays"
" can have significant performance effects when looping over arrays. A rule "
"of thumb to keep in mind is that with column-major arrays, the first index "
"changes most rapidly. Essentially this means that looping will be faster if "
"the inner-most loop index is the first to appear in a slice expression."
msgstr ""

#: ../../manual/performance-tips.rst:364
msgid ""
"Consider the following contrived example. Imagine we wanted to write a "
"function that accepts a ``Vector`` and and returns a square ``Matrix`` with "
"either the rows or the columns filled with copies of the input vector. "
"Assume that it is not important whether rows or columns are filled with "
"these copies (perhaps the rest of the code can be easily adapted "
"accordingly). We could conceivably do this in at least four ways (in "
"addition to the recommended call to the built-in function ``repmat``)::"
msgstr ""

#: ../../manual/performance-tips.rst:409
msgid ""
"Now we will time each of these functions using the same random ``10000`` by "
"``1`` input vector::"
msgstr ""

#: ../../manual/performance-tips.rst:422
msgid ""
"Notice that ``copy_cols`` is much faster than ``copy_rows``. This is "
"expected because ``copy_cols`` respects the column-based memory layout of "
"the ``Matrix`` and fills it one column at a time. Additionally, "
"``copy_col_row`` is much faster than ``copy_row_col`` because it follows our"
" rule of thumb that the first element to appear in a slice expression should"
" be coupled with the inner-most loop."
msgstr ""

#: ../../manual/performance-tips.rst:432
msgid "Pre-allocating outputs"
msgstr ""

#: ../../manual/performance-tips.rst:434
msgid ""
"If your function returns an Array or some other complex type, it may have to"
" allocate memory.  Unfortunately, oftentimes allocation and its converse, "
"garbage collection, are substantial bottlenecks."
msgstr ""

#: ../../manual/performance-tips.rst:439
msgid ""
"Sometimes you can circumvent the need to allocate memory on each function "
"call by pre-allocating the output.  As a trivial example, compare ::"
msgstr ""

#: ../../manual/performance-tips.rst:457
msgid "with ::"
msgstr ""

#: ../../manual/performance-tips.rst:477
msgid "Timing results::"
msgstr ""

#: ../../manual/performance-tips.rst:487
msgid ""
"Pre-allocation has other advantages, for example by allowing the caller to "
"control the \"output\" type from an algorithm.  In the example above, we "
"could have passed a ``SubArray`` rather than an ``Array``, had we so "
"desired."
msgstr ""

#: ../../manual/performance-tips.rst:492
msgid ""
"Taken to its extreme, pre-allocation can make your code uglier, so "
"performance measurements and some judgment may be required."
msgstr ""

#: ../../manual/performance-tips.rst:497
msgid "Avoid string interpolation for I/O"
msgstr ""

#: ../../manual/performance-tips.rst:499
msgid ""
"When writing data to a file (or other I/O device), forming extra "
"intermediate strings is a source of overhead. Instead of::"
msgstr ""

#: ../../manual/performance-tips.rst:504 ../../manual/style-guide.rst:78
#: ../../manual/style-guide.rst:103
msgid "use::"
msgstr ""

#: ../../manual/performance-tips.rst:508
msgid ""
"The first version of the code forms a string, then writes it to the file, "
"while the second version writes values directly to the file. Also notice "
"that in some cases string interpolation can be harder to read. Consider::"
msgstr ""

#: ../../manual/performance-tips.rst:515
msgid "versus::"
msgstr ""

#: ../../manual/performance-tips.rst:521
msgid "Fix deprecation warnings"
msgstr ""

#: ../../manual/performance-tips.rst:523
msgid ""
"A deprecated function internally performs a lookup in order to print a "
"relevant warning only once. This extra lookup can cause a significant "
"slowdown, so all uses of deprecated functions should be modified as "
"suggested by the warnings."
msgstr ""

#: ../../manual/performance-tips.rst:529
msgid "Tweaks"
msgstr ""

#: ../../manual/performance-tips.rst:531
msgid "These are some minor points that might help in tight inner loops."
msgstr ""

#: ../../manual/performance-tips.rst:533
msgid ""
"Avoid unnecessary arrays. For example, instead of ``sum([x,y,z])`` use "
"``x+y+z``."
msgstr ""

#: ../../manual/performance-tips.rst:535
msgid ""
"Use ``abs2(z)`` instead of ``abs(z)^2`` for complex ``z``. In general, try "
"to rewrite code to use ``abs2`` instead of ``abs`` for complex arguments."
msgstr ""

#: ../../manual/performance-tips.rst:537
msgid ""
"Use ``div(x,y)`` for truncating division of integers instead of "
"``trunc(x/y)``, ``fld(x,y)`` instead of ``floor(x/y)``, and ``cld(x,y)`` "
"instead of ``ceil(x/y)``."
msgstr ""

#: ../../manual/performance-tips.rst:542
msgid "Performance Annotations"
msgstr ""

#: ../../manual/performance-tips.rst:544
msgid ""
"Sometimes you can enable better optimization by promising certain program "
"properties."
msgstr ""

#: ../../manual/performance-tips.rst:547
msgid ""
"Use ``@inbounds`` to eliminate array bounds checking within expressions. Be "
"certain before doing this. If the subscripts are ever out of bounds, you may"
" suffer crashes or silent corruption."
msgstr ""

#: ../../manual/performance-tips.rst:550
msgid ""
"Write ``@simd`` in front of ``for`` loops that are amenable to "
"vectorization. **This feature is experimental** and could change or "
"disappear in future versions of Julia."
msgstr ""

#: ../../manual/performance-tips.rst:554
msgid "Here is an example with both forms of markup::"
msgstr ""

#: ../../manual/performance-tips.rst:588
msgid "On a computer with a 2.4GHz Intel Core i5 processor, this produces::"
msgstr ""

#: ../../manual/performance-tips.rst:593
msgid ""
"The range for a ``@simd for`` loop should be a one-dimensional range. A "
"variable used for accumulating, such as ``s`` in the example, is called a "
"*reduction variable*. By using``@simd``, you are asserting several "
"properties of the loop:"
msgstr ""

#: ../../manual/performance-tips.rst:598
msgid ""
"It is safe to execute iterations in arbitrary or overlapping order, with "
"special consideration for reduction variables."
msgstr ""

#: ../../manual/performance-tips.rst:600
msgid ""
"Floating-point operations on reduction variables can be reordered, possibly "
"causing different results than without ``@simd``."
msgstr ""

#: ../../manual/performance-tips.rst:602
msgid "No iteration ever waits on another iteration to make forward progress."
msgstr ""

#: ../../manual/performance-tips.rst:604
msgid ""
"A loop containing ``break``, ``continue``, or ``goto`` will cause a compile-"
"time error."
msgstr ""

#: ../../manual/performance-tips.rst:607
msgid ""
"Using ``@simd`` merely gives the compiler license to vectorize. Whether it "
"actually does so depends on the compiler. To actually benefit from the "
"current implementation, your loop should have the following additional "
"properties:"
msgstr ""

#: ../../manual/performance-tips.rst:612
msgid "The loop must be an innermost loop."
msgstr ""

#: ../../manual/performance-tips.rst:613
msgid ""
"The loop body must be straight-line code. This is why ``@inbounds`` is "
"currently needed for all array accesses. The compiler can sometimes turn "
"short ``&&``, ``||``, and ``?:`` expressions into straight-line code, if it "
"is safe to evaluate all operands unconditionally. Consider using ``ifelse`` "
"instead of ``?:`` in the loop if it is safe to do so."
msgstr ""

#: ../../manual/performance-tips.rst:618
msgid ""
"Accesses must have a stride pattern and cannot be \"gathers\" (random-index "
"reads) or \"scatters\" (random-index writes)."
msgstr ""

#: ../../manual/performance-tips.rst:620
msgid "The stride should be unit stride."
msgstr ""

#: ../../manual/performance-tips.rst:621
msgid ""
"In some simple cases, for example with 2-3 arrays accessed in a loop, the "
"LLVM auto-vectorization may kick in automatically, leading to no further "
"speedup with ``@simd``."
msgstr ""

#: ../../manual/running-external-programs.rst:5
msgid "Running External Programs"
msgstr ""

#: ../../manual/running-external-programs.rst:7
msgid ""
"Julia borrows backtick notation for commands from the shell, Perl, and Ruby."
" However, in Julia, writing"
msgstr ""

#: ../../manual/running-external-programs.rst:15
msgid ""
"differs in several aspects from the behavior in various shells, Perl, or "
"Ruby:"
msgstr ""

#: ../../manual/running-external-programs.rst:18
msgid ""
"Instead of immediately running the command, backticks create a ``Cmd`` "
"object to represent the command. You can use this object to connect the "
"command to others via pipes, run it, and read or write to it."
msgstr ""

#: ../../manual/running-external-programs.rst:22
msgid ""
"When the command is run, Julia does not capture its output unless you "
"specifically arrange for it to. Instead, the output of the command by "
"default goes to ``stdout`` as it would using ``libc``'s ``system`` call."
msgstr ""

#: ../../manual/running-external-programs.rst:26
msgid ""
"The command is never run with a shell. Instead, Julia parses the command "
"syntax directly, appropriately interpolating variables and splitting on "
"words as the shell would, respecting shell quoting syntax. The command is "
"run as ``julia``'s immediate child process, using ``fork`` and ``exec`` "
"calls."
msgstr ""

#: ../../manual/running-external-programs.rst:32
msgid "Here's a simple example of running an external program::"
msgstr ""

#: ../../manual/running-external-programs.rst:37
msgid ""
"The ``hello`` is the output of the ``echo`` command, sent to stdout. The run"
" method itself returns ``nothing``, and throws an ``ErrorException`` if the "
"external command fails to run successfully."
msgstr ""

#: ../../manual/running-external-programs.rst:41
msgid ""
"If you want to read the output of the external command, the ``readall`` "
"method can be used instead::"
msgstr ""

#: ../../manual/running-external-programs.rst:50
msgid ""
"More generally, you can use ``open`` to read from or write to an external "
"command.  For example::"
msgstr ""

#: ../../manual/running-external-programs.rst:62 ../../manual/strings.rst:375
msgid "Interpolation"
msgstr ""

#: ../../manual/running-external-programs.rst:64
msgid ""
"Suppose you want to do something a bit more complicated and use the name of "
"a file in the variable ``file`` as an argument to a command. You can use "
"``$`` for interpolation much as you would in a string literal (see :ref"
":`man-strings`)::"
msgstr ""

#: ../../manual/running-external-programs.rst:75
msgid ""
"A common pitfall when running external programs via a shell is that if a "
"file name contains characters that are special to the shell, they may cause "
"undesirable behavior. Suppose, for example, rather than ``/etc/passwd``, we "
"wanted to sort the contents of the file ``/Volumes/External HD/data.csv``. "
"Let's try it::"
msgstr ""

#: ../../manual/running-external-programs.rst:87
msgid ""
"How did the file name get quoted? Julia knows that ``file`` is meant to be "
"interpolated as a single argument, so it quotes the word for you. Actually, "
"that is not quite accurate: the value of ``file`` is never interpreted by a "
"shell, so there's no need for actual quoting; the quotes are inserted only "
"for presentation to the user. This will even work if you interpolate a value"
" as part of a shell word::"
msgstr ""

#: ../../manual/running-external-programs.rst:106
msgid ""
"As you can see, the space in the ``path`` variable is appropriately escaped."
" But what if you *want* to interpolate multiple words? In that case, just "
"use an array (or any other iterable container)::"
msgstr ""

#: ../../manual/running-external-programs.rst:119
msgid ""
"If you interpolate an array as part of a shell word, Julia emulates the "
"shell's ``{a,b,c}`` argument generation::"
msgstr ""

#: ../../manual/running-external-programs.rst:131
msgid ""
"Moreover, if you interpolate multiple arrays into the same word, the shell's"
" Cartesian product generation behavior is emulated::"
msgstr ""

#: ../../manual/running-external-programs.rst:148
msgid ""
"Since you can interpolate literal arrays, you can use this generative "
"functionality without needing to create temporary array objects first::"
msgstr ""

#: ../../manual/running-external-programs.rst:155
msgid "Quoting"
msgstr ""

#: ../../manual/running-external-programs.rst:157
msgid ""
"Inevitably, one wants to write commands that aren't quite so simple, and it "
"becomes necessary to use quotes. Here's a simple example of a perl one-liner"
" at a shell prompt::"
msgstr ""

#: ../../manual/running-external-programs.rst:167
msgid ""
"The Perl expression needs to be in single quotes for two reasons: so that "
"spaces don't break the expression into multiple shell words, and so that "
"uses of Perl variables like ``$|`` (yes, that's the name of a variable in "
"Perl), don't cause interpolation. In other instances, you may want to use "
"double quotes so that interpolation *does* occur::"
msgstr ""

#: ../../manual/running-external-programs.rst:179
msgid ""
"In general, the Julia backtick syntax is carefully designed so that you can "
"just cut-and-paste shell commands as-is into backticks and they will work: "
"the escaping, quoting, and interpolation behaviors are the same as the "
"shell's. The only difference is that the interpolation is integrated and "
"aware of Julia's notion of what is a single string value, and what is a "
"container for multiple values. Let's try the above two examples in Julia::"
msgstr ""

#: ../../manual/running-external-programs.rst:205
msgid ""
"The results are identical, and Julia's interpolation behavior mimics the "
"shell's with some improvements due to the fact that Julia supports first-"
"class iterable objects while most shells use strings split on spaces for "
"this, which introduces ambiguities. When trying to port shell commands to "
"Julia, try cut and pasting first. Since Julia shows commands to you before "
"running them, you can easily and safely just examine its interpretation "
"without doing any damage."
msgstr ""

#: ../../manual/running-external-programs.rst:214
msgid "Pipelines"
msgstr ""

#: ../../manual/running-external-programs.rst:216
msgid ""
"Shell metacharacters, such as ``|``, ``&``, and ``>``, are not special "
"inside of Julia's backticks: unlike in the shell, inside of Julia's "
"backticks, a pipe is always just a pipe::"
msgstr ""

#: ../../manual/running-external-programs.rst:223
msgid ""
"This expression invokes the ``echo`` command with three words as arguments: "
"\"hello\", \"\\|\", and \"sort\". The result is that a single line is "
"printed: \"hello \\| sort\". Inside of backticks, a \"\\|\" is just a "
"literal pipe character. How, then, does one construct a pipeline? Instead of"
" using \"\\|\" inside of backticks, one uses Julia's ``|>`` operator between"
" ``Cmd`` objects::"
msgstr ""

#: ../../manual/running-external-programs.rst:233
msgid ""
"This pipes the output of the ``echo`` command to the ``sort`` command. Of "
"course, this isn't terribly interesting since there's only one line to sort,"
" but we can certainly do much more interesting things::"
msgstr ""

#: ../../manual/running-external-programs.rst:244
msgid ""
"This prints the highest five user IDs on a UNIX system. The ``cut``, "
"``sort`` and ``tail`` commands are all spawned as immediate children of the "
"current ``julia`` process, with no intervening shell process. Julia itself "
"does the work to setup pipes and connect file descriptors that is normally "
"done by the shell. Since Julia does this itself, it retains better control "
"and can do some things that shells cannot. Note that ``|>`` only redirects "
"``stdout``. To redirect ``stderr``, use ``.>``"
msgstr ""

#: ../../manual/running-external-programs.rst:253
msgid "Julia can run multiple commands in parallel::"
msgstr ""

#: ../../manual/running-external-programs.rst:259
msgid ""
"The order of the output here is non-deterministic because the two ``echo`` "
"processes are started nearly simultaneously, and race to make the first "
"write to the ``stdout`` descriptor they share with each other and the "
"``julia`` parent process. Julia lets you pipe the output from both of these "
"processes to another program::"
msgstr ""

#: ../../manual/running-external-programs.rst:269
msgid ""
"In terms of UNIX plumbing, what's happening here is that a single UNIX pipe "
"object is created and written to by both ``echo`` processes, and the other "
"end of the pipe is read from by the ``sort`` command."
msgstr ""

#: ../../manual/running-external-programs.rst:273
msgid ""
"The combination of a high-level programming language, a first-class command "
"abstraction, and automatic setup of pipes between processes is a powerful "
"one. To give some sense of the complex pipelines that can be created easily,"
" here are some more sophisticated examples, with apologies for the excessive"
" use of Perl one-liners::"
msgstr ""

#: ../../manual/running-external-programs.rst:293
msgid ""
"This is a classic example of a single producer feeding two concurrent "
"consumers: one ``perl`` process generates lines with the numbers 0 through 9"
" on them, while two parallel processes consume that output, one prefixing "
"lines with the letter \"A\", the other with the letter \"B\". Which consumer"
" gets the first line is non-deterministic, but once that race has been won, "
"the lines are consumed alternately by one process and then the other. "
"(Setting ``$|=1`` in Perl causes each print statement to flush the "
"``stdout`` handle, which is necessary for this example to work. Otherwise "
"all the output is buffered and printed to the pipe at once, to be read by "
"just one consumer process.)"
msgstr ""

#: ../../manual/running-external-programs.rst:304
msgid "Here is an even more complex multi-stage producer-consumer example::"
msgstr ""

#: ../../manual/running-external-programs.rst:320
msgid ""
"This example is similar to the previous one, except there are two stages of "
"consumers, and the stages have different latency so they use a different "
"number of parallel workers, to maintain saturated throughput."
msgstr ""

#: ../../manual/running-external-programs.rst:324
msgid ""
"We strongly encourage you to try all these examples to see how they work."
msgstr ""

#: ../../manual/strings.rst:7
msgid "Strings"
msgstr ""

#: ../../manual/strings.rst:9
msgid ""
"Strings are finite sequences of characters. Of course, the real trouble "
"comes when one asks what a character is. The characters that English "
"speakers are familiar with are the letters ``A``, ``B``, ``C``, etc., "
"together with numerals and common punctuation symbols. These characters are "
"standardized together with a mapping to integer values between 0 and 127 by "
"the `ASCII <http://en.wikipedia.org/wiki/ASCII>`_ standard. There are, of "
"course, many other characters used in non-English languages, including "
"variants of the ASCII characters with accents and other modifications, "
"related scripts such as Cyrillic and Greek, and scripts completely unrelated"
" to ASCII and English, including Arabic, Chinese, Hebrew, Hindi, Japanese, "
"and Korean. The `Unicode <http://en.wikipedia.org/wiki/Unicode>`_ standard "
"tackles the complexities of what exactly a character is, and is generally "
"accepted as the definitive standard addressing this problem. Depending on "
"your needs, you can either ignore these complexities entirely and just "
"pretend that only ASCII characters exist, or you can write code that can "
"handle any of the characters or encodings that one may encounter when "
"handling non-ASCII text. Julia makes dealing with plain ASCII text simple "
"and efficient, and handling Unicode is as simple and efficient as possible. "
"In particular, you can write C-style string code to process ASCII strings, "
"and they will work as expected, both in terms of performance and semantics. "
"If such code encounters non-ASCII text, it will gracefully fail with a clear"
" error message, rather than silently introducing corrupt results. When this "
"happens, modifying the code to handle non-ASCII data is straightforward."
msgstr ""

#: ../../manual/strings.rst:35
msgid "There are a few noteworthy high-level features about Julia's strings:"
msgstr ""

#: ../../manual/strings.rst:37
msgid ""
"``AbstractString`` is an abstraction, not a concrete type — many different "
"representations can implement the ``AbstractString`` interface, but they can"
" easily be used together and interact transparently. Any string type can be "
"used in any function expecting a ``AbstractString``."
msgstr ""

#: ../../manual/strings.rst:41
msgid ""
"Like C and Java, but unlike most dynamic languages, Julia has a first-class "
"type representing a single character, called ``Char``. This is just a "
"special kind of 32-bit bitstype whose numeric value represents a Unicode "
"code point."
msgstr ""

#: ../../manual/strings.rst:45
msgid ""
"As in Java, strings are immutable: the value of a ``AbstractString`` object "
"cannot be changed. To construct a different string value, you construct a "
"new string from parts of other strings."
msgstr ""

#: ../../manual/strings.rst:48
msgid ""
"Conceptually, a string is a *partial function* from indices to characters — "
"for some index values, no character value is returned, and instead an "
"exception is thrown. This allows for efficient indexing into strings by the "
"byte index of an encoded representation rather than by a character index, "
"which cannot be implemented both efficiently and simply for variable-width "
"encodings of Unicode strings."
msgstr ""

#: ../../manual/strings.rst:55
msgid ""
"Julia supports the full range of `Unicode "
"<http://en.wikipedia.org/wiki/Unicode>`_ characters: literal strings are "
"always `ASCII <http://en.wikipedia.org/wiki/ASCII>`_ or `UTF-8 "
"<http://en.wikipedia.org/wiki/UTF-8>`_ but other encodings for strings from "
"external sources can be supported."
msgstr ""

#: ../../manual/strings.rst:64
msgid "Characters"
msgstr ""

#: ../../manual/strings.rst:66
msgid ""
"A ``Char`` value represents a single character: it is just a 32-bit bitstype"
" with a special literal representation and appropriate arithmetic behaviors,"
" whose numeric value is interpreted as a `Unicode code point "
"<http://en.wikipedia.org/wiki/Code_point>`_. Here is how ``Char`` values are"
" input and shown:"
msgstr ""

#: ../../manual/strings.rst:80
msgid ""
"You can convert a ``Char`` to its integer value, i.e. code point, easily:"
msgstr ""

#: ../../manual/strings.rst:91
msgid ""
"On 32-bit architectures, ``typeof(ans)`` will be ``Int32``. You can convert "
"an integer value back to a ``Char`` just as easily:"
msgstr ""

#: ../../manual/strings.rst:99
msgid ""
"Not all integer values are valid Unicode code points, but for performance, "
"the :func:`char` conversion does not check that every character value is "
"valid. If you want to check that each converted value is a valid code point,"
" use the :func:`is_valid_char` function:"
msgstr ""

#: ../../manual/strings.rst:112
msgid ""
"As of this writing, the valid Unicode code points are ``U+00`` through "
"``U+d7ff`` and ``U+e000`` through ``U+10ffff``. These have not all been "
"assigned intelligible meanings yet, nor are they necessarily interpretable "
"by applications, but all of these values are considered to be valid Unicode "
"characters."
msgstr ""

#: ../../manual/strings.rst:118
msgid ""
"You can input any Unicode character in single quotes using ``\\u`` followed "
"by up to four hexadecimal digits or ``\\U`` followed by up to eight "
"hexadecimal digits (the longest valid value only requires six):"
msgstr ""

#: ../../manual/strings.rst:136
msgid ""
"Julia uses your system's locale and language settings to determine which "
"characters can be printed as-is and which must be output using the generic, "
"escaped ``\\u`` or ``\\U`` input forms. In addition to these Unicode escape "
"forms, all of `C's traditional escaped input forms "
"<http://en.wikipedia.org/wiki/C_syntax#Backslash_escapes>`_ can also be "
"used:"
msgstr ""

#: ../../manual/strings.rst:166
msgid ""
"You can do comparisons and a limited amount of arithmetic with ``Char`` "
"values:"
msgstr ""

#: ../../manual/strings.rst:187
msgid "AbstractString Basics"
msgstr ""

#: ../../manual/strings.rst:189
msgid ""
"AbstractString literals are delimited by double quotes or triple double "
"quotes:"
msgstr ""

#: ../../manual/strings.rst:199
msgid "If you want to extract a character from a string, you index into it:"
msgstr ""

#: ../../manual/strings.rst:212
msgid ""
"All indexing in Julia is 1-based: the first element of any integer-indexed "
"object is found at index 1, and the last element is found at index ``n``, "
"when the string has a length of ``n``."
msgstr ""

#: ../../manual/strings.rst:217
msgid ""
"In any indexing expression, the keyword ``end`` can be used as a shorthand "
"for the last index (computed by ``endof(str)``). You can perform arithmetic "
"and other operations with ``end``, just like a normal value:"
msgstr ""

#: ../../manual/strings.rst:238
msgid "Using an index less than 1 or greater than ``end`` raises an error::"
msgstr ""

#: ../../manual/strings.rst:248
msgid "You can also extract a substring using range indexing:"
msgstr ""

#: ../../manual/strings.rst:255
msgid ""
"Notice that the expressions ``str[k]`` and ``str[k:k]`` do not give the same"
" result:"
msgstr ""

#: ../../manual/strings.rst:265
msgid ""
"The former is a single character value of type ``Char``, while the latter is"
" a string value that happens to contain only a single character. In Julia "
"these are very different things."
msgstr ""

#: ../../manual/strings.rst:270
msgid "Unicode and UTF-8"
msgstr ""

#: ../../manual/strings.rst:272
msgid ""
"Julia fully supports Unicode characters and strings. As `discussed above "
"<#characters>`_, in character literals, Unicode code points can be "
"represented using Unicode ``\\u`` and ``\\U`` escape sequences, as well as "
"all the standard C escape sequences. These can likewise be used to write "
"string literals:"
msgstr ""

#: ../../manual/strings.rst:283
msgid ""
"Whether these Unicode characters are displayed as escapes or shown as "
"special characters depends on your terminal's locale settings and its "
"support for Unicode. Non-ASCII string literals are encoded using the UTF-8 "
"encoding. UTF-8 is a variable-width encoding, meaning that not all "
"characters are encoded in the same number of bytes. In UTF-8, ASCII "
"characters — i.e. those with code points less than 0x80 (128) — are encoded "
"as they are in ASCII, using a single byte, while code points 0x80 and above "
"are encoded using multiple bytes — up to four per character. This means that"
" not every byte index into a UTF-8 string is necessarily a valid index for a"
" character. If you index into a string at such an invalid byte index, an "
"error is thrown:"
msgstr ""

#: ../../manual/strings.rst:313
msgid ""
"In this case, the character ``∀`` is a three-byte character, so the indices "
"2 and 3 are invalid and the next character's index is 4."
msgstr ""

#: ../../manual/strings.rst:316
msgid ""
"Because of variable-length encodings, the number of characters in a string "
"(given by ``length(s)``) is not always the same as the last index. If you "
"iterate through the indices 1 through ``endof(s)`` and index into ``s``, the"
" sequence of characters returned when errors aren't thrown is the sequence "
"of characters comprising the string ``s``. Thus we have the identity that "
"``length(s) <= endof(s)``, since each character in a string must have its "
"own index. The following is an inefficient and verbose way to iterate "
"through the characters of ``s``:"
msgstr ""

#: ../../manual/strings.rst:342
msgid ""
"The blank lines actually have spaces on them. Fortunately, the above awkward"
" idiom is unnecessary for iterating through the characters in a string, "
"since you can just use the string as an iterable object, no exception "
"handling required:"
msgstr ""

#: ../../manual/strings.rst:360
msgid ""
"UTF-8 is not the only encoding that Julia supports, and adding support for "
"new encodings is quite easy.  In particular, Julia also provides "
"``UTF16String`` and ``UTF32String`` types, constructed by the ``utf16(s)`` "
"and ``utf32(s)`` functions respectively, for UTF-16 and UTF-32 encodings.  "
"It also provides aliases ``WString`` and ``wstring(s)`` for either UTF-16 or"
" UTF-32 strings, depending on the size of ``Cwchar_t``. Additional "
"discussion of other encodings and how to implement support for them is "
"beyond the scope of this document for the time being. For further discussion"
" of UTF-8 encoding issues, see the section below on `byte array literals "
"<#Byte+Array+Literals>`_, which goes into some greater detail."
msgstr ""

#: ../../manual/strings.rst:377
msgid "One of the most common and useful string operations is concatenation:"
msgstr ""

#: ../../manual/strings.rst:390
msgid ""
"Constructing strings like this can become a bit cumbersome, however. To "
"reduce the need for these verbose calls to :func:`string`, Julia allows "
"interpolation into string literals using ``$``, as in Perl:"
msgstr ""

#: ../../manual/strings.rst:399
msgid ""
"This is more readable and convenient and equivalent to the above string "
"concatenation — the system rewrites this apparent single string literal into"
" a concatenation of string literals with variables."
msgstr ""

#: ../../manual/strings.rst:403
msgid ""
"The shortest complete expression after the ``$`` is taken as the expression "
"whose value is to be interpolated into the string. Thus, you can interpolate"
" any expression into a string using parentheses:"
msgstr ""

#: ../../manual/strings.rst:412
msgid ""
"Both concatenation and string interpolation call the generic ``string`` "
"function to convert objects into string form. Most non-``AbstractString`` "
"objects are converted to strings closely corresponding to how they are "
"entered as literal expressions:"
msgstr ""

#: ../../manual/strings.rst:428
msgid ""
"The ``string`` function is the identity for ``AbstractString`` and ``Char`` "
"values, so these are interpolated into strings as themselves, unquoted and "
"unescaped:"
msgstr ""

#: ../../manual/strings.rst:440
msgid ""
"To include a literal ``$`` in a string literal, escape it with a backslash:"
msgstr ""

#: ../../manual/strings.rst:449
msgid "Common Operations"
msgstr ""

#: ../../manual/strings.rst:451
msgid ""
"You can lexicographically compare strings using the standard comparison "
"operators:"
msgstr ""

#: ../../manual/strings.rst:468
msgid ""
"You can search for the index of a particular character using the "
":func:`search` function:"
msgstr ""

#: ../../manual/strings.rst:482
msgid ""
"You can start the search for a character at a given offset by providing a "
"third argument:"
msgstr ""

#: ../../manual/strings.rst:496
msgid "Two other handy string functions are :func:`repeat` and :func:`join`:"
msgstr ""

#: ../../manual/strings.rst:506
msgid "Some other useful functions include:"
msgstr ""

#: ../../manual/strings.rst:508
msgid ""
"``endof(str)`` gives the maximal (byte) index that can be used to index into"
" ``str``."
msgstr ""

#: ../../manual/strings.rst:510
msgid "``length(str)`` the number of characters in ``str``."
msgstr ""

#: ../../manual/strings.rst:511
msgid ""
"``i = start(str)`` gives the first valid index at which a character can be "
"found in ``str`` (typically 1)."
msgstr ""

#: ../../manual/strings.rst:513
msgid ""
"``c, j = next(str,i)`` returns next character at or after the index ``i`` "
"and the next valid character index following that. With ``start`` and "
"``endof``, can be used to iterate through the characters in ``str``."
msgstr ""

#: ../../manual/strings.rst:517
msgid ""
"``ind2chr(str,i)`` gives the number of characters in ``str`` up to and "
"including any at index ``i``."
msgstr ""

#: ../../manual/strings.rst:519
msgid ""
"``chr2ind(str,j)`` gives the index at which the ``j``\\ th character in "
"``str`` occurs."
msgstr ""

#: ../../manual/strings.rst:527
msgid ""
"There are situations when you want to construct a string or use string "
"semantics, but the behavior of the standard string construct is not quite "
"what is needed. For these kinds of situations, Julia provides :ref:`non-"
"standard string literals <man-non-standard-string-literals2>`. A non-"
"standard string literal looks like a regular double-quoted string literal, "
"but is immediately prefixed by an identifier, and doesn't behave quite like "
"a normal string literal. Regular expressions, byte array literals and "
"version number literals, as described below, are some examples of non-"
"standard string literals. Other examples are given in the "
":ref:`metaprogramming <man-non-standard-string-literals2>` section."
msgstr ""

#: ../../manual/strings.rst:540
msgid "Regular Expressions"
msgstr ""

#: ../../manual/strings.rst:542
msgid ""
"Julia has Perl-compatible regular expressions (regexes), as provided by the "
"`PCRE <http://www.pcre.org/>`_ library. Regular expressions are related to "
"strings in two ways: the obvious connection is that regular expressions are "
"used to find regular patterns in strings; the other connection is that "
"regular expressions are themselves input as strings, which are parsed into a"
" state machine that can be used to efficiently search for patterns in "
"strings. In Julia, regular expressions are input using non-standard string "
"literals prefixed with various identifiers beginning with ``r``. The most "
"basic regular expression literal without any options turned on just uses "
"``r\"...\"``:"
msgstr ""

#: ../../manual/strings.rst:561
msgid ""
"To check if a regex matches a string, use the :func:`ismatch` function:"
msgstr ""

#: ../../manual/strings.rst:571
msgid ""
"As one can see here, ``ismatch`` simply returns true or false, indicating "
"whether the given regex matches the string or not. Commonly, however, one "
"wants to know not just whether a string matched, but also *how* it matched. "
"To capture this information about a match, use the :func:`match` function "
"instead:"
msgstr ""

#: ../../manual/strings.rst:584
msgid ""
"If the regular expression does not match the given string, ``match`` returns"
" ``nothing`` — a special value that does not print anything at the "
"interactive prompt. Other than not printing, it is a completely normal value"
" and you can test for it programmatically::"
msgstr ""

#: ../../manual/strings.rst:596
msgid ""
"If a regular expression does match, the value returned by ``match`` is a "
"``RegexMatch`` object. These objects record how the expression matches, "
"including the substring that the pattern matches and any captured "
"substrings, if there are any. This example only captures the portion of the "
"substring that matches, but perhaps we want to capture any non-blank text "
"after the comment character. We could do the following:"
msgstr ""

#: ../../manual/strings.rst:608
msgid ""
"When calling ``match``, you have the option to specify an index at which to "
"start the search. For example:"
msgstr ""

#: ../../manual/strings.rst:622
msgid "You can extract the following info from a ``RegexMatch`` object:"
msgstr ""

#: ../../manual/strings.rst:624
msgid "the entire substring matched: ``m.match``"
msgstr ""

#: ../../manual/strings.rst:625
msgid "the captured substrings as a tuple of strings: ``m.captures``"
msgstr ""

#: ../../manual/strings.rst:626
msgid "the offset at which the whole match begins: ``m.offset``"
msgstr ""

#: ../../manual/strings.rst:627
msgid "the offsets of the captured substrings as a vector: ``m.offsets``"
msgstr ""

#: ../../manual/strings.rst:629
msgid ""
"For when a capture doesn't match, instead of a substring, ``m.captures`` "
"contains ``nothing`` in that position, and ``m.offsets`` has a zero offset "
"(recall that indices in Julia are 1-based, so a zero offset into a string is"
" invalid). Here's is a pair of somewhat contrived examples::"
msgstr ""

#: ../../manual/strings.rst:676
msgid ""
"It is convenient to have captures returned as a tuple so that one can use "
"tuple destructuring syntax to bind them to local variables::"
msgstr ""

#: ../../manual/strings.rst:682
msgid ""
"You can modify the behavior of regular expressions by some combination of "
"the flags ``i``, ``m``, ``s``, and ``x`` after the closing double quote "
"mark. These flags have the same meaning as they do in Perl, as explained in "
"this excerpt from the `perlre manpage "
"<http://perldoc.perl.org/perlre.html#Modifiers>`_::"
msgstr ""

#: ../../manual/strings.rst:716
msgid "For example, the following regex has all three flags turned on:"
msgstr ""

#: ../../manual/strings.rst:726
msgid ""
"Triple-quoted regex strings, of the form ``r\"\"\"...\"\"\"``, are also "
"supported (and may be convenient for regular expressions containing "
"quotation marks or newlines)."
msgstr ""

#: ../../manual/strings.rst:731
msgid "Byte Array Literals"
msgstr ""

#: ../../manual/strings.rst:733
msgid ""
"Another useful non-standard string literal is the byte-array string literal:"
" ``b\"...\"``. This form lets you use string notation to express literal "
"byte arrays — i.e. arrays of ``UInt8`` values. The convention is that non-"
"standard literals with uppercase prefixes produce actual string objects, "
"while those with lowercase prefixes produce non-string objects like byte "
"arrays or compiled regular expressions. The rules for byte array literals "
"are the following:"
msgstr ""

#: ../../manual/strings.rst:741
msgid "ASCII characters and ASCII escapes produce a single byte."
msgstr ""

#: ../../manual/strings.rst:742
msgid ""
"``\\x`` and octal escape sequences produce the *byte* corresponding to the "
"escape value."
msgstr ""

#: ../../manual/strings.rst:744
msgid ""
"Unicode escape sequences produce a sequence of bytes encoding that code "
"point in UTF-8."
msgstr ""

#: ../../manual/strings.rst:747
msgid ""
"There is some overlap between these rules since the behavior of ``\\x`` and "
"octal escapes less than 0x80 (128) are covered by both of the first two "
"rules, but here these rules agree. Together, these rules allow one to easily"
" use ASCII characters, arbitrary byte values, and UTF-8 sequences to produce"
" arrays of bytes. Here is an example using all three:"
msgstr ""

#: ../../manual/strings.rst:767
msgid ""
"The ASCII string \"DATA\" corresponds to the bytes 68, 65, 84, 65. ``\\xff``"
" produces the single byte 255. The Unicode escape ``\\u2200`` is encoded in "
"UTF-8 as the three bytes 226, 136, 128. Note that the resulting byte array "
"does not correspond to a valid UTF-8 string — if you try to use this as a "
"regular string literal, you will get a syntax error:"
msgstr ""

#: ../../manual/strings.rst:779
msgid ""
"Also observe the significant distinction between ``\\xff`` and ``\\uff``: "
"the former escape sequence encodes the *byte 255*, whereas the latter escape"
" sequence represents the *code point 255*, which is encoded as two bytes in "
"UTF-8:"
msgstr ""

#: ../../manual/strings.rst:795
msgid ""
"In character literals, this distinction is glossed over and ``\\xff`` is "
"allowed to represent the code point 255, because characters *always* "
"represent code points. In strings, however, ``\\x`` escapes always represent"
" bytes, not code points, whereas ``\\u`` and ``\\U`` escapes always "
"represent code points, which are encoded in one or more bytes. For code "
"points less than ``\\u80``, it happens that the UTF-8 encoding of each code "
"point is just the single byte produced by the corresponding ``\\x`` escape, "
"so the distinction can safely be ignored. For the escapes ``\\x80`` through "
"``\\xff`` as compared to ``\\u80`` through ``\\uff``, however, there is a "
"major difference: the former escapes all encode single bytes, which — unless"
" followed by very specific continuation bytes — do not form valid UTF-8 "
"data, whereas the latter escapes all represent Unicode code points with two-"
"byte encodings."
msgstr ""

#: ../../manual/strings.rst:810
msgid ""
"If this is all extremely confusing, try reading `\"The Absolute Minimum "
"Every Software Developer Absolutely, Positively Must Know About Unicode and "
"Character Sets\" <http://www.joelonsoftware.com/articles/Unicode.html>`_. "
"It's an excellent introduction to Unicode and UTF-8, and may help alleviate "
"some confusion regarding the matter."
msgstr ""

#: ../../manual/strings.rst:820
msgid "Version Number Literals"
msgstr ""

#: ../../manual/strings.rst:822
msgid ""
"Version numbers can easily be expressed with non-standard string literals of"
" the form ``v\"...\"``. Version number literals create ``VersionNumber`` "
"objects which follow the specifications of `semantic versioning "
"<http://semver.org>`_, and therefore are composed of major, minor and patch "
"numeric values, followed by pre-release and build alpha-numeric annotations."
" For example, ``v\"0.2.1-rc1+win64\"`` is broken into major version ``0``, "
"minor version ``2``, patch version ``1``, pre-release ``rc1`` and build "
"``win64``. When entering a version literal, everything except the major "
"version number is optional, therefore e.g.  ``v\"0.2\"`` is equivalent to "
"``v\"0.2.0\"`` (with empty pre-release/build annotations), ``v\"2\"`` is "
"equivalent to ``v\"2.0.0\"``, and so on."
msgstr ""

#: ../../manual/strings.rst:834
msgid ""
"``VersionNumber`` objects are mostly useful to easily and correctly compare "
"two (or more) versions. For example, the constant ``VERSION`` holds Julia "
"version number as a ``VersionNumber`` object, and therefore one can define "
"some version-specific behaviour using simple statements as::"
msgstr ""

#: ../../manual/strings.rst:843
msgid ""
"Note that in the above example the non-standard version number ``v\"0.3-\"``"
" is used, with a trailing ``-``: this notation is a Julia extension of the "
"standard, and it's used to indicate a version which is lower than any "
"``0.3`` release, including all of its pre-releases. So in the above example "
"the code would only run with stable ``0.2`` versions, and exclude such "
"versions as ``v\"0.3.0-rc1\"``. In order to also allow for unstable (i.e. "
"pre-release) ``0.2`` versions, the lower bound check should be modified like"
" this: ``v\"0.2-\" <= VERSION``."
msgstr ""

#: ../../manual/strings.rst:852
msgid ""
"Another non-standard version specification extension allows to use a "
"trailing ``+`` to express an upper limit on build versions, e.g.  ``VERSION "
"> \"v\"0.2-rc1+\"`` can be used to mean any version above ``0.2-rc1`` and "
"any of its builds: it will return ``false`` for version "
"``v\"0.2-rc1+win64\"`` and ``true`` for ``v\"0.2-rc2\"``."
msgstr ""

#: ../../manual/strings.rst:858
msgid ""
"It is good practice to use such special versions in comparisons "
"(particularly, the trailing ``-`` should always be used on upper bounds "
"unless there's a good reason not to), but they must not be used as the "
"actual version number of anything, as they are invalid in the semantic "
"versioning scheme."
msgstr ""

#: ../../manual/strings.rst:863
msgid ""
"Besides being used for the ``VERSION`` constant, ``VersionNumber`` objects "
"are widely used in the ``Pkg`` module, to specify packages versions and "
"their dependencies."
msgstr ""

#: ../../manual/style-guide.rst:5
msgid "Style Guide"
msgstr ""

#: ../../manual/style-guide.rst:7
msgid ""
"The following sections explain a few aspects of idiomatic Julia coding "
"style. None of these rules are absolute; they are only suggestions to help "
"familiarize you with the language and to help you choose among alternative "
"designs."
msgstr ""

#: ../../manual/style-guide.rst:12
msgid "Write functions, not just scripts"
msgstr ""

#: ../../manual/style-guide.rst:14
msgid ""
"Writing code as a series of steps at the top level is a quick way to get "
"started solving a problem, but you should try to divide a program into "
"functions as soon as possible. Functions are more reusable and testable, and"
" clarify what steps are being done and what their inputs and outputs are. "
"Furthermore, code inside functions tends to run much faster than top level "
"code, due to how Julia's compiler works."
msgstr ""

#: ../../manual/style-guide.rst:21
msgid ""
"It is also worth emphasizing that functions should take arguments, instead "
"of operating directly on global variables (aside from constants like "
"``pi``)."
msgstr ""

#: ../../manual/style-guide.rst:25
msgid "Avoid writing overly-specific types"
msgstr ""

#: ../../manual/style-guide.rst:27
msgid "Code should be as generic as possible. Instead of writing::"
msgstr ""

#: ../../manual/style-guide.rst:31
msgid "it's better to use available generic functions::"
msgstr ""

#: ../../manual/style-guide.rst:35
msgid ""
"The second version will convert ``x`` to an appropriate type, instead of "
"always the same type."
msgstr ""

#: ../../manual/style-guide.rst:38
msgid ""
"This style point is especially relevant to function arguments. For example, "
"don't declare an argument to be of type ``Int`` or ``Int32`` if it really "
"could be any integer, expressed with the abstract type ``Integer``.  In "
"fact, in many cases you can omit the argument type altogether, unless it is "
"needed to disambiguate from other method definitions, since a "
"``MethodError`` will be thrown anyway if a type is passed that does not "
"support any of the requisite operations. (This is known as `duck typing "
"<http://en.wikipedia.org/wiki/Duck_typing>`_.)"
msgstr ""

#: ../../manual/style-guide.rst:47
msgid ""
"For example, consider the following definitions of a function ``addone`` "
"that returns one plus its argument::"
msgstr ""

#: ../../manual/style-guide.rst:55
msgid ""
"The last definition of ``addone`` handles any type supporting the ``one`` "
"function (which returns 1 in the same type as ``x``, which avoids unwanted "
"type promotion) and the ``+`` function with those arguments.  The key thing "
"to realize is that there is *no performance penalty* to defining *only* the "
"general ``addone(x) = x + one(x)``, because Julia will automatically compile"
" specialized versions as needed.  For example, the first time you call "
"``addone(12)``, Julia will automatically compile a specialized ``addone`` "
"function for ``x::Int`` arguments, with the call to ``one`` replaced by its "
"inlined value ``1``.  Therefore, the first three definitions of ``addone`` "
"above are completely redundant."
msgstr ""

#: ../../manual/style-guide.rst:68
msgid "Handle excess argument diversity in the caller"
msgstr ""

#: ../../manual/style-guide.rst:70 ../../manual/style-guide.rst:96
msgid "Instead of::"
msgstr ""

#: ../../manual/style-guide.rst:85
msgid ""
"This is better style because ``foo`` does not really accept numbers of all "
"types; it really needs ``Int`` s."
msgstr ""

#: ../../manual/style-guide.rst:88
msgid ""
"One issue here is that if a function inherently requires integers, it might "
"be better to force the caller to decide how non-integers should be converted"
" (e.g. floor or ceiling). Another issue is that declaring more specific "
"types leaves more \"space\" for future method definitions."
msgstr ""

#: ../../manual/style-guide.rst:94
msgid "Append `!` to names of functions that modify their arguments"
msgstr ""

#: ../../manual/style-guide.rst:110
msgid ""
"The Julia standard library uses this convention throughout and contains "
"examples of functions with both copying and modifying forms (e.g., ``sort`` "
"and ``sort!``), and others which are just modifying (e.g., ``push!``, "
"``pop!``, ``splice!``).  It is typical for such functions to also return the"
" modified array for convenience."
msgstr ""

#: ../../manual/style-guide.rst:117
msgid "Avoid strange type Unions"
msgstr ""

#: ../../manual/style-guide.rst:119
msgid ""
"Types such as ``Union(Function,AbstractString)`` are often a sign that some "
"design could be cleaner."
msgstr ""

#: ../../manual/style-guide.rst:123
msgid "Try to avoid nullable fields"
msgstr ""

#: ../../manual/style-guide.rst:125
msgid ""
"When using ``x::Union(Nothing,T)``, ask whether the option for ``x`` to be "
"``nothing`` is really necessary. Here are some alternatives to consider:"
msgstr ""

#: ../../manual/style-guide.rst:128
msgid "Find a safe default value to initialize ``x`` with"
msgstr ""

#: ../../manual/style-guide.rst:129
msgid "Introduce another type that lacks ``x``"
msgstr ""

#: ../../manual/style-guide.rst:130
msgid "If there are many fields like ``x``, store them in a dictionary"
msgstr ""

#: ../../manual/style-guide.rst:131
msgid ""
"Determine whether there is a simple rule for when ``x`` is ``nothing``. For "
"example, often the field will start as ``nothing`` but get initialized at "
"some well-defined point. In that case, consider leaving it undefined at "
"first."
msgstr ""

#: ../../manual/style-guide.rst:136
msgid "Avoid elaborate container types"
msgstr ""

#: ../../manual/style-guide.rst:138
msgid "It is usually not much help to construct arrays like the following::"
msgstr ""

#: ../../manual/style-guide.rst:142
msgid ""
"In this case ``cell(n)`` is better. It is also more helpful to the compiler "
"to annotate specific uses (e.g. ``a[i]::Int``) than to try to pack many "
"alternatives into one type."
msgstr ""

#: ../../manual/style-guide.rst:147
msgid "Use naming conventions consistent with Julia's ``base/``"
msgstr ""

#: ../../manual/style-guide.rst:149
msgid ""
"modules and type names use capitalization and camel case: ``module "
"SparseMatrix``,  ``immutable UnitRange``."
msgstr ""

#: ../../manual/style-guide.rst:151
msgid ""
"functions are lowercase (``maximum``, ``convert``) and, when readable, with "
"multiple words squashed together (``isequal``, ``haskey``). When necessary, "
"use underscores as word separators. Underscores are also used to indicate a "
"combination of concepts (``remotecall_fetch`` as a more efficient "
"implementation of ``remotecall(fetch(...))``) or as modifiers (``sum_kbn``)."
msgstr ""

#: ../../manual/style-guide.rst:157
msgid ""
"conciseness is valued, but avoid abbreviation (``indexin`` rather than "
"``indxin``) as it becomes difficult to remember whether and how particular "
"words are abbreviated."
msgstr ""

#: ../../manual/style-guide.rst:161
msgid ""
"If a function name requires multiple words, consider whether it might "
"represent more than one concept and might be better split into pieces."
msgstr ""

#: ../../manual/style-guide.rst:165
msgid "Don't overuse try-catch"
msgstr ""

#: ../../manual/style-guide.rst:167
msgid "It is better to avoid errors than to rely on catching them."
msgstr ""

#: ../../manual/style-guide.rst:170
msgid "Don't parenthesize conditions"
msgstr ""

#: ../../manual/style-guide.rst:172
msgid ""
"Julia doesn't require parens around conditions in ``if`` and ``while``. "
"Write::"
msgstr ""

#: ../../manual/style-guide.rst:177
msgid "instead of::"
msgstr ""

#: ../../manual/style-guide.rst:182
msgid "Don't overuse ..."
msgstr ""

#: ../../manual/style-guide.rst:184
msgid ""
"Splicing function arguments can be addictive. Instead of ``[a..., b...]``, "
"use simply ``[a, b]``, which already concatenates arrays. ``collect(a)`` is "
"better than ``[a...]``, but since ``a`` is already iterable it is often even"
" better to leave it alone, and not convert it to an array."
msgstr ""

#: ../../manual/style-guide.rst:190
msgid "Don't use unnecessary static parameters"
msgstr ""

#: ../../manual/style-guide.rst:192
msgid "A function signature::"
msgstr ""

#: ../../manual/style-guide.rst:196
msgid "should be written as::"
msgstr ""

#: ../../manual/style-guide.rst:200
msgid ""
"instead, especially if ``T`` is not used in the function body. Even if ``T``"
" is used, it can be replaced with ``typeof(x)`` if convenient. There is no "
"performance difference. Note that this is not a general caution against "
"static parameters, just against uses where they are not needed."
msgstr ""

#: ../../manual/style-guide.rst:206
msgid ""
"Note also that container types, specifically may need type parameters in "
"function calls. See the FAQ :ref:`man-abstract-container-type` for more "
"information."
msgstr ""

#: ../../manual/style-guide.rst:211
msgid "Avoid confusion about whether something is an instance or a type"
msgstr ""

#: ../../manual/style-guide.rst:213
msgid "Sets of definitions like the following are confusing::"
msgstr ""

#: ../../manual/style-guide.rst:218
msgid ""
"Decide whether the concept in question will be written as ``MyType`` or "
"``MyType()``, and stick to it."
msgstr ""

#: ../../manual/style-guide.rst:221
msgid ""
"The preferred style is to use instances by default, and only add methods "
"involving ``Type{MyType}`` later if they become necessary to solve some "
"problem."
msgstr ""

#: ../../manual/style-guide.rst:225
msgid ""
"If a type is effectively an enumeration, it should be defined as a single "
"(ideally ``immutable``) type, with the enumeration values being instances of"
" it. Constructors and conversions can check whether values are valid. This "
"design is preferred over making the enumeration an abstract type, with the "
"\"values\" as subtypes."
msgstr ""

#: ../../manual/style-guide.rst:232
msgid "Don't overuse macros"
msgstr ""

#: ../../manual/style-guide.rst:234
msgid "Be aware of when a macro could really be a function instead."
msgstr ""

#: ../../manual/style-guide.rst:236
msgid ""
"Calling ``eval`` inside a macro is a particularly dangerous warning sign; it"
" means the macro will only work when called at the top level. If such a "
"macro is written as a function instead, it will naturally have access to the"
" run-time values it needs."
msgstr ""

#: ../../manual/style-guide.rst:242
msgid "Don't expose unsafe operations at the interface level"
msgstr ""

#: ../../manual/style-guide.rst:244
msgid "If you have a type that uses a native pointer::"
msgstr ""

#: ../../manual/style-guide.rst:251
msgid "don't write definitions like the following::"
msgstr ""

#: ../../manual/style-guide.rst:255
msgid ""
"The problem is that users of this type can write ``x[i]`` without realizing "
"that the operation is unsafe, and then be susceptible to memory bugs."
msgstr ""

#: ../../manual/style-guide.rst:258
msgid ""
"Such a function should either check the operation to ensure it is safe, or "
"have ``unsafe`` somewhere in its name to alert callers."
msgstr ""

#: ../../manual/style-guide.rst:262
msgid "Don't overload methods of base container types"
msgstr ""

#: ../../manual/style-guide.rst:264
msgid "It is possible to write definitions like the following::"
msgstr ""

#: ../../manual/style-guide.rst:268
msgid ""
"This would provide custom showing of vectors with a specific new element "
"type. While tempting, this should be avoided. The trouble is that users will"
" expect a well-known type like ``Vector`` to behave in a certain way, and "
"overly customizing its behavior can make it harder to work with."
msgstr ""

#: ../../manual/style-guide.rst:274
msgid "Be careful with type equality"
msgstr ""

#: ../../manual/style-guide.rst:276
msgid ""
"You generally want to use ``isa`` and ``<:`` (``issubtype``) for testing "
"types, not ``==``. Checking types for exact equality typically only makes "
"sense when comparing to a known concrete type (e.g. ``T == Float64``), or if"
" you *really, really* know what you're doing."
msgstr ""

#: ../../manual/style-guide.rst:282
msgid "Do not write ``x->f(x)``"
msgstr ""

#: ../../manual/style-guide.rst:284
msgid ""
"Since higher-order functions are often called with anonymous functions, it "
"is easy to conclude that this is desirable or even necessary. But any "
"function can be passed directly, without being \"wrapped\" in an anonymous "
"function. Instead of writing ``map(x->f(x), a)``, write ``map(f, a)``."
msgstr ""

#: ../../manual/types.rst:5
msgid "Types"
msgstr ""

#: ../../manual/types.rst:7
msgid ""
"Type systems have traditionally fallen into two quite different camps: "
"static type systems, where every program expression must have a type "
"computable before the execution of the program, and dynamic type systems, "
"where nothing is known about types until run time, when the actual values "
"manipulated by the program are available. Object orientation allows some "
"flexibility in statically typed languages by letting code be written without"
" the precise types of values being known at compile time. The ability to "
"write code that can operate on different types is called polymorphism. All "
"code in classic dynamically typed languages is polymorphic: only by "
"explicitly checking types, or when objects fail to support operations at "
"run-time, are the types of any values ever restricted."
msgstr ""

#: ../../manual/types.rst:20
msgid ""
"Julia's type system is dynamic, but gains some of the advantages of static "
"type systems by making it possible to indicate that certain values are of "
"specific types. This can be of great assistance in generating efficient "
"code, but even more significantly, it allows method dispatch on the types of"
" function arguments to be deeply integrated with the language. Method "
"dispatch is explored in detail in :ref:`man-methods`, but is rooted in the "
"type system presented here."
msgstr ""

#: ../../manual/types.rst:29
msgid ""
"The default behavior in Julia when types are omitted is to allow values to "
"be of any type. Thus, one can write many useful Julia programs without ever "
"explicitly using types. When additional expressiveness is needed, however, "
"it is easy to gradually introduce explicit type annotations into previously "
"\"untyped\" code. Doing so will typically increase both the performance and "
"robustness of these systems, and perhaps somewhat counterintuitively, often "
"significantly simplify them."
msgstr ""

#: ../../manual/types.rst:37
msgid ""
"Describing Julia in the lingo of `type systems "
"<http://en.wikipedia.org/wiki/Type_system>`_, it is: dynamic, nominative and"
" parametric. Generic types can be parameterized, and the hierarchical "
"relationships between types are explicitly declared, rather than implied by "
"compatible structure. One particularly distinctive feature of Julia's type "
"system is that concrete types may not subtype each other: all concrete types"
" are final and may only have abstract types as their supertypes. While this "
"might at first seem unduly restrictive, it has many beneficial consequences "
"with surprisingly few drawbacks. It turns out that being able to inherit "
"behavior is much more important than being able to inherit structure, and "
"inheriting both causes significant difficulties in traditional object-"
"oriented languages. Other high-level aspects of Julia's type system that "
"should be mentioned up front are:"
msgstr ""

#: ../../manual/types.rst:52
msgid ""
"There is no division between object and non-object values: all values in "
"Julia are true objects having a type that belongs to a single, fully "
"connected type graph, all nodes of which are equally first-class as types."
msgstr ""

#: ../../manual/types.rst:56
msgid ""
"There is no meaningful concept of a \"compile-time type\": the only type a "
"value has is its actual type when the program is running. This is called a "
"\"run-time type\" in object-oriented languages where the combination of "
"static compilation with polymorphism makes this distinction significant."
msgstr ""

#: ../../manual/types.rst:61
msgid ""
"Only values, not variables, have types — variables are simply names bound to"
" values."
msgstr ""

#: ../../manual/types.rst:63
msgid ""
"Both abstract and concrete types can be parameterized by other types. They "
"can also be parameterized by symbols, by values of any type for which "
"`isbits` returns true (essentially, things like numbers and bools that are "
"stored like C types or structs with no pointers to other objects), and also "
"by tuples thereof. Type parameters may be omitted when they do not need to "
"be referenced or restricted."
msgstr ""

#: ../../manual/types.rst:70
msgid ""
"Julia's type system is designed to be powerful and expressive, yet clear, "
"intuitive and unobtrusive. Many Julia programmers may never feel the need to"
" write code that explicitly uses types. Some kinds of programming, however, "
"become clearer, simpler, faster and more robust with declared types."
msgstr ""

#: ../../manual/types.rst:77
msgid "Type Declarations"
msgstr ""

#: ../../manual/types.rst:79
msgid ""
"The ``::`` operator can be used to attach type annotations to expressions "
"and variables in programs. There are two primary reasons to do this:"
msgstr ""

#: ../../manual/types.rst:83
msgid ""
"As an assertion to help confirm that your program works the way you expect,"
msgstr ""

#: ../../manual/types.rst:85
msgid ""
"To provide extra type information to the compiler, which can then improve "
"performance in some cases"
msgstr ""

#: ../../manual/types.rst:88
msgid ""
"When appended to an expression computing a *value*, the ``::`` operator is "
"read as \"is an instance of\". It can be used anywhere to assert that the "
"value of the expression on the left is an instance of the type on the right."
" When the type on the right is concrete, the value on the left must have "
"that type as its implementation — recall that all concrete types are final, "
"so no implementation is a subtype of any other. When the type is abstract, "
"it suffices for the value to be implemented by a concrete type that is a "
"subtype of the abstract type. If the type assertion is not true, an "
"exception is thrown, otherwise, the left-hand value is returned:"
msgstr ""

#: ../../manual/types.rst:107
msgid ""
"This allows a type assertion to be attached to any expression in-place. The "
"most common usage of ``::`` as an assertion is in function/methods "
"signatures, such as ``f(x::Int8) = ...`` (see :ref:`man-methods`)."
msgstr ""

#: ../../manual/types.rst:113
msgid ""
"When appended to a *variable* in a statement context, the ``::`` operator "
"means something a bit different: it declares the variable to always have the"
" specified type, like a type declaration in a statically-typed language such"
" as C. Every value assigned to the variable will be converted to the "
"declared type using the ``convert`` function:"
msgstr ""

#: ../../manual/types.rst:134
msgid ""
"This feature is useful for avoiding performance \"gotchas\" that could occur"
" if one of the assignments to a variable changed its type unexpectedly."
msgstr ""

#: ../../manual/types.rst:138
msgid "The \"declaration\" behavior only occurs in specific contexts::"
msgstr ""

#: ../../manual/types.rst:144
msgid ""
"and applies to the whole current scope, even before the declaration. "
"Currently, type declarations cannot be used in global scope, e.g. in the "
"REPL, since Julia does not yet have constant-type globals.  Note that in a "
"function return statement, the first two of the above expressions compute a "
"value and then ``::`` is a type assertion and not a declaration."
msgstr ""

#: ../../manual/types.rst:155
msgid "Abstract Types"
msgstr ""

#: ../../manual/types.rst:157
msgid ""
"Abstract types cannot be instantiated, and serve only as nodes in the type "
"graph, thereby describing sets of related concrete types: those concrete "
"types which are their descendants. We begin with abstract types even though "
"they have no instantiation because they are the backbone of the type system:"
" they form the conceptual hierarchy which makes Julia's type system more "
"than just a collection of object implementations."
msgstr ""

#: ../../manual/types.rst:164
msgid ""
"Recall that in :ref:`man-integers-and-floating-point-numbers`, we introduced"
" a variety of concrete types of numeric values: ``Int8``, ``UInt8``, "
"``Int16``, ``UInt16``, ``Int32``, ``UInt32``, ``Int64``, ``UInt64``, "
"``Int128``, ``UInt128``, ``Float16``, ``Float32``, and ``Float64``.  "
"Although they have different representation sizes, ``Int8``, ``Int16``, "
"``Int32``, ``Int64``  and ``Int128`` all have in common that they are signed"
" integer types. Likewise ``UInt8``, ``UInt16``, ``UInt32``, ``UInt64`` and "
"``UInt128`` are all unsigned integer types, while ``Float16``, ``Float32`` "
"and ``Float64`` are distinct in being floating-point types rather than "
"integers. It is common for a piece of code to make sense, for example, only "
"if its arguments are some kind of integer, but not really depend on what "
"particular *kind* of integer.  For example, the greatest common denominator "
"algorithm works for all kinds of integers, but will not work for floating-"
"point numbers.  Abstract types allow the construction of a hierarchy of "
"types, providing a context into which concrete types can fit.  This allows "
"you, for example, to easily program to any type that is an integer, without "
"restricting an algorithm to a specific type of integer."
msgstr ""

#: ../../manual/types.rst:183
msgid ""
"Abstract types are declared using the ``abstract`` keyword. The general "
"syntaxes for declaring an abstract type are::"
msgstr ""

#: ../../manual/types.rst:189
msgid ""
"The ``abstract`` keyword introduces a new abstract type, whose name is given"
" by ``«name»``. This name can be optionally followed by ``<:`` and an "
"already-existing type, indicating that the newly declared abstract type is a"
" subtype of this \"parent\" type."
msgstr ""

#: ../../manual/types.rst:194
msgid ""
"When no supertype is given, the default supertype is ``Any`` — a predefined "
"abstract type that all objects are instances of and all types are subtypes "
"of. In type theory, ``Any`` is commonly called \"top\" because it is at the "
"apex of the type graph. Julia also has a predefined abstract \"bottom\" "
"type, at the nadir of the type graph, which is called ``None``. It is the "
"exact opposite of ``Any``: no object is an instance of ``None`` and all "
"types are supertypes of ``None``."
msgstr ""

#: ../../manual/types.rst:202
msgid ""
"Let's consider some of the abstract types that make up Julia's numerical "
"hierarchy::"
msgstr ""

#: ../../manual/types.rst:212
msgid ""
"The ``Number`` type is a direct child type of ``Any``, and ``Real`` is its "
"child. In turn, ``Real`` has two children (it has more, but only two are "
"shown here; we'll get to the others later): ``Integer`` and "
"``FloatingPoint``, separating the world into representations of integers and"
" representations of real numbers. Representations of real numbers include, "
"of course, floating-point types, but also include other types, such as "
"rationals. Hence, ``FloatingPoint`` is a proper subtype of ``Real``, "
"including only floating-point representations of real numbers. Integers are "
"further subdivided into ``Signed`` and ``Unsigned`` varieties."
msgstr ""

#: ../../manual/types.rst:223
msgid ""
"The ``<:`` operator in general means \"is a subtype of\", and, used in "
"declarations like this, declares the right-hand type to be an immediate "
"supertype of the newly declared type. It can also be used in expressions as "
"a subtype operator which returns ``true`` when its left operand is a subtype"
" of its right operand:"
msgstr ""

#: ../../manual/types.rst:237
msgid ""
"An important use of abstract types is to provide default implementations for"
" concrete types. To give a simple example, consider::"
msgstr ""

#: ../../manual/types.rst:244
msgid ""
"The first thing to note is that the above argument declarations are "
"equivalent to ``x::Any`` and ``y::Any``. When this function is invoked, say "
"as ``myplus(2,5)``, the dispatcher chooses the most specific method named "
"``myplus`` that matches the given arguments. (See :ref:`man-methods` for "
"more information on multiple dispatch.)"
msgstr ""

#: ../../manual/types.rst:250
msgid ""
"Assuming no method more specific than the above is found, Julia next "
"internally defines and compiles a method called ``myplus`` specifically for "
"two ``Int`` arguments based on the generic function given above, i.e., it "
"implicitly defines and compiles::"
msgstr ""

#: ../../manual/types.rst:259
msgid "and finally, it invokes this specific method."
msgstr ""

#: ../../manual/types.rst:261
msgid ""
"Thus, abstract types allow programmers to write generic functions that can "
"later be used as the default method by many combinations of concrete types. "
"Thanks to multiple dispatch, the programmer has full control over whether "
"the default or more specific method is used."
msgstr ""

#: ../../manual/types.rst:266
msgid ""
"An important point to note is that there is no loss in performance if the "
"programmer relies on a function whose arguments are abstract types, because "
"it is recompiled for each tuple of argument concrete types with which it is "
"invoked. (There may be a performance issue, however, in the case of function"
" arguments that are containers of abstract types; see :ref:`man-performance-"
"tips`.)"
msgstr ""

#: ../../manual/types.rst:274
msgid "Bits Types"
msgstr ""

#: ../../manual/types.rst:276
msgid ""
"A bits type is a concrete type whose data consists of plain old bits. "
"Classic examples of bits types are integers and floating-point values. "
"Unlike most languages, Julia lets you declare your own bits types, rather "
"than providing only a fixed set of built-in bits types. In fact, the "
"standard bits types are all defined in the language itself::"
msgstr ""

#: ../../manual/types.rst:300
msgid "The general syntaxes for declaration of a ``bitstype`` are::"
msgstr ""

#: ../../manual/types.rst:305
msgid ""
"The number of bits indicates how much storage the type requires and the name"
" gives the new type a name. A bits type can optionally be declared to be a "
"subtype of some supertype. If a supertype is omitted, then the type defaults"
" to having ``Any`` as its immediate supertype. The declaration of ``Bool`` "
"above therefore means that a boolean value takes eight bits to store, and "
"has ``Integer`` as its immediate supertype. Currently, only sizes that are "
"multiples of 8 bits are supported. Therefore, boolean values, although they "
"really need just a single bit, cannot be declared to be any smaller than "
"eight bits."
msgstr ""

#: ../../manual/types.rst:315
msgid ""
"The types ``Bool``, ``Int8`` and ``UInt8`` all have identical "
"representations: they are eight-bit chunks of memory. Since Julia's type "
"system is nominative, however, they are not interchangeable despite having "
"identical structure. Another fundamental difference between them is that "
"they have different supertypes: ``Bool``'s direct supertype is ``Integer``, "
"``Int8``'s is ``Signed``, and ``UInt8``'s is ``Unsigned``. All other "
"differences between ``Bool``, ``Int8``, and ``UInt8`` are matters of "
"behavior — the way functions are defined to act when given objects of these "
"types as arguments. This is why a nominative type system is necessary: if "
"structure determined type, which in turn dictates behavior, then it would be"
" impossible to make ``Bool`` behave any differently than ``Int8`` or "
"``UInt8``."
msgstr ""

#: ../../manual/types.rst:331
msgid "Composite Types"
msgstr ""

#: ../../manual/types.rst:333
msgid ""
"`Composite types <http://en.wikipedia.org/wiki/Composite_data_type>`_ are "
"called records, structures (``structs`` in C), or objects in various "
"languages. A composite type is a collection of named fields, an instance of "
"which can be treated as a single value. In many languages, composite types "
"are the only kind of user-definable type, and they are by far the most "
"commonly used user-defined type in Julia as well."
msgstr ""

#: ../../manual/types.rst:340
msgid ""
"In mainstream object oriented languages, such as C++, Java, Python and Ruby,"
" composite types also have named functions associated with them, and the "
"combination is called an \"object\". In purer object-oriented languages, "
"such as Python and Ruby, all values are objects whether they are composites "
"or not. In less pure object oriented languages, including C++ and Java, some"
" values, such as integers and floating-point values, are not objects, while "
"instances of user-defined composite types are true objects with associated "
"methods. In Julia, all values are objects, but functions are not bundled "
"with the objects they operate on. This is necessary since Julia chooses "
"which method of a function to use by multiple dispatch, meaning that the "
"types of *all* of a function's arguments are considered when selecting a "
"method, rather than just the first one (see :ref:`man-methods` for more "
"information on methods and dispatch). Thus, it would be inappropriate for "
"functions to \"belong\" to only their first argument. Organizing methods "
"into function objects rather than having named bags of methods \"inside\" "
"each object ends up being a highly beneficial aspect of the language design."
msgstr ""

#: ../../manual/types.rst:360
msgid ""
"Since composite types are the most common form of user-defined concrete "
"type, they are simply introduced with the ``type`` keyword followed by a "
"block of field names, optionally annotated with types using the ``::`` "
"operator:"
msgstr ""

#: ../../manual/types.rst:373
msgid ""
"Fields with no type annotation default to ``Any``, and can accordingly hold "
"any type of value."
msgstr ""

#: ../../manual/types.rst:376
msgid ""
"New objects of composite type ``Foo`` are created by applying the ``Foo`` "
"type object like a function to values for its fields:"
msgstr ""

#: ../../manual/types.rst:387
msgid ""
"When a type is applied like a function it is called a *constructor*. Two "
"constructors are generated automatically (these are called *default "
"constructors*). One accepts any arguments and calls ``convert`` to convert "
"them to the types of the fields, and the other accepts arguments that match "
"the field types exactly. The reason both of these are generated is that this"
" makes it easier to add new definitions without inadvertently replacing a "
"default constructor."
msgstr ""

#: ../../manual/types.rst:395
msgid ""
"Since the ``bar`` field is unconstrained in type, any value will do. "
"However, the value for ``baz`` must be convertible to ``Int``:"
msgstr ""

#: ../../manual/types.rst:404
msgid "You may find a list of field names using the ``names`` function."
msgstr ""

#: ../../manual/types.rst:414
msgid ""
"You can access the field values of a composite object using the traditional "
"``foo.bar`` notation:"
msgstr ""

#: ../../manual/types.rst:428
msgid "You can also change the values as one would expect:"
msgstr ""

#: ../../manual/types.rst:438
msgid ""
"Composite types with no fields are singletons; there can be only one "
"instance of such types::"
msgstr ""

#: ../../manual/types.rst:447
msgid ""
"The ``is`` function confirms that the \"two\" constructed instances of "
"``NoFields`` are actually one and the same. Singleton types are described in"
" further detail `below <#man-singleton-types>`_."
msgstr ""

#: ../../manual/types.rst:451
msgid ""
"There is much more to say about how instances of composite types are "
"created, but that discussion depends on both `Parametric Types <#man-"
"parametric-types>`_ and on :ref:`man-methods`, and is sufficiently important"
" to be addressed in its own section: :ref:`man-constructors`."
msgstr ""

#: ../../manual/types.rst:460
msgid "Immutable Composite Types"
msgstr ""

#: ../../manual/types.rst:462
msgid ""
"It is also possible to define *immutable* composite types by using the "
"keyword ``immutable`` instead of ``type``::"
msgstr ""

#: ../../manual/types.rst:470
msgid ""
"Such types behave much like other composite types, except that instances of "
"them cannot be modified. Immutable types have several advantages:"
msgstr ""

#: ../../manual/types.rst:473
msgid ""
"They are more efficient in some cases. Types like the ``Complex`` example "
"above can be packed efficiently into arrays, and in some cases the compiler "
"is able to avoid allocating immutable objects entirely."
msgstr ""

#: ../../manual/types.rst:477
msgid ""
"It is not possible to violate the invariants provided by the type's "
"constructors."
msgstr ""

#: ../../manual/types.rst:479
msgid "Code using immutable objects can be easier to reason about."
msgstr ""

#: ../../manual/types.rst:481
msgid ""
"An immutable object might contain mutable objects, such as arrays, as "
"fields. Those contained objects will remain mutable; only the fields of the "
"immutable object itself cannot be changed to point to different objects."
msgstr ""

#: ../../manual/types.rst:485
msgid ""
"A useful way to think about immutable composites is that each instance is "
"associated with specific field values --- the field values alone tell you "
"everything about the object. In contrast, a mutable object is like a little "
"container that might hold different values over time, and so is not "
"identified with specific field values. In deciding whether to make a type "
"immutable, ask whether two instances with the same field values would be "
"considered identical, or if they might need to change independently over "
"time. If they would be considered identical, the type should probably be "
"immutable."
msgstr ""

#: ../../manual/types.rst:495
msgid "To recap, two essential properties define immutability in Julia:"
msgstr ""

#: ../../manual/types.rst:498
msgid ""
"An object with an immutable type is passed around (both in assignment "
"statements and in function calls) by copying, whereas a mutable type is "
"passed around by reference."
msgstr ""

#: ../../manual/types.rst:502
msgid ""
"It is not permitted to modify the fields of a composite immutable type."
msgstr ""

#: ../../manual/types.rst:505
msgid ""
"It is instructive, particularly for readers whose background is C/C++, to "
"consider why these two properties go hand in hand.  If they were separated, "
"i.e., if the fields of objects passed around by copying could be modified, "
"then it would become more difficult to reason about certain instances of "
"generic code.  For example, suppose ``x`` is a function argument of an "
"abstract type, and suppose that the function changes a field: "
"``x.isprocessed = true``.  Depending on whether ``x`` is passed by copying "
"or by reference, this statement may or may not alter the actual argument in "
"the calling routine.  Julia sidesteps the possibility of creating functions "
"with unknown effects in this scenario by forbidding modification of fields "
"of objects passed around by copying."
msgstr ""

#: ../../manual/types.rst:519
msgid "Declared Types"
msgstr ""

#: ../../manual/types.rst:521
msgid ""
"The three kinds of types discussed in the previous three sections are "
"actually all closely related. They share the same key properties:"
msgstr ""

#: ../../manual/types.rst:524
msgid "They are explicitly declared."
msgstr ""

#: ../../manual/types.rst:525
msgid "They have names."
msgstr ""

#: ../../manual/types.rst:526
msgid "They have explicitly declared supertypes."
msgstr ""

#: ../../manual/types.rst:527
msgid "They may have parameters."
msgstr ""

#: ../../manual/types.rst:529
msgid ""
"Because of these shared properties, these types are internally represented "
"as instances of the same concept, ``DataType``, which is the type of any of "
"these types:"
msgstr ""

#: ../../manual/types.rst:541
msgid ""
"A ``DataType`` may be abstract or concrete. If it is concrete, it has a "
"specified size, storage layout, and (optionally) field names. Thus a bits "
"type is a ``DataType`` with nonzero size, but no field names. A composite "
"type is a ``DataType`` that has field names or is empty (zero size)."
msgstr ""

#: ../../manual/types.rst:547
msgid ""
"Every concrete value in the system is either an instance of some "
"``DataType``, or is a tuple."
msgstr ""

#: ../../manual/types.rst:551
msgid "Tuple Types"
msgstr ""

#: ../../manual/types.rst:553
msgid ""
"Tuples are an abstraction of the arguments of a function — without the "
"function itself. The salient aspects of a function's arguments are their "
"order and their types. The type of a tuple of values is the tuple of types "
"of values:"
msgstr ""

#: ../../manual/types.rst:563
msgid "Accordingly, a tuple of types can be used anywhere a type is expected:"
msgstr ""

#: ../../manual/types.rst:573
msgid ""
"If one of the components of the tuple is not a type, however, you will get "
"an error:"
msgstr ""

#: ../../manual/types.rst:581
msgid "Note that the empty tuple ``()`` is its own type:"
msgstr ""

#: ../../manual/types.rst:588
msgid ""
"Tuple types are *covariant* in their constituent types, which means that one"
" tuple type is a subtype of another if elements of the first are subtypes of"
" the corresponding elements of the second. For example:"
msgstr ""

#: ../../manual/types.rst:604
msgid ""
"Intuitively, this corresponds to the type of a function's arguments being a "
"subtype of the function's signature (when the signature matches)."
msgstr ""

#: ../../manual/types.rst:608
msgid "Type Unions"
msgstr ""

#: ../../manual/types.rst:610
msgid ""
"A type union is a special abstract type which includes as objects all "
"instances of any of its argument types, constructed using the special "
"``Union`` function::"
msgstr ""

#: ../../manual/types.rst:626
msgid ""
"The compilers for many languages have an internal union construct for "
"reasoning about types; Julia simply exposes it to the programmer. The union "
"of no types is the \"bottom\" type, ``None``:"
msgstr ""

#: ../../manual/types.rst:635
msgid ""
"Recall from the `discussion above <#Any+and+None>`_ that ``None`` is the "
"abstract type which is the subtype of all other types, and which no object "
"is an instance of. ``None`` is therefore synonymous with a zero-argument "
"``Union`` type, which has no argument types for objects to be instances of."
msgstr ""

#: ../../manual/types.rst:643
msgid "Parametric Types"
msgstr ""

#: ../../manual/types.rst:645
msgid ""
"An important and powerful feature of Julia's type system is that it is "
"parametric: types can take parameters, so that type declarations actually "
"introduce a whole family of new types — one for each possible combination of"
" parameter values. There are many languages that support some version of "
"`generic programming <http://en.wikipedia.org/wiki/Generic_programming>`_, "
"wherein data structures and algorithms to manipulate them may be specified "
"without specifying the exact types involved. For example, some form of "
"generic programming exists in ML, Haskell, Ada, Eiffel, C++, Java, C#, F#, "
"and Scala, just to name a few. Some of these languages support true "
"parametric polymorphism (e.g. ML, Haskell, Scala), while others support ad-"
"hoc, template-based styles of generic programming (e.g. C++, Java). With so "
"many different varieties of generic programming and parametric types in "
"various languages, we won't even attempt to compare Julia's parametric types"
" to other languages, but will instead focus on explaining Julia's system in "
"its own right. We will note, however, that because Julia is a dynamically "
"typed language and doesn't need to make all type decisions at compile time, "
"many traditional difficulties encountered in static parametric type systems "
"can be relatively easily handled."
msgstr ""

#: ../../manual/types.rst:666
msgid ""
"All declared types (the ``DataType`` variety) can be parameterized, with the"
" same syntax in each case. We will discuss them in the following order: "
"first, parametric composite types, then parametric abstract types, and "
"finally parametric bits types."
msgstr ""

#: ../../manual/types.rst:672
msgid "Parametric Composite Types"
msgstr ""

#: ../../manual/types.rst:682
msgid ""
"Type parameters are introduced immediately after the type name, surrounded "
"by curly braces::"
msgstr ""

#: ../../manual/types.rst:690
msgid ""
"This declaration defines a new parametric type, ``Point{T}``, holding two "
"\"coordinates\" of type ``T``. What, one may ask, is ``T``? Well, that's "
"precisely the point of parametric types: it can be any type at all (or an "
"integer, actually, although here it's clearly used as a type). "
"``Point{Float64}`` is a concrete type equivalent to the type defined by "
"replacing ``T`` in the definition of ``Point`` with ``Float64``. Thus, this "
"single declaration actually declares an unlimited number of types: "
"``Point{Float64}``, ``Point{AbstractString}``, ``Point{Int64}``, etc. Each "
"of these is now a usable concrete type:"
msgstr ""

#: ../../manual/types.rst:708
msgid ""
"The type ``Point{Float64}`` is a point whose coordinates are 64-bit "
"floating-point values, while the type ``Point{AbstractString}`` is a "
"\"point\" whose \"coordinates\" are string objects (see :ref:`man-strings`)."
" However, ``Point`` itself is also a valid type object:"
msgstr ""

#: ../../manual/types.rst:718
msgid ""
"Here the ``T`` is the dummy type symbol used in the original declaration of "
"``Point``. What does ``Point`` by itself mean? It is an abstract type that "
"contains all the specific instances ``Point{Float64}``, "
"``Point{AbstractString}``, etc.:"
msgstr ""

#: ../../manual/types.rst:731
msgid "Other types, of course, are not subtypes of it:"
msgstr ""

#: ../../manual/types.rst:741
msgid ""
"Concrete ``Point`` types with different values of ``T`` are never subtypes "
"of each other:"
msgstr ""

#: ../../manual/types.rst:752
msgid "This last point is very important:"
msgstr ""

#: ../../manual/types.rst:754
msgid ""
"**Even though** ``Float64 <: Real`` **we DO NOT have** ``Point{Float64} <: "
"Point{Real}``\\ **.**"
msgstr ""

#: ../../manual/types.rst:757
msgid ""
"In other words, in the parlance of type theory, Julia's type parameters are "
"*invariant*, rather than being covariant (or even contravariant). This is "
"for practical reasons: while any instance of ``Point{Float64}`` may "
"conceptually be like an instance of ``Point{Real}`` as well, the two types "
"have different representations in memory:"
msgstr ""

#: ../../manual/types.rst:763
msgid ""
"An instance of ``Point{Float64}`` can be represented compactly and "
"efficiently as an immediate pair of 64-bit values;"
msgstr ""

#: ../../manual/types.rst:765
msgid ""
"An instance of ``Point{Real}`` must be able to hold any pair of instances of"
" ``Real``. Since objects that are instances of ``Real`` can be of arbitrary "
"size and structure, in practice an instance of ``Point{Real}`` must be "
"represented as a pair of pointers to individually allocated ``Real`` "
"objects."
msgstr ""

#: ../../manual/types.rst:771
msgid ""
"The efficiency gained by being able to store ``Point{Float64}`` objects with"
" immediate values is magnified enormously in the case of arrays: an "
"``Array{Float64}`` can be stored as a contiguous memory block of 64-bit "
"floating-point values, whereas an ``Array{Real}`` must be an array of "
"pointers to individually allocated ``Real`` objects — which may well be "
"`boxed <http://en.wikipedia.org/wiki/Object_type_%28object-"
"oriented_programming%29#Boxing>`_ 64-bit floating-point values, but also "
"might be arbitrarily large, complex objects, which are declared to be "
"implementations of the ``Real`` abstract type."
msgstr ""

#: ../../manual/types.rst:781
msgid ""
"How does one construct a ``Point`` object? It is possible to define custom "
"constructors for composite types, which will be discussed in detail in :ref"
":`man-constructors`, but in the absence of any special constructor "
"declarations, there are two default ways of creating new composite objects, "
"one in which the type parameters are explicitly given and the other in which"
" they are implied by the arguments to the object constructor."
msgstr ""

#: ../../manual/types.rst:789
msgid ""
"Since the type ``Point{Float64}`` is a concrete type equivalent to ``Point``"
" declared with ``Float64`` in place of ``T``, it can be applied as a "
"constructor accordingly:"
msgstr ""

#: ../../manual/types.rst:801
msgid ""
"For the default constructor, exactly one argument must be supplied for each "
"field:"
msgstr ""

#: ../../manual/types.rst:812
msgid ""
"Only one default constructor is generated for parametric types, since "
"overriding it is not possible. This constructor accepts any arguments and "
"converts them to the field types."
msgstr ""

#: ../../manual/types.rst:816
msgid ""
"In many cases, it is redundant to provide the type of ``Point`` object one "
"wants to construct, since the types of arguments to the constructor call "
"already implicitly provide type information. For that reason, you can also "
"apply ``Point`` itself as a constructor, provided that the implied value of "
"the parameter type ``T`` is unambiguous:"
msgstr ""

#: ../../manual/types.rst:836
msgid ""
"In the case of ``Point``, the type of ``T`` is unambiguously implied if and "
"only if the two arguments to ``Point`` have the same type. When this isn't "
"the case, the constructor will fail with a no method error:"
msgstr ""

#: ../../manual/types.rst:845
msgid ""
"Constructor methods to appropriately handle such mixed cases can be defined,"
" but that will not be discussed until later on in :ref:`man-constructors`."
msgstr ""

#: ../../manual/types.rst:850
msgid "Parametric Abstract Types"
msgstr ""

#: ../../manual/types.rst:852
msgid ""
"Parametric abstract type declarations declare a collection of abstract "
"types, in much the same way::"
msgstr ""

#: ../../manual/types.rst:857
msgid ""
"With this declaration, ``Pointy{T}`` is a distinct abstract type for each "
"type or integer value of ``T``. As with parametric composite types, each "
"such instance is a subtype of ``Pointy``:"
msgstr ""

#: ../../manual/types.rst:869
msgid ""
"Parametric abstract types are invariant, much as parametric composite types "
"are:"
msgstr ""

#: ../../manual/types.rst:880
msgid ""
"Much as plain old abstract types serve to create a useful hierarchy of types"
" over concrete types, parametric abstract types serve the same purpose with "
"respect to parametric composite types. We could, for example, have declared "
"``Point{T}`` to be a subtype of ``Pointy{T}`` as follows::"
msgstr ""

#: ../../manual/types.rst:891
msgid ""
"Given such a declaration, for each choice of ``T``, we have ``Point{T}`` as "
"a subtype of ``Pointy{T}``:"
msgstr ""

#: ../../manual/types.rst:905
msgid "This relationship is also invariant:"
msgstr ""

#: ../../manual/types.rst:912
msgid ""
"What purpose do parametric abstract types like ``Pointy`` serve? Consider if"
" we create a point-like implementation that only requires a single "
"coordinate because the point is on the diagonal line *x = y*::"
msgstr ""

#: ../../manual/types.rst:920
msgid ""
"Now both ``Point{Float64}`` and ``DiagPoint{Float64}`` are implementations "
"of the ``Pointy{Float64}`` abstraction, and similarly for every other "
"possible choice of type ``T``. This allows programming to a common interface"
" shared by all ``Pointy`` objects, implemented for both ``Point`` and "
"``DiagPoint``. This cannot be fully demonstrated, however, until we have "
"introduced methods and dispatch in the next section, :ref:`man-methods`."
msgstr ""

#: ../../manual/types.rst:928
msgid ""
"There are situations where it may not make sense for type parameters to "
"range freely over all possible types. In such situations, one can constrain "
"the range of ``T`` like so::"
msgstr ""

#: ../../manual/types.rst:934
msgid ""
"With such a declaration, it is acceptable to use any type that is a subtype "
"of ``Real`` in place of ``T``, but not types that are not subtypes of "
"``Real``:"
msgstr ""

#: ../../manual/types.rst:956
msgid ""
"Type parameters for parametric composite types can be restricted in the same"
" manner::"
msgstr ""

#: ../../manual/types.rst:964
msgid ""
"To give a real-world example of how all this parametric type machinery can "
"be useful, here is the actual definition of Julia's ``Rational`` immutable "
"type (except that we omit the constructor here for simplicity), representing"
" an exact ratio of integers::"
msgstr ""

#: ../../manual/types.rst:974
msgid ""
"It only makes sense to take ratios of integer values, so the parameter type "
"``T`` is restricted to being a subtype of ``Integer``, and a ratio of "
"integers represents a value on the real number line, so any ``Rational`` is "
"an instance of the ``Real`` abstraction."
msgstr ""

#: ../../manual/types.rst:982
msgid "Singleton Types"
msgstr ""

#: ../../manual/types.rst:984
msgid ""
"There is a special kind of abstract parametric type that must be mentioned "
"here: singleton types. For each type, ``T``, the \"singleton type\" "
"``Type{T}`` is an abstract type whose only instance is the object ``T``. "
"Since the definition is a little difficult to parse, let's look at some "
"examples:"
msgstr ""

#: ../../manual/types.rst:1004
msgid ""
"In other words, ``isa(A,Type{B})`` is true if and only if ``A`` and ``B`` "
"are the same object and that object is a type. Without the parameter, "
"``Type`` is simply an abstract type which has all type objects as its "
"instances, including, of course, singleton types:"
msgstr ""

#: ../../manual/types.rst:1020
msgid "Any object that is not a type is not an instance of ``Type``:"
msgstr ""

#: ../../manual/types.rst:1030
msgid ""
"Until we discuss :ref:`man-parametric-methods` and :ref:`conversions <man-"
"conversion>`, it is difficult to explain the utility of the singleton type "
"construct, but in short, it allows one to specialize function behavior on "
"specific type *values*. This is useful for writing methods (especially "
"parametric ones) whose behavior depends on a type that is given as an "
"explicit argument rather than implied by the type of one of its arguments."
msgstr ""

#: ../../manual/types.rst:1039
msgid ""
"A few popular languages have singleton types, including Haskell, Scala and "
"Ruby. In general usage, the term \"singleton type\" refers to a type whose "
"only instance is a single value. This meaning applies to Julia's singleton "
"types, but with that caveat that only type objects have singleton types."
msgstr ""

#: ../../manual/types.rst:1046
msgid "Parametric Bits Types"
msgstr ""

#: ../../manual/types.rst:1048
msgid ""
"Bits types can also be declared parametrically. For example, pointers are "
"represented as boxed bits types which would be declared in Julia like this::"
msgstr ""

#: ../../manual/types.rst:1058
msgid ""
"The slightly odd feature of these declarations as compared to typical "
"parametric composite types, is that the type parameter ``T`` is not used in "
"the definition of the type itself — it is just an abstract tag, essentially "
"defining an entire family of types with identical structure, differentiated "
"only by their type parameter. Thus, ``Ptr{Float64}`` and ``Ptr{Int64}`` are "
"distinct types, even though they have identical representations. And of "
"course, all specific pointer types are subtype of the umbrella ``Ptr`` type:"
msgstr ""

#: ../../manual/types.rst:1076
msgid "Type Aliases"
msgstr ""

#: ../../manual/types.rst:1078
msgid ""
"Sometimes it is convenient to introduce a new name for an already "
"expressible type. For such occasions, Julia provides the ``typealias`` "
"mechanism. For example, ``UInt`` is type aliased to either ``UInt32`` or "
"``UInt64`` as is appropriate for the size of pointers on the system::"
msgstr ""

#: ../../manual/types.rst:1091
msgid "This is accomplished via the following code in ``base/boot.jl``::"
msgstr ""

#: ../../manual/types.rst:1099
msgid ""
"Of course, this depends on what ``Int`` is aliased to — but that is "
"predefined to be the correct type — either ``Int32`` or ``Int64``."
msgstr ""

#: ../../manual/types.rst:1102
msgid ""
"For parametric types, ``typealias`` can be convenient for providing names "
"for cases where some of the parameter choices are fixed. Julia's arrays have"
" type ``Array{T,N}`` where ``T`` is the element type and ``N`` is the number"
" of array dimensions. For convenience, writing ``Array{Float64}`` allows one"
" to specify the element type without specifying the dimension:"
msgstr ""

#: ../../manual/types.rst:1114
msgid ""
"However, there is no way to equally simply restrict just the dimension but "
"not the element type. Yet, one often needs to ensure an object is a vector "
"or a matrix (imposing restrictions on the number of dimensions). For that "
"reason, the following type aliases are provided::"
msgstr ""

#: ../../manual/types.rst:1122
msgid ""
"Writing ``Vector{Float64}`` is equivalent to writing ``Array{Float64,1}``, "
"and the umbrella type ``Vector`` has as instances all ``Array`` objects "
"where the second parameter — the number of array dimensions — is 1, "
"regardless of what the element type is. In languages where parametric types "
"must always be specified in full, this is not especially helpful, but in "
"Julia, this allows one to write just ``Matrix`` for the abstract type "
"including all two-dimensional dense arrays of any element type."
msgstr ""

#: ../../manual/types.rst:1131
msgid ""
"This declaration of ``Vector`` creates a subtype relation ``Vector{Int} <: "
"Vector``.  However, it is not always the case that a parametric "
"``typealias`` statement creates such a relation; for example, the "
"statement::"
msgstr ""

#: ../../manual/types.rst:1137
msgid ""
"does not create the relation ``AA{Int} <: AA``.  The reason is that "
"``Array{Array{T,1},1}`` is not an abstract type at all; in fact, it is a "
"concrete type describing a 1-dimensional array in which each entry is an "
"object of type ``Array{T,1}`` for some value of ``T``."
msgstr ""

#: ../../manual/types.rst:1143
msgid "Operations on Types"
msgstr ""

#: ../../manual/types.rst:1145
msgid ""
"Since types in Julia are themselves objects, ordinary functions can operate "
"on them. Some functions that are particularly useful for working with or "
"exploring types have already been introduced, such as the ``<:`` operator, "
"which indicates whether its left hand operand is a subtype of its right hand"
" operand."
msgstr ""

#: ../../manual/types.rst:1151
msgid ""
"The ``isa`` function tests if an object is of a given type and returns true "
"or false:"
msgstr ""

#: ../../manual/types.rst:1162
msgid ""
"The ``typeof`` function, already used throughout the manual in examples, "
"returns the type of its argument. Since, as noted above, types are objects, "
"they also have types, and we can ask what their types are:"
msgstr ""

#: ../../manual/types.rst:1177
msgid ""
"What if we repeat the process? What is the type of a type of a type? As it "
"happens, types are all composite values and thus all have a type of "
"``DataType``:"
msgstr ""

#: ../../manual/types.rst:1189
msgid ""
"The reader may note that ``DataType`` shares with the empty tuple (see "
"`above <#tuple-types>`_), the distinction of being its own type (i.e. a "
"fixed point of the ``typeof`` function). This leaves any number of tuple "
"types recursively built with ``()`` and ``DataType`` as their only atomic "
"values, which are their own type:"
msgstr ""

#: ../../manual/types.rst:1212
msgid "All fixed points of the ``typeof`` function are like this."
msgstr ""

#: ../../manual/types.rst:1214
msgid ""
"Another operation that applies to some types is ``super``, which reveals a "
"type's supertype. Only declared types (``DataType``) have unambiguous "
"supertypes:"
msgstr ""

#: ../../manual/types.rst:1232
msgid ""
"If you apply ``super`` to other type objects (or non-type objects), a \"no "
"method\" error is raised::"
msgstr ""

#: ../../manual/types.rst:1245
msgid "Nullable Types: Representing Missing Values"
msgstr ""

#: ../../manual/types.rst:1247
msgid ""
"In many settings, you need to interact with a value of type ``T`` that may "
"or may not exist. To handle these settings, Julia provides a parametric type"
" called ``Nullable{T}``, which can be thought of as a specialized container "
"type that can contain either zero or one values. ``Nullable{T}`` provides a "
"minimal interface designed to ensure that interactions with missing values "
"are safe. At present, the interface consists of four possible interactions:"
msgstr ""

#: ../../manual/types.rst:1254
msgid "Construct a ``Nullable`` object."
msgstr ""

#: ../../manual/types.rst:1255
msgid "Check if an ``Nullable`` object has a missing value."
msgstr ""

#: ../../manual/types.rst:1256
msgid ""
"Access the value of a ``Nullable`` object with a guarantee that a "
"``NullException`` will be thrown if the object's value is missing."
msgstr ""

#: ../../manual/types.rst:1258
msgid ""
"Access the value of a ``Nullable`` object with a guarantee that a default "
"value of type ``T`` will be returned if the object's value is missing."
msgstr ""

#: ../../manual/types.rst:1262
msgid "Constructing ``Nullable`` objects"
msgstr ""

#: ../../manual/types.rst:1264
msgid ""
"To construct an object representing a missing value of type ``T``, use the "
"``Nullable{T}()`` function:"
msgstr ""

#: ../../manual/types.rst:1273
msgid ""
"To construct an object representing a non-missing value of type ``T``, use "
"the ``Nullable(x::T)`` function:"
msgstr ""

#: ../../manual/types.rst:1287
msgid ""
"Note the core distinction between these two ways of constructing a "
"``Nullable`` object: in one style, you provide a type, ``T``, as a function "
"parameter; in the other style, you provide a single value of type ``T`` as "
"an argument."
msgstr ""

#: ../../manual/types.rst:1292
msgid "Checking if an ``Nullable`` object has a value"
msgstr ""

#: ../../manual/types.rst:1294
msgid ""
"You can check if a ``Nullable`` object has any value using the ``isnull`` "
"function:"
msgstr ""

#: ../../manual/types.rst:1306
msgid "Safely accessing the value of an ``Nullable`` object"
msgstr ""

#: ../../manual/types.rst:1308
msgid ""
"You can safely access the value of an ``Nullable`` object using the ``get`` "
"function:"
msgstr ""

#: ../../manual/types.rst:1320
msgid ""
"If the value is not present, as it would be for ``Nullable{Float64}``, a "
"``NullException`` error will be thrown. The error-throwing nature of the "
"``get`` function ensures that any attempt to access a missing value "
"immediately fails."
msgstr ""

#: ../../manual/types.rst:1325
msgid ""
"In cases for which a reasonable default value exists that could be used when"
" a ``Nullable`` object's value turns out to be missing, you can provide this"
" default value as a second argument to ``get``:"
msgstr ""

#: ../../manual/types.rst:1337
msgid ""
"Note that this default value will automatically be converted to the type of "
"the ``Nullable`` object that you attempt to access using the ``get`` "
"function. For example, in the code shown above the value ``0`` would be "
"automatically converted to a ``Float64`` value before being returned. The "
"presence of default replacement values makes it easy to use the ``get`` "
"function to write type-stable code that interacts with sources of "
"potentially missing values."
msgstr ""

#: ../../manual/unicode-input.rst:5
msgid "Unicode Input"
msgstr ""

#: ../../manual/variables.rst:4
msgid "Variables"
msgstr ""

#: ../../manual/variables.rst:6
msgid ""
"A variable, in Julia, is a name associated (or bound) to a value. It's "
"useful when you want to store a value (that you obtained after some math, "
"for example) for later use. For example:"
msgstr ""

#: ../../manual/variables.rst:26
msgid ""
"Julia provides an extremely flexible system for naming variables. Variable "
"names are case-sensitive, and have no semantic meaning (that is, the "
"language will not treat variables differently based on their names)."
msgstr ""

#: ../../manual/variables.rst:55
msgid "Unicode names (in UTF-8 encoding) are allowed:"
msgstr ""

#: ../../manual/variables.rst:69
msgid ""
"In the Julia REPL and several other Julia editing environments, you can type"
" many Unicode math symbols by typing the backslashed LaTeX symbol name "
"followed by tab.  For example, the variable name ``δ`` can be entered by "
"typing ``\\delta``-*tab*, or even ``α̂₂`` by "
"``\\alpha``-*tab*-``\\hat``-*tab*-``\\_2``-*tab*."
msgstr ""

#: ../../manual/variables.rst:79
msgid ""
"Julia will even let you redefine built-in constants and functions if needed:"
msgstr ""

#: ../../manual/variables.rst:100
msgid ""
"However, this is obviously not recommended to avoid potential confusion."
msgstr ""

#: ../../manual/variables.rst:103
msgid "Allowed Variable Names"
msgstr ""

#: ../../manual/variables.rst:105
msgid ""
"Variable names must begin with a letter (A-Z or a-z), underscore, or a "
"subset of Unicode code points greater than 00A0; in particular, `Unicode "
"character categories`_ Lu/Ll/Lt/Lm/Lo/Nl (letters), Sc/So (currency and "
"other symbols), and a few other letter-like characters (e.g. a subset of the"
" Sm math symbols) are allowed. Subsequent characters may also include ! and "
"digits (0-9 and other characters in categories Nd/No), as well as other "
"Unicode code points: diacritics and other modifying marks (categories "
"Mn/Mc/Me/Sk), some punctuation connectors (category Pc), primes, and a few "
"other characters."
msgstr ""

#: ../../manual/variables.rst:116
msgid ""
"Operators like ``+`` are also valid identifiers, but are parsed specially. "
"In some contexts, operators can be used just like variables; for example "
"``(+)`` refers to the addition function, and ``(+) = f`` will reassign it.  "
"Most of the Unicode infix operators (in category Sm), such as ``⊕``, are "
"parsed as infix operators and are available for user-defined methods (e.g. "
"you can use ``const ⊗ = kron`` to define ``⊗`` as an infix Kronecker "
"product)."
msgstr ""

#: ../../manual/variables.rst:124
msgid ""
"The only explicitly disallowed names for variables are the names of built-in"
" statements:"
msgstr ""

#: ../../manual/variables.rst:137
msgid "Stylistic Conventions"
msgstr ""

#: ../../manual/variables.rst:139
msgid ""
"While Julia imposes few restrictions on valid names, it has become useful to"
" adopt the following conventions:"
msgstr ""

#: ../../manual/variables.rst:142
msgid "Names of variables are in lower case."
msgstr ""

#: ../../manual/variables.rst:143
msgid ""
"Word separation can be indicated by underscores (``'_'``), but use of "
"underscores is discouraged unless the name would be hard to read otherwise."
msgstr ""

#: ../../manual/variables.rst:145
msgid ""
"Names of ``Type``\\ s begin with a capital letter and word separation is "
"shown with CamelCase instead of underscores."
msgstr ""

#: ../../manual/variables.rst:147
msgid ""
"Names of ``function``\\ s and ``macro``\\s are in lower case, without "
"underscores."
msgstr ""

#: ../../manual/variables.rst:149
msgid ""
"Functions that write to their arguments have names that end in ``!``. These "
"are sometimes called \"mutating\" or \"in-place\" functions because they are"
" intended to produce changes in their arguments after the function is "
"called, not just return a value."
msgstr ""

#: ../../manual/variables-and-scoping.rst:5
msgid "Scope of Variables"
msgstr ""

#: ../../manual/variables-and-scoping.rst:7
msgid ""
"The *scope* of a variable is the region of code within which a variable is "
"visible. Variable scoping helps avoid variable naming conflicts. The concept"
" is intuitive: two functions can both have arguments called ``x`` without "
"the two ``x``'s referring to the same thing. Similarly there are many other "
"cases where different blocks of code can use the same name without referring"
" to the same thing. The rules for when the same variable name does or "
"doesn't refer to the same thing are called scope rules; this section spells "
"them out in detail."
msgstr ""

#: ../../manual/variables-and-scoping.rst:16
msgid ""
"Certain constructs in the language introduce *scope blocks*, which are "
"regions of code that are eligible to be the scope of some set of variables. "
"The scope of a variable cannot be an arbitrary set of source lines; instead,"
" it will always line up with one of these blocks. The constructs introducing"
" such blocks are:"
msgstr ""

#: ../../manual/variables-and-scoping.rst:22
msgid "``function`` bodies (:ref:`either syntax <man-functions>`)"
msgstr ""

#: ../../manual/variables-and-scoping.rst:23
msgid "``while`` loops"
msgstr ""

#: ../../manual/variables-and-scoping.rst:24
msgid "``for`` loops"
msgstr ""

#: ../../manual/variables-and-scoping.rst:25
msgid "``try`` blocks"
msgstr ""

#: ../../manual/variables-and-scoping.rst:26
msgid "``catch`` blocks"
msgstr ""

#: ../../manual/variables-and-scoping.rst:27
msgid "``let`` blocks"
msgstr ""

#: ../../manual/variables-and-scoping.rst:28
msgid "``type`` blocks."
msgstr ""

#: ../../manual/variables-and-scoping.rst:30
msgid ""
"Notably missing from this list are :ref:`begin blocks <man-compound-"
"expressions>`, which do *not* introduce new scope blocks."
msgstr ""

#: ../../manual/variables-and-scoping.rst:34
msgid ""
"Certain constructs introduce new variables into the current innermost scope."
" When a variable is introduced into a scope, it is also inherited by all "
"inner scopes unless one of those inner scopes explicitly overrides it."
msgstr ""

#: ../../manual/variables-and-scoping.rst:39
msgid ""
"Julia uses `lexical scoping "
"<http://en.wikipedia.org/wiki/Scope_%28computer_science%29#Lexical_scoping_vs._dynamic_scoping>`_,"
" meaning that a function's scope does not inherit from its caller's scope, "
"but from the scope in which the function was defined. For example, in the "
"following code the ``x`` inside ``foo`` is found in the global scope (and if"
" no global variable ``x`` existed, an undefined variable error would be "
"raised)::"
msgstr ""

#: ../../manual/variables-and-scoping.rst:60
msgid ""
"If ``foo`` is instead defined inside ``bar``, then it accesses the local "
"``x`` present in that function::"
msgstr ""

#: ../../manual/variables-and-scoping.rst:76
msgid ""
"The constructs that introduce new variables into the current scope are as "
"follows:"
msgstr ""

#: ../../manual/variables-and-scoping.rst:79
msgid ""
"A declaration ``local x`` or ``const x`` introduces a new local variable."
msgstr ""

#: ../../manual/variables-and-scoping.rst:80
msgid ""
"A declaration ``global x`` makes ``x`` in the current scope and inner scopes"
" refer to the global variable of that name."
msgstr ""

#: ../../manual/variables-and-scoping.rst:82
msgid ""
"A function's arguments are introduced as new local variables into the "
"function's body scope."
msgstr ""

#: ../../manual/variables-and-scoping.rst:84
msgid ""
"An assignment ``x = y`` introduces a new local variable ``x`` only if ``x`` "
"is neither declared global nor introduced as local by any enclosing scope "
"before *or after* the current line of code."
msgstr ""

#: ../../manual/variables-and-scoping.rst:88
msgid ""
"In the following example, there is only one ``x`` assigned both inside and "
"outside the ``for`` loop::"
msgstr ""

#: ../../manual/variables-and-scoping.rst:102
msgid ""
"In the next example, the loop has a separate ``x`` and the function always "
"returns zero::"
msgstr ""

#: ../../manual/variables-and-scoping.rst:117
msgid ""
"In this example, an ``x`` exists only inside the loop, and the function "
"encounters an undefined variable error on its last line (unless there is a "
"global variable ``x``)::"
msgstr ""

#: ../../manual/variables-and-scoping.rst:131
msgid ""
"A variable that is not assigned to or otherwise introduced locally defaults "
"to global, so this function would return the value of the global ``x`` if "
"there were such a variable, or produce an error if no such global existed. "
"As a consequence, the only way to assign to a global variable inside a non-"
"top-level scope is to explicitly declare the variable as global within some "
"scope, since otherwise the assignment would introduce a new local rather "
"than assigning to the global. This rule works out well in practice, since "
"the vast majority of variables assigned inside functions are intended to be "
"local variables, and using global variables should be the exception rather "
"than the rule, and assigning new values to them even more so."
msgstr ""

#: ../../manual/variables-and-scoping.rst:143
msgid ""
"One last example shows that an outer assignment introducing ``x`` need not "
"come before an inner usage::"
msgstr ""

#: ../../manual/variables-and-scoping.rst:155
msgid ""
"This behavior may seem slightly odd for a normal variable, but allows for "
"named functions — which are just normal variables holding function objects —"
" to be used before they are defined. This allows functions to be defined in "
"whatever order is intuitive and convenient, rather than forcing bottom up "
"ordering or requiring forward declarations, both of which one typically sees"
" in C programs. As an example, here is an inefficient, mutually recursive "
"way to test if positive integers are even or odd::"
msgstr ""

#: ../../manual/variables-and-scoping.rst:173
msgid ""
"Julia provides built-in, efficient functions to test this called ``iseven`` "
"and ``isodd`` so the above definitions should only be taken as examples."
msgstr ""

#: ../../manual/variables-and-scoping.rst:177
msgid ""
"Since functions can be used before they are defined, as long as they are "
"defined by the time they are actually called, no syntax for forward "
"declarations is necessary, and definitions can be ordered arbitrarily."
msgstr ""

#: ../../manual/variables-and-scoping.rst:181
msgid ""
"At the interactive prompt, variable scope works the same way as anywhere "
"else. The prompt behaves as if there is scope block wrapped around "
"everything you type, except that this scope block is identified with the "
"global scope. This is especially evident in the case of assignments:"
msgstr ""

#: ../../manual/variables-and-scoping.rst:201
msgid ""
"In the former case, ``y`` only exists inside of the ``for`` loop. In the "
"latter case, an outer ``y`` has been introduced and so is inherited within "
"the loop. Due to the special identification of the prompt's scope block with"
" the global scope, it is not necessary to declare ``global y`` inside the "
"loop. However, in code not entered into the interactive prompt this "
"declaration would be necessary in order to modify a global variable."
msgstr ""

#: ../../manual/variables-and-scoping.rst:209
msgid "Multiple variables can be declared global using the following syntax::"
msgstr ""

#: ../../manual/variables-and-scoping.rst:227
msgid ""
"The ``let`` statement provides a different way to introduce variables. "
"Unlike assignments to local variables, ``let`` statements allocate new "
"variable bindings each time they run. An assignment modifies an existing "
"value location, and ``let`` creates new locations. This difference is "
"usually not important, and is only detectable in the case of variables that "
"outlive their scope via closures. The ``let`` syntax accepts a comma-"
"separated series of assignments and variable names::"
msgstr ""

#: ../../manual/variables-and-scoping.rst:239
msgid ""
"The assignments are evaluated in order, with each right-hand side evaluated "
"in the scope before the new variable on the left-hand side has been "
"introduced. Therefore it makes sense to write something like ``let x = x`` "
"since the two ``x`` variables are distinct and have separate storage. Here "
"is an example where the behavior of ``let`` is needed::"
msgstr ""

#: ../../manual/variables-and-scoping.rst:258
msgid ""
"Here we create and store two closures that return variable ``i``. However, "
"it is always the same variable ``i``, so the two closures behave "
"identically. We can use ``let`` to create a new binding for ``i``::"
msgstr ""

#: ../../manual/variables-and-scoping.rst:278
msgid ""
"Since the ``begin`` construct does not introduce a new scope, it can be "
"useful to use a zero-argument ``let`` to just introduce a new scope block "
"without creating any new bindings:"
msgstr ""

#: ../../manual/variables-and-scoping.rst:302
msgid ""
"The first example is invalid because you cannot declare the same variable as"
" local in the same scope twice. The second example is valid since the "
"``let`` introduces a new scope block, so the inner local ``x`` is a "
"different variable than the outer local ``x``."
msgstr ""

#: ../../manual/variables-and-scoping.rst:308
msgid "For Loops and Comprehensions"
msgstr ""

#: ../../manual/variables-and-scoping.rst:310
msgid ""
"``for`` loops and :ref:`comprehensions <comprehensions>` have a special "
"additional behavior: any new variables introduced in their body scopes are "
"freshly allocated for each loop iteration. Therefore these constructs are "
"similar to ``while`` loops with ``let`` blocks inside::"
msgstr ""

#: ../../manual/variables-and-scoping.rst:326
msgid "``for`` loops will reuse existing variables for iteration::"
msgstr ""

#: ../../manual/variables-and-scoping.rst:333
msgid ""
"However, comprehensions do not do this, and always freshly allocate their "
"iteration variables::"
msgstr ""

#: ../../manual/variables-and-scoping.rst:341
msgid "Constants"
msgstr ""

#: ../../manual/variables-and-scoping.rst:343
msgid ""
"A common use of variables is giving names to specific, unchanging values. "
"Such variables are only assigned once. This intent can be conveyed to the "
"compiler using the ``const`` keyword::"
msgstr ""

#: ../../manual/variables-and-scoping.rst:350
msgid ""
"The ``const`` declaration is allowed on both global and local variables, but"
" is especially useful for globals. It is difficult for the compiler to "
"optimize code involving global variables, since their values (or even their "
"types) might change at almost any time. If a global variable will not "
"change, adding a ``const`` declaration solves this performance problem."
msgstr ""

#: ../../manual/variables-and-scoping.rst:357
msgid ""
"Local constants are quite different. The compiler is able to determine "
"automatically when a local variable is constant, so local constant "
"declarations are not necessary for performance purposes."
msgstr ""

#: ../../manual/variables-and-scoping.rst:361
msgid ""
"Special top-level assignments, such as those performed by the ``function`` "
"and ``type`` keywords, are constant by default."
msgstr ""

#: ../../manual/variables-and-scoping.rst:364
msgid ""
"Note that ``const`` only affects the variable binding; the variable may be "
"bound to a mutable object (such as an array), and that object may still be "
"modified."
msgstr ""
