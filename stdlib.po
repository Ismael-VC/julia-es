# 
msgid ""
msgstr ""
"Project-Id-Version: Julia Language 0.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-12-24 16:27-0600\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../stdlib/base.rst:5
msgid "The Standard Library"
msgstr ""

#: ../../stdlib/base.rst:8
msgid "Introduction"
msgstr ""

#: ../../stdlib/base.rst:10
msgid ""
"The Julia standard library contains a range of functions and macros "
"appropriate for performing scientific and numerical computing, but is also "
"as broad as those of many general purpose programming languages.  Additional"
" functionality is available from a growing collection of available packages."
" Functions are grouped by topic below."
msgstr ""

#: ../../stdlib/base.rst:12
msgid "Some general notes:"
msgstr ""

#: ../../stdlib/base.rst:14
msgid ""
"Except for functions in built-in modules (:mod:`~Base.Pkg`, "
":mod:`~Base.Collections`, :mod:`~Base.Graphics`, :mod:`~Base.Test` and "
":mod:`~Base.Profile`), all functions documented here are directly available "
"for use in programs."
msgstr ""

#: ../../stdlib/base.rst:16
msgid ""
"To use module functions, use ``import Module`` to import the module, and "
"``Module.fn(x)`` to use the functions."
msgstr ""

#: ../../stdlib/base.rst:17
msgid ""
"Alternatively, ``using Module`` will import all exported ``Module`` "
"functions into the current namespace."
msgstr ""

#: ../../stdlib/base.rst:18
msgid ""
"By convention, function names ending with an exclamation point (``!``) "
"modify their arguments.  Some functions have both modifying (e.g., "
"``sort!``) and non-modifying (``sort``) versions."
msgstr ""

#: ../../stdlib/base.rst:21
msgid "Getting Around"
msgstr ""

#: ../../stdlib/base.rst:25
msgid ""
"Quit (or control-D at the prompt). The default exit code is zero, indicating"
" that the processes completed successfully."
msgstr ""

#: ../../stdlib/base.rst:29
msgid ""
"Quit the program indicating that the processes completed successfully. This "
"function calls ``exit(0)`` (see :func:`exit`)."
msgstr ""

#: ../../stdlib/base.rst:33
msgid "Register a zero-argument function to be called at exit."
msgstr ""

#: ../../stdlib/base.rst:37
msgid "Determine whether Julia is running an interactive session."
msgstr ""

#: ../../stdlib/base.rst:41
msgid ""
"Print information about exported global variables in a module, optionally "
"restricted to those matching ``pattern``."
msgstr ""

#: ../../stdlib/base.rst:46
msgid ""
"Edit a file optionally providing a line number to edit at. Returns to the "
"julia prompt when you quit the editor."
msgstr ""

#: ../../stdlib/base.rst:50
msgid ""
"Edit the definition of a function, optionally specifying a tuple of types to"
" indicate which method to edit."
msgstr ""

#: ../../stdlib/base.rst:54
msgid ""
"Evaluates the arguments to the function call, determines their types, and "
"calls the ``edit`` function on the resulting expression"
msgstr ""

#: ../../stdlib/base.rst:58
msgid ""
"Show a file using the default pager, optionally providing a starting line "
"number. Returns to the julia prompt when you quit the pager."
msgstr ""

#: ../../stdlib/base.rst:62
msgid ""
"Show the definition of a function using the default pager, optionally "
"specifying a tuple of types to indicate which method to see."
msgstr ""

#: ../../stdlib/base.rst:66
msgid ""
"Evaluates the arguments to the function call, determines their types, and "
"calls the ``less`` function on the resulting expression"
msgstr ""

#: ../../stdlib/base.rst:70
msgid "Send a printed form of ``x`` to the operating system clipboard (\"copy\")."
msgstr ""

#: ../../stdlib/base.rst:74
msgid ""
"Return a string with the contents of the operating system clipboard "
"(\"paste\")."
msgstr ""

#: ../../stdlib/base.rst:78
msgid ""
"Load source files once, in the context of the ``Main`` module, on every "
"active node, searching standard locations for files. ``require`` is "
"considered a top-level operation, so it sets the current ``include`` path "
"but does not use it to search for files (see help for ``include``). This "
"function is typically used to load library code, and is implicitly called by"
" ``using`` to load packages."
msgstr ""

#: ../../stdlib/base.rst:80
msgid ""
"When searching for files, ``require`` first looks in the current working "
"directory, then looks for package code under ``Pkg.dir()``, then tries paths"
" in the global array ``LOAD_PATH``."
msgstr ""

#: ../../stdlib/base.rst:84
msgid ""
"Like ``require``, except forces loading of files regardless of whether they "
"have been loaded before. Typically used when interactively developing "
"libraries."
msgstr ""

#: ../../stdlib/base.rst:88
msgid ""
"Evaluate the contents of a source file in the current context. During "
"including, a task-local include path is set to the directory containing the "
"file. Nested calls to ``include`` will search relative to that path. All "
"paths refer to files on node 1 when running in parallel, and files will be "
"fetched from node 1. This function is typically used to load source "
"interactively, or to combine files in packages that are broken into multiple"
" source files."
msgstr ""

#: ../../stdlib/base.rst:92
msgid ""
"Like ``include``, except reads code from the given string rather than from a"
" file. Since there is no file path involved, no path processing or fetching "
"from node 1 is done."
msgstr ""

#: ../../stdlib/base.rst:96
msgid "Get help for a function. ``name`` can be an object or a string."
msgstr ""

#: ../../stdlib/base.rst:100
msgid "Search documentation for functions related to ``string``."
msgstr ""

#: ../../stdlib/base.rst:104
msgid ""
"Return the method of ``f`` (a ``Method`` object) that will be called for "
"arguments with the given types."
msgstr ""

#: ../../stdlib/base.rst:108
msgid ""
"Evaluates the arguments to the function call, determines their types, and "
"calls the ``which`` function on the resulting expression"
msgstr ""

#: ../../stdlib/base.rst:112
msgid "Show all methods of ``f`` with their argument types."
msgstr ""

#: ../../stdlib/base.rst:114
msgid ""
"If ``types`` is specified, an array of methods whose types match is "
"returned."
msgstr ""

#: ../../stdlib/base.rst:118
msgid ""
"Return an array of methods with an argument of type ``typ``. If optional "
"``showparents`` is ``true``, also return arguments with a parent type of "
"``typ``, excluding type ``Any``."
msgstr ""

#: ../../stdlib/base.rst:122
msgid ""
"The optional second argument restricts the search to a particular module or "
"function."
msgstr ""

#: ../../stdlib/base.rst:127
msgid "Show an expression and result, returning the result"
msgstr ""

#: ../../stdlib/base.rst:131
msgid ""
"Print information about the version of Julia in use. If the ``verbose`` "
"argument is true, detailed system information is shown as well."
msgstr ""

#: ../../stdlib/base.rst:136
msgid ""
"Replace the top-level module (``Main``) with a new one, providing a clean "
"workspace. The previous ``Main`` module is made available as ``LastMain``. A"
" previously-loaded package can be accessed using a statement such as ``using"
" LastMain.Package``."
msgstr ""

#: ../../stdlib/base.rst:140
msgid "This function should only be used interactively."
msgstr ""

#: ../../stdlib/base.rst:143
msgid "All Objects"
msgstr ""

#: ../../stdlib/base.rst:149
msgid ""
"Determine whether ``x`` and ``y`` are identical, in the sense that no "
"program could distinguish them. Compares mutable objects by address in "
"memory, and compares immutable objects (such as numbers) by contents at the "
"bit level. This function is sometimes called ``egal``."
msgstr ""

#: ../../stdlib/base.rst:153
msgid "Determine whether ``x`` is of the given ``type``."
msgstr ""

#: ../../stdlib/base.rst:157
msgid ""
"Similar to ``==``, except treats all floating-point ``NaN`` values as equal "
"to each other, and treats ``-0.0`` as unequal to ``0.0``. The default "
"implementation of ``isequal`` calls ``==``, so if you have a type that "
"doesn't have these floating-point subtleties then you probably only need to "
"define ``==``."
msgstr ""

#: ../../stdlib/base.rst:161
msgid ""
"``isequal`` is the comparison function used by hash tables (``Dict``). "
"``isequal(x,y)`` must imply that ``hash(x) == hash(y)``."
msgstr ""

#: ../../stdlib/base.rst:164
msgid ""
"This typically means that if you define your own ``==`` function then you "
"must define a corresponding ``hash`` (and vice versa).  Collections "
"typically implement ``isequal`` by calling ``isequal`` recursively on all "
"contents."
msgstr ""

#: ../../stdlib/base.rst:167
msgid ""
"Scalar types generally do not need to implement ``isequal`` separate from "
"``==``, unless they represent floating-point numbers amenable to a more "
"efficient implementation than that provided as a generic fallback (based on "
"``isnan``, ``signbit``, and ``==``)."
msgstr ""

#: ../../stdlib/base.rst:173
msgid ""
"Test whether ``x`` is less than ``y``, according to a canonical total order."
" Values that are normally unordered, such as ``NaN``, are ordered in an "
"arbitrary but consistent fashion. This is the default comparison used by "
"``sort``. Non-numeric types with a canonical total order should implement "
"this function. Numeric types only need to implement it if they have special "
"values such as ``NaN``."
msgstr ""

#: ../../stdlib/base.rst:178
msgid ""
"Return ``x`` if ``condition`` is true, otherwise return ``y``. This differs "
"from ``?`` or ``if`` in that it is an ordinary function, so all the "
"arguments are evaluated first. In some cases, using ``ifelse`` instead of an"
" ``if`` statement can eliminate the branch in generated code and provide "
"higher performance in tight loops."
msgstr ""

#: ../../stdlib/base.rst:186
msgid ""
"Compare ``x`` and ``y`` lexicographically and return -1, 0, or 1 depending "
"on whether ``x`` is less than, equal to, or greater than ``y``, "
"respectively. This function should be defined for lexicographically "
"comparable types, and ``lexless`` will call ``lexcmp`` by default."
msgstr ""

#: ../../stdlib/base.rst:191
msgid "Determine whether ``x`` is lexicographically less than ``y``."
msgstr ""

#: ../../stdlib/base.rst:195
msgid "Get the concrete type of ``x``."
msgstr ""

#: ../../stdlib/base.rst:199
msgid "Construct a tuple of the given objects."
msgstr ""

#: ../../stdlib/base.rst:203
msgid ""
"Create a tuple of length ``n``, computing each element as ``f(i)``, where "
"``i`` is the index of the element."
msgstr ""

#: ../../stdlib/base.rst:207
msgid ""
"Get a unique integer id for ``x``. ``object_id(x)==object_id(y)`` if and "
"only if ``is(x,y)``."
msgstr ""

#: ../../stdlib/base.rst:211
msgid ""
"Compute an integer hash code such that ``isequal(x,y)`` implies "
"``hash(x)==hash(y)``. The optional second argument ``h`` is a hash code to "
"be mixed with the result."
msgstr ""

#: ../../stdlib/base.rst:214
msgid ""
"New types should implement the 2-argument form, typically  by calling the "
"2-argument ``hash`` method recursively in order to mix hashes of the "
"contents with each other (and with ``h``).   Typically, any type that "
"implements ``hash`` should also implement its own ``==`` (hence ``isequal``)"
" to guarantee the property mentioned above."
msgstr ""

#: ../../stdlib/base.rst:218
msgid ""
"Register a function ``f(x)`` to be called when there are no program-"
"accessible references to ``x``. The behavior of this function is "
"unpredictable if ``x`` is of a bits type."
msgstr ""

#: ../../stdlib/base.rst:222
msgid "Immediately run finalizers registered for object ``x``."
msgstr ""

#: ../../stdlib/base.rst:226
msgid ""
"Create a shallow copy of ``x``: the outer structure is copied, but not all "
"internal values. For example, copying an array produces a new array with "
"identically-same elements as the original."
msgstr ""

#: ../../stdlib/base.rst:230
msgid ""
"Create a deep copy of ``x``: everything is copied recursively, resulting in "
"a fully independent object. For example, deep-copying an array produces a "
"new array whose elements are deep copies of the original elements. Calling "
"`deepcopy` on an object should generally have the same effect as serializing"
" and then deserializing it."
msgstr ""

#: ../../stdlib/base.rst:232
msgid ""
"As a special case, functions can only be actually deep-copied if they are "
"anonymous, otherwise they are just copied. The difference is only relevant "
"in the case of closures, i.e. functions which may contain hidden internal "
"references."
msgstr ""

#: ../../stdlib/base.rst:234
msgid ""
"While it isn't normally necessary, user-defined types can override the "
"default ``deepcopy`` behavior by defining a specialized version of the "
"function ``deepcopy_internal(x::T, dict::ObjectIdDict)`` (which shouldn't "
"otherwise be used), where ``T`` is the type to be specialized for, and "
"``dict`` keeps track of objects copied so far within the recursion. Within "
"the definition, ``deepcopy_internal`` should be used in place of "
"``deepcopy``, and the ``dict`` variable should be updated as appropriate "
"before returning."
msgstr ""

#: ../../stdlib/base.rst:238
msgid ""
"Tests whether an assignable location is defined. The arguments can be an "
"array and index, a composite object and field name (as a symbol), or a "
"module and a symbol. With a single symbol argument, tests whether a global "
"variable with that name is defined in ``current_module()``."
msgstr ""

#: ../../stdlib/base.rst:246
msgid "Convert ``x`` to a value of type ``T``."
msgstr ""

#: ../../stdlib/base.rst:248
msgid ""
"If ``T`` is an ``Integer`` type, an ``InexactError`` will be raised if ``x``"
" is not representable by ``T``, for example if ``x`` is not integer-valued, "
"or is outside the range supported by ``T``."
msgstr ""

#: ../../stdlib/base.rst:261
msgid ""
"If ``T`` is a ``FloatingPoint`` or ``Rational`` type, then it will return "
"the closest value to ``x`` representable by ``T``."
msgstr ""

#: ../../stdlib/base.rst:280
msgid ""
"Convert all arguments to their common promotion type (if any), and return "
"them all (as a tuple)."
msgstr ""

#: ../../stdlib/base.rst:284
msgid "Convert ``y`` to the type of ``x`` (``convert(typeof(x), y)``)."
msgstr ""

#: ../../stdlib/base.rst:288
msgid ""
"If the argument is a type, return a \"larger\" type (for numeric types, this"
" will be a type with at least as much range and precision as the argument, "
"and usually more). Otherwise the argument ``x`` is converted to "
"``widen(typeof(x))``."
msgstr ""

#: ../../stdlib/base.rst:304
msgid "The identity function. Returns its argument."
msgstr ""

#: ../../stdlib/base.rst:307
msgid "Types"
msgstr ""

#: ../../stdlib/base.rst:311
msgid "Return the supertype of DataType T"
msgstr ""

#: ../../stdlib/base.rst:315
msgid ""
"True if and only if all values of ``type1`` are also of ``type2``. Can also "
"be written using the ``<:`` infix operator as ``type1 <: type2``."
msgstr ""

#: ../../stdlib/base.rst:319
msgid "Subtype operator, equivalent to ``issubtype(T1,T2)``."
msgstr ""

#: ../../stdlib/base.rst:323
msgid ""
"Return a list of immediate subtypes of DataType T.  Note that all currently "
"loaded subtypes are included, including those not visible in the current "
"module."
msgstr ""

#: ../../stdlib/base.rst:327
msgid ""
"Return a nested list of all subtypes of DataType T.  Note that all currently"
" loaded subtypes are included, including those not visible in the current "
"module."
msgstr ""

#: ../../stdlib/base.rst:331
msgid "The lowest value representable by the given (real) numeric type."
msgstr ""

#: ../../stdlib/base.rst:335
msgid "The highest value representable by the given (real) numeric type."
msgstr ""

#: ../../stdlib/base.rst:339
msgid ""
"The smallest in absolute value non-subnormal value representable by the "
"given floating-point type"
msgstr ""

#: ../../stdlib/base.rst:343
msgid ""
"The highest finite value representable by the given floating-point type"
msgstr ""

#: ../../stdlib/base.rst:347
msgid ""
"The largest integer losslessly representable by the given floating-point "
"type"
msgstr ""

#: ../../stdlib/base.rst:351
msgid ""
"Size, in bytes, of the canonical binary representation of the given type, if"
" any."
msgstr ""

#: ../../stdlib/base.rst:355
msgid ""
"The distance between 1.0 and the next larger representable floating-point "
"value of ``type``. Only floating-point types are sensible arguments. If "
"``type`` is omitted, then ``eps(Float64)`` is returned."
msgstr ""

#: ../../stdlib/base.rst:359
msgid ""
"The distance between ``x`` and the next larger representable floating-point "
"value of the same type as ``x``."
msgstr ""

#: ../../stdlib/base.rst:363
msgid ""
"Determine a type big enough to hold values of each argument type without "
"loss, whenever possible. In some cases, where no type exists to which both "
"types can be promoted losslessly, some loss is tolerated; for example, "
"``promote_type(Int64,Float64)`` returns ``Float64`` even though strictly, "
"not all ``Int64`` values can be represented exactly as ``Float64`` values."
msgstr ""

#: ../../stdlib/base.rst:367
msgid ""
"Specifies what type should be used by ``promote`` when given values of types"
" ``type1`` and ``type2``. This function should not be called directly, but "
"should have definitions added to it for new types as appropriate."
msgstr ""

#: ../../stdlib/base.rst:373
msgid ""
"Extract a named field from a value of composite type. The syntax ``a.b`` "
"calls ``getfield(a, :b)``, and the syntax ``a.(b)`` calls ``getfield(a, "
"b)``."
msgstr ""

#: ../../stdlib/base.rst:378
msgid ""
"Assign ``x`` to a named field in ``value`` of composite type. The syntax "
"``a.b = c`` calls ``setfield!(a, :b, c)``, and the syntax ``a.(b) = c`` "
"calls ``setfield!(a, b, c)``."
msgstr ""

#: ../../stdlib/base.rst:384
msgid ""
"The byte offset of each field of a type relative to the data start. For "
"example, we could use it in the following manner to summarize information "
"about a struct type:"
msgstr ""

#: ../../stdlib/base.rst:408
msgid ""
"Determine the declared type of a field (specified by name or index) in a "
"composite type."
msgstr ""

#: ../../stdlib/base.rst:412
msgid ""
"True if value ``v`` is immutable.  See :ref:`man-immutable-composite-types` "
"for a discussion of immutability. Note that this function works on values, "
"so if you give it a type, it will tell you that a value of ``DataType`` is "
"mutable."
msgstr ""

#: ../../stdlib/base.rst:417
msgid ""
"True if ``T`` is a \"plain data\" type, meaning it is immutable and contains"
" no references to other values. Typical examples are numeric types such as "
"``UInt8``, ``Float64``, and ``Complex{Float64}``."
msgstr ""

#: ../../stdlib/base.rst:429
msgid ""
"Determine whether ``T`` is a concrete type that can have instances, meaning "
"its only subtypes are itself and ``None`` (but ``T`` itself is not "
"``None``)."
msgstr ""

#: ../../stdlib/base.rst:435
msgid "Compute a type that contains both ``T`` and ``S``."
msgstr ""

#: ../../stdlib/base.rst:439
msgid ""
"Compute a type that contains the intersection of ``T`` and ``S``. Usually "
"this will be the smallest such type or one close to it."
msgstr ""

#: ../../stdlib/base.rst:442
msgid "Generic Functions"
msgstr ""

#: ../../stdlib/base.rst:446
msgid ""
"Accepts a function and several arguments, each of which must be iterable. "
"The elements generated by all the arguments are appended into a single list,"
" which is then passed to ``f`` as its argument list."
msgstr ""

#: ../../stdlib/base.rst:459
msgid ""
"``apply`` is called to implement the ``...`` argument splicing syntax, and "
"is usually not called directly: ``apply(f,x) === f(x...)``"
msgstr ""

#: ../../stdlib/base.rst:464
msgid ""
"Determine whether the given generic function has a method matching the given"
" tuple of argument types."
msgstr ""

#: ../../stdlib/base.rst:473
msgid ""
"Determine whether the given generic function has a method applicable to the "
"given arguments."
msgstr ""

#: ../../stdlib/base.rst:489
msgid ""
"Invoke a method for the given generic function matching the specified types "
"(as a tuple), on the specified arguments. The arguments must be compatible "
"with the specified types. This allows invoking a method other than the most "
"specific matching method, which is useful when the behavior of a more "
"general definition is explicitly needed (often as part of the implementation"
" of a more specific method of the same function)."
msgstr ""

#: ../../stdlib/base.rst:493
msgid ""
"Applies a function to the preceding argument. This allows for easy function "
"chaining."
msgstr ""

#: ../../stdlib/base.rst:501
msgid "Syntax"
msgstr ""

#: ../../stdlib/base.rst:505
msgid ""
"Evaluate an expression in the given module and return the result. Every "
"module (except those defined with ``baremodule``) has its own 1-argument "
"definition of ``eval``, which evaluates expressions in that module."
msgstr ""

#: ../../stdlib/base.rst:511
msgid "Evaluate an expression and return the value."
msgstr ""

#: ../../stdlib/base.rst:515
msgid ""
"Evaluate all expressions in the given file, and return the value of the last"
" one. No other processing (path searching, fetching from node 1, etc.) is "
"performed."
msgstr ""

#: ../../stdlib/base.rst:519
msgid ""
"Only valid in the context of an Expr returned from a macro. Prevents the "
"macro hygiene pass from turning embedded variables into gensym variables. "
"See the :ref:`man-macros` section of the Metaprogramming chapter of the "
"manual for more details and examples."
msgstr ""

#: ../../stdlib/base.rst:524
msgid "Generates a symbol which will not conflict with other variable names."
msgstr ""

#: ../../stdlib/base.rst:528
msgid ""
"Generates a gensym symbol for a variable. For example, ``@gensym x y`` is "
"transformed into ``x = gensym(\"x\"); y = gensym(\"y\")``."
msgstr ""

#: ../../stdlib/base.rst:532
msgid ""
"Parse the expression string and return an expression (which could later be "
"passed to eval for execution). Start is the index of the first character to "
"start parsing. If ``greedy`` is true (default), ``parse`` will try to "
"consume as much input as it can; otherwise, it will stop as soon as it has "
"parsed a valid expression. If ``raise`` is true (default), syntax errors "
"will raise an error; otherwise, ``parse`` will return an expression that "
"will raise an error upon evaluation."
msgstr ""

#: ../../stdlib/base.rst:536
msgid ""
"Parse the whole string greedily, returning a single expression.  An error is"
" thrown if there are additional characters after the first expression. If "
"``raise`` is true (default), syntax errors will raise an error; otherwise, "
"``parse`` will return an expression that will raise an error upon "
"evaluation."
msgstr ""

#: ../../stdlib/base.rst:539
msgid "Iteration"
msgstr ""

#: ../../stdlib/base.rst:541
msgid ""
"Sequential iteration is implemented by the methods ``start``, ``done``, and "
"``next``. The general ``for`` loop::"
msgstr ""

#: ../../stdlib/base.rst:548
msgid "is translated to::"
msgstr ""

#: ../../stdlib/base.rst:556
msgid ""
"The ``state`` object may be anything, and should be chosen appropriately for"
" each iterable type."
msgstr ""

#: ../../stdlib/base.rst:560
msgid "Get initial iteration state for an iterable object"
msgstr ""

#: ../../stdlib/base.rst:564
msgid "Test whether we are done iterating"
msgstr ""

#: ../../stdlib/base.rst:568
msgid ""
"For a given iterable object and iteration state, return the current item and"
" the next iteration state"
msgstr ""

#: ../../stdlib/base.rst:572
msgid ""
"For a set of iterable objects, returns an iterable of tuples, where the "
"``i``\\ th tuple contains the ``i``\\ th component of each input iterable."
msgstr ""

#: ../../stdlib/base.rst:574
msgid ""
"Note that ``zip`` is its own inverse: ``[zip(zip(a...)...)...] == [a...]``."
msgstr ""

#: ../../stdlib/base.rst:578
msgid ""
"Return an iterator that yields ``(i, x)`` where ``i`` is an index starting "
"at 1, and ``x`` is the ``i``\\ th value from the given iterator. It's useful"
" when you need not only the values ``x`` over which you are iterating, but "
"also the index ``i`` of the iterations."
msgstr ""

#: ../../stdlib/base.rst:592
msgid ""
"Fully implemented by: ``Range``, ``UnitRange``, ``NDRange``, ``Tuple``, "
"``Real``, ``AbstractArray``, ``IntSet``, ``ObjectIdDict``, ``Dict``, "
"``WeakKeyDict``, ``EachLine``, ``AbstractString``, ``Set``, ``Task``."
msgstr ""

#: ../../stdlib/base.rst:595
msgid "General Collections"
msgstr ""

#: ../../stdlib/base.rst:599
msgid "Determine whether a collection is empty (has no elements)."
msgstr ""

#: ../../stdlib/base.rst:611
msgid "Remove all elements from a ``collection``."
msgstr ""

#: ../../stdlib/base.rst:615
msgid ""
"For ordered, indexable collections, the maximum index ``i`` for which "
"``getindex(collection, i)`` is valid. For unordered collections, the number "
"of elements."
msgstr ""

#: ../../stdlib/base.rst:619
msgid "Returns the last index of the collection."
msgstr ""

#: ../../stdlib/base.rst:626
msgid ""
"Fully implemented by: ``Range``, ``UnitRange``, ``Tuple``, ``Number``, "
"``AbstractArray``, ``IntSet``, ``Dict``, ``WeakKeyDict``, "
"``AbstractString``, ``Set``."
msgstr ""

#: ../../stdlib/base.rst:629
msgid "Iterable Collections"
msgstr ""

#: ../../stdlib/base.rst:637
msgid ""
"Determine whether an item is in the given collection, in the sense that it "
"is ``==`` to one of the values generated by iterating over the collection. "
"Some collections need a slightly different definition; for example Sets "
"check whether the item is ``isequal`` to one of the elements. Dicts look for"
" ``(key,value)`` pairs, and the key is compared using ``isequal``. To test "
"for the presence of a key in a dictionary, use ``haskey`` or ``k in "
"keys(dict)``."
msgstr ""

#: ../../stdlib/base.rst:647
msgid ""
"Determine the type of the elements generated by iterating ``collection``. "
"For associative collections, this will be a ``(key,value)`` tuple type."
msgstr ""

#: ../../stdlib/base.rst:652
msgid ""
"Returns a vector containing the highest index in ``b`` for each value in "
"``a`` that is a member of ``b`` . The output vector contains 0 wherever "
"``a`` is not a member of ``b``."
msgstr ""

#: ../../stdlib/base.rst:658
msgid ""
"Returns the indices of elements in collection ``a`` that appear in "
"collection ``b``"
msgstr ""

#: ../../stdlib/base.rst:662
msgid ""
"Returns an array containing only the unique elements of the iterable "
"``itr``, in the order that the first of each set of equivalent elements "
"originally appears. If ``dim`` is specified, returns unique regions of the "
"array ``itr`` along ``dim``."
msgstr ""

#: ../../stdlib/base.rst:668
msgid ""
"Reduce the given collection ``ìtr`` with the given binary operator ``op``. "
"``v0`` must be a neutral element for ``op`` that will be returned for empty "
"collections. It is unspecified whether ``v0`` is used for non-empty "
"collections."
msgstr ""

#: ../../stdlib/base.rst:673
msgid ""
"Reductions for certain commonly-used operators have special implementations "
"which should be used instead: ``maximum(itr)``, ``minimum(itr)``, "
"``sum(itr)``, ``prod(itr)``, ``any(itr)``, ``all(itr)``."
msgstr ""

#: ../../stdlib/base.rst:678
msgid ""
"The associativity of the reduction is implementation-dependent. This means "
"that you can't use non-associative operations like ``-`` because it is "
"undefined whether ``reduce(-,[1,2,3])`` should be evaluated as ``(1-2)-3`` "
"or ``1-(2-3)``. Use ``foldl`` or ``foldr`` instead for guaranteed left or "
"right associativity."
msgstr ""

#: ../../stdlib/base.rst:684
msgid ""
"Some operations accumulate error, and parallelism will also be easier if the"
" reduction can be executed in groups. Future versions of Julia might change "
"the algorithm. Note that the elements are not reordered if you use an "
"ordered collection."
msgstr ""

#: ../../stdlib/base.rst:691
msgid ""
"Like ``reduce(op, v0, itr)``. This cannot be used with empty collections, "
"except for some special cases (e.g. when ``op`` is one of ``+``, ``*``, "
"``max``, ``min``, ``&``, ``|``) when Julia can determine the neutral element"
" of ``op``."
msgstr ""

#: ../../stdlib/base.rst:698
msgid ""
"Like ``reduce``, but with guaranteed left associativity. ``v0`` will be used"
" exactly once."
msgstr ""

#: ../../stdlib/base.rst:703
msgid ""
"Like ``foldl(op, v0, itr)``, but using the first element of ``itr`` as "
"``v0``. In general, this cannot be used with empty collections (see "
"``reduce(op, itr)``)."
msgstr ""

#: ../../stdlib/base.rst:709
msgid ""
"Like ``reduce``, but with guaranteed right associativity. ``v0`` will be "
"used exactly once."
msgstr ""

#: ../../stdlib/base.rst:714
msgid ""
"Like ``foldr(op, v0, itr)``, but using the last element of ``itr`` as "
"``v0``. In general, this cannot be used with empty collections (see "
"``reduce(op, itr)``)."
msgstr ""

#: ../../stdlib/base.rst:720
msgid "Returns the largest element in a collection."
msgstr ""

#: ../../stdlib/base.rst:724
msgid "Compute the maximum value of an array over the given dimensions."
msgstr ""

#: ../../stdlib/base.rst:728
msgid ""
"Compute the maximum value of ``A`` over the singleton dimensions of ``r``, "
"and write results to ``r``."
msgstr ""

#: ../../stdlib/base.rst:733
msgid "Returns the smallest element in a collection."
msgstr ""

#: ../../stdlib/base.rst:737
msgid "Compute the minimum value of an array over the given dimensions."
msgstr ""

#: ../../stdlib/base.rst:741
msgid ""
"Compute the minimum value of ``A`` over the singleton dimensions of ``r``, "
"and write results to ``r``."
msgstr ""

#: ../../stdlib/base.rst:746
msgid ""
"Compute both the minimum and maximum element in a single pass, and return "
"them as a 2-tuple."
msgstr ""

#: ../../stdlib/base.rst:751
msgid "Returns the index of the maximum element in a collection."
msgstr ""

#: ../../stdlib/base.rst:755
msgid "Returns the index of the minimum element in a collection."
msgstr ""

#: ../../stdlib/base.rst:759
msgid "Returns the maximum element and its index."
msgstr ""

#: ../../stdlib/base.rst:763
msgid ""
"For an array input, returns the value and index of the maximum over the "
"given dimensions."
msgstr ""

#: ../../stdlib/base.rst:768
msgid "Returns the minimum element and its index."
msgstr ""

#: ../../stdlib/base.rst:772
msgid ""
"For an array input, returns the value and index of the minimum over the "
"given dimensions."
msgstr ""

#: ../../stdlib/base.rst:777
msgid "Compute the maximum absolute value of a collection of values."
msgstr ""

#: ../../stdlib/base.rst:781
msgid "Compute the maximum absolute values over given dimensions."
msgstr ""

#: ../../stdlib/base.rst:785
msgid ""
"Compute the maximum absolute values over the singleton dimensions of ``r``, "
"and write values to ``r``."
msgstr ""

#: ../../stdlib/base.rst:790
msgid "Compute the minimum absolute value of a collection of values."
msgstr ""

#: ../../stdlib/base.rst:794
msgid "Compute the minimum absolute values over given dimensions."
msgstr ""

#: ../../stdlib/base.rst:798
msgid ""
"Compute the minimum absolute values over the singleton dimensions of ``r``, "
"and write values to ``r``."
msgstr ""

#: ../../stdlib/base.rst:803
msgid "Returns the sum of all elements in a collection."
msgstr ""

#: ../../stdlib/base.rst:807
msgid "Sum elements of an array over the given dimensions."
msgstr ""

#: ../../stdlib/base.rst:811
msgid ""
"Sum elements of ``A`` over the singleton dimensions of ``r``, and write "
"results to ``r``."
msgstr ""

#: ../../stdlib/base.rst:816
msgid "Sum the results of calling function ``f`` on each element of ``itr``."
msgstr ""

#: ../../stdlib/base.rst:820
msgid ""
"Sum absolute values of all elements in a collection. This is equivalent to "
"`sum(abs(itr))` but faster."
msgstr ""

#: ../../stdlib/base.rst:825
msgid "Sum absolute values of elements of an array over the given dimensions."
msgstr ""

#: ../../stdlib/base.rst:830
msgid ""
"Sum absolute values of elements of ``A`` over the singleton dimensions of "
"``r``, and write results to ``r``."
msgstr ""

#: ../../stdlib/base.rst:835
msgid ""
"Sum squared absolute values of all elements in a collection. This is "
"equivalent to `sum(abs2(itr))` but faster."
msgstr ""

#: ../../stdlib/base.rst:840
msgid ""
"Sum squared absolute values of elements of an array over the given "
"dimensions."
msgstr ""

#: ../../stdlib/base.rst:845
msgid ""
"Sum squared absolute values of elements of ``A`` over the singleton "
"dimensions of ``r``, and write results to ``r``."
msgstr ""

#: ../../stdlib/base.rst:850
msgid "Returns the product of all elements of a collection."
msgstr ""

#: ../../stdlib/base.rst:854
msgid "Multiply elements of an array over the given dimensions."
msgstr ""

#: ../../stdlib/base.rst:858
msgid ""
"Multiply elements of ``A`` over the singleton dimensions of ``r``, and write"
" results to ``r``."
msgstr ""

#: ../../stdlib/base.rst:863
msgid "Test whether any elements of a boolean collection are true."
msgstr ""

#: ../../stdlib/base.rst:867
msgid ""
"Test whether any values along the given dimensions of an array are true."
msgstr ""

#: ../../stdlib/base.rst:871
msgid ""
"Test whether any values in ``A`` along the singleton dimensions of ``r`` are"
" true, and write results to ``r``."
msgstr ""

#: ../../stdlib/base.rst:876
msgid "Test whether all elements of a boolean collection are true."
msgstr ""

#: ../../stdlib/base.rst:880
msgid ""
"Test whether all values along the given dimensions of an array are true."
msgstr ""

#: ../../stdlib/base.rst:884
msgid ""
"Test whether all values in ``A`` along the singleton dimensions of ``r`` are"
" true, and write results to ``r``."
msgstr ""

#: ../../stdlib/base.rst:889
msgid ""
"Count the number of elements in ``itr`` for which predicate ``p`` returns "
"true."
msgstr ""

#: ../../stdlib/base.rst:893
msgid ""
"Determine whether predicate ``p`` returns true for any elements of ``itr``."
msgstr ""

#: ../../stdlib/base.rst:897
msgid ""
"Determine whether predicate ``p`` returns true for all elements of ``itr``."
msgstr ""

#: ../../stdlib/base.rst:906
msgid ""
"Transform collection ``c`` by applying ``f`` to each element. For multiple "
"collection arguments, apply ``f`` elementwise."
msgstr ""

#: ../../stdlib/base.rst:925
msgid "In-place version of :func:`map`."
msgstr ""

#: ../../stdlib/base.rst:929
msgid ""
"Like :func:`map()`, but stores the result in ``destination`` rather than a "
"new collection. ``destination`` must be at least as large as the first "
"collection."
msgstr ""

#: ../../stdlib/base.rst:935
msgid ""
"Apply function ``f`` to each element in ``itr``, and then reduce the result "
"using the binary function ``op``. ``v0`` must be a neutral element for "
"``op`` that will be returned for empty collections. It is unspecified "
"whether ``v0`` is used for non-empty collections."
msgstr ""

#: ../../stdlib/base.rst:941
msgid ""
"``mapreduce`` is functionally equivalent to calling ``reduce(op, v0, map(f, "
"itr))``, but will in general execute faster since no intermediate collection"
" needs to be created. See documentation for ``reduce`` and ``map``."
msgstr ""

#: ../../stdlib/base.rst:951
msgid ""
"The associativity of the reduction is implementation-dependent. Use "
"``mapfoldl`` or ``mapfoldr`` instead for guaranteed left or right "
"associativity."
msgstr ""

#: ../../stdlib/base.rst:957
msgid ""
"Like ``mapreduce(f, op, v0, itr)``. In general, this cannot be used with "
"empty collections (see ``reduce(op, itr)``)."
msgstr ""

#: ../../stdlib/base.rst:962
msgid ""
"Like ``mapreduce``, but with guaranteed left associativity. ``v0`` will be "
"used exactly once."
msgstr ""

#: ../../stdlib/base.rst:967
msgid ""
"Like ``mapfoldl(f, op, v0, itr)``, but using the first element of ``itr`` as"
" ``v0``. In general, this cannot be used with empty collections (see "
"``reduce(op, itr)``)."
msgstr ""

#: ../../stdlib/base.rst:973
msgid ""
"Like ``mapreduce``, but with guaranteed right associativity. ``v0`` will be "
"used exactly once."
msgstr ""

#: ../../stdlib/base.rst:978
msgid ""
"Like ``mapfoldr(f, op, v0, itr)``, but using the first element of ``itr`` as"
" ``v0``. In general, this cannot be used with empty collections (see "
"``reduce(op, itr)``)."
msgstr ""

#: ../../stdlib/base.rst:984
msgid ""
"Get the first element of an iterable collection. Returns the start point of "
"a ``Range`` even if it is empty."
msgstr ""

#: ../../stdlib/base.rst:989
msgid ""
"Get the last element of an ordered collection, if it can be computed in O(1)"
" time. This is accomplished by calling ``endof`` to get the last index. "
"Returns the end point of a ``Range`` even if it is empty."
msgstr ""

#: ../../stdlib/base.rst:995
msgid "Get the step size of a ``Range`` object."
msgstr ""

#: ../../stdlib/base.rst:999
msgid ""
"Return an array of all items in a collection. For associative collections, "
"returns (key, value) tuples."
msgstr ""

#: ../../stdlib/base.rst:1003
msgid ""
"Return an array of type ``Array{element_type,1}`` of all items in a "
"collection."
msgstr ""

#: ../../stdlib/base.rst:1010
msgid ""
"Determine whether every element of ``a`` is also in ``b``, using the ``in`` "
"function."
msgstr ""

#: ../../stdlib/base.rst:1015
msgid ""
"Return a copy of ``collection``, removing elements for which ``function`` is"
" false. For associative collections, the function is passed two arguments "
"(key and value)."
msgstr ""

#: ../../stdlib/base.rst:1020
msgid ""
"Update ``collection``, removing elements for which ``function`` is false. "
"For associative collections, the function is passed two arguments (key and "
"value)."
msgstr ""

#: ../../stdlib/base.rst:1025
msgid "Indexable Collections"
msgstr ""

#: ../../stdlib/base.rst:1029
msgid ""
"Retrieve the value(s) stored at the given key or index within a collection. "
"The syntax ``a[i,j,...]`` is converted by the compiler to ``getindex(a, i, "
"j, ...)``."
msgstr ""

#: ../../stdlib/base.rst:1035
msgid ""
"Store the given value at the given key or index within a collection. The "
"syntax ``a[i,j,...] = x`` is converted by the compiler to ``setindex!(a, x, "
"i, j, ...)``."
msgstr ""

#: ../../stdlib/base.rst:1039
msgid ""
"Fully implemented by: ``Array``, ``DArray``, ``BitArray``, "
"``AbstractArray``, ``SubArray``, ``ObjectIdDict``, ``Dict``, "
"``WeakKeyDict``, ``AbstractString``."
msgstr ""

#: ../../stdlib/base.rst:1041
msgid "Partially implemented by: ``Range``, ``UnitRange``, ``Tuple``."
msgstr ""

#: ../../stdlib/base.rst:1044
msgid "Associative Collections"
msgstr ""

#: ../../stdlib/base.rst:1046
msgid ""
"``Dict`` is the standard associative collection. Its implementation uses the"
" ``hash(x)`` as the hashing function for the key, and ``isequal(x,y)`` to "
"determine equality. Define these two functions for custom types to override "
"how they are stored in a hash table."
msgstr ""

#: ../../stdlib/base.rst:1048
msgid ""
"``ObjectIdDict`` is a special hash table where the keys are always object "
"identities. ``WeakKeyDict`` is a hash table implementation where the keys "
"are weak references to objects, and thus may be garbage collected even when "
"referenced in a hash table."
msgstr ""

#: ../../stdlib/base.rst:1050
msgid ""
"Dicts can be created by passing pair objects constructed with ``=>`` to a "
"``Dict`` constructor: ``Dict(\"A\"=>1, \"B\"=>2)``. This call will attempt "
"to infer type information from the keys and values (i.e. this example "
"creates a ``Dict{ASCIIString, Int64}``). To explicitly specify types use the"
" syntax ``Dict{KeyType,ValueType}(...)``. For example, "
"``Dict{ASCIIString,Int32}(\"A\"=>1, \"B\"=>2)``."
msgstr ""

#: ../../stdlib/base.rst:1054
msgid ""
"As with arrays, ``Dicts`` may be created with comprehensions. For example, "
"``[i => f(i) for i = 1:10]``."
msgstr ""

#: ../../stdlib/base.rst:1057
msgid ""
"Given a dictionary ``D``, the syntax ``D[x]`` returns the value of key ``x``"
" (if it exists) or throws an error, and ``D[x] = y`` stores the key-value "
"pair ``x => y`` in ``D`` (replacing any existing value for the key ``x``).  "
"Multiple arguments to ``D[...]`` are converted to tuples; for example, the "
"syntax ``D[x,y]``  is equivalent to ``D[(x,y)]``, i.e. it refers to the "
"value keyed by the tuple ``(x,y)``."
msgstr ""

#: ../../stdlib/base.rst:1061
msgid ""
"``Dict{K,V}()`` constructs a hash table with keys of type K and values of "
"type V. Given a single iterable argument, constructs a ``Dict`` whose key-"
"value pairs are taken from 2-tuples ``(key,value)`` generated by the "
"argument."
msgstr ""

#: ../../stdlib/base.rst:1065
msgid ""
"Alternatively, a sequence of pair arguments may be passed: "
"``Dict{K,V}(\"A\"=>1, \"B\"=>2)``."
msgstr ""

#: ../../stdlib/base.rst:1070
msgid "Determine whether a collection has a mapping for a given key."
msgstr ""

#: ../../stdlib/base.rst:1074
msgid ""
"Return the value stored for the given key, or the given default value if no "
"mapping for the key is present."
msgstr ""

#: ../../stdlib/base.rst:1078
msgid ""
"Return the value stored for the given key, or if no mapping for the key is "
"present, return ``f()``.  Use ``get!`` to also store the default value in "
"the dictionary."
msgstr ""

#: ../../stdlib/base.rst:1080 ../../stdlib/base.rst:1095
msgid "This is intended to be called using ``do`` block syntax::"
msgstr ""

#: ../../stdlib/base.rst:1089
msgid ""
"Return the value stored for the given key, or if no mapping for the key is "
"present, store ``key => default``, and return ``default``."
msgstr ""

#: ../../stdlib/base.rst:1093
msgid ""
"Return the value stored for the given key, or if no mapping for the key is "
"present, store ``key => f()``, and return ``f()``."
msgstr ""

#: ../../stdlib/base.rst:1104
msgid ""
"Return the key matching argument ``key`` if one exists in ``collection``, "
"otherwise return ``default``."
msgstr ""

#: ../../stdlib/base.rst:1108
msgid ""
"Delete the mapping for the given key in a collection, and return the "
"collection."
msgstr ""

#: ../../stdlib/base.rst:1112
msgid ""
"Delete and return the mapping for ``key`` if it exists in ``collection``, "
"otherwise return ``default``, or throw an error if default is not specified."
msgstr ""

#: ../../stdlib/base.rst:1116
msgid ""
"Return an iterator over all keys in a collection. ``collect(keys(d))`` "
"returns an array of keys."
msgstr ""

#: ../../stdlib/base.rst:1120
msgid ""
"Return an iterator over all values in a collection. ``collect(values(d))`` "
"returns an array of values."
msgstr ""

#: ../../stdlib/base.rst:1124
msgid ""
"Construct a merged collection from the given collections. If necessary, the "
"types of the resulting collection will be promoted to accommodate the types "
"of the merged collections::"
msgstr ""

#: ../../stdlib/base.rst:1145
msgid "Update collection with pairs from the other collections"
msgstr ""

#: ../../stdlib/base.rst:1149
msgid ""
"Suggest that collection ``s`` reserve capacity for at least ``n`` elements. "
"This can improve performance."
msgstr ""

#: ../../stdlib/base.rst:1151
msgid "Fully implemented by: ``ObjectIdDict``, ``Dict``, ``WeakKeyDict``."
msgstr ""

#: ../../stdlib/base.rst:1153
msgid ""
"Partially implemented by: ``IntSet``, ``Set``, ``EnvHash``, ``Array``, "
"``BitArray``."
msgstr ""

#: ../../stdlib/base.rst:1156
msgid "Set-Like Collections"
msgstr ""

#: ../../stdlib/base.rst:1160
msgid ""
"Construct a ``Set`` of the values generated by the given iterable object, or"
" an empty set. Should be used instead of ``IntSet`` for sparse integer sets,"
" or for sets of arbitrary objects."
msgstr ""

#: ../../stdlib/base.rst:1165
msgid ""
"Construct a sorted set of the integers generated by the given iterable "
"object, or an empty set. Implemented as a bit string, and therefore designed"
" for dense integer sets. Only non-negative integers can be stored. If the "
"set will be sparse (for example holding a single very large integer), use "
"``Set`` instead."
msgstr ""

#: ../../stdlib/base.rst:1170
msgid "Construct the union of two or more sets. Maintains order with arrays."
msgstr ""

#: ../../stdlib/base.rst:1174
msgid "Union each element of ``iterable`` into set ``s`` in-place."
msgstr ""

#: ../../stdlib/base.rst:1179
msgid ""
"Construct the intersection of two or more sets. Maintains order and "
"multiplicity of the first argument for arrays and ranges."
msgstr ""

#: ../../stdlib/base.rst:1183
msgid ""
"Construct the set of elements in ``s1`` but not ``s2``. Maintains order with"
" arrays. Note that both arguments must be collections, and both will be "
"iterated over. In particular, ``setdiff(set,element)`` where ``element`` is "
"a potential member of ``set``, will not work in general."
msgstr ""

#: ../../stdlib/base.rst:1190
msgid "Remove each element of ``iterable`` from set ``s`` in-place."
msgstr ""

#: ../../stdlib/base.rst:1194
msgid ""
"Construct the symmetric difference of elements in the passed in sets or "
"arrays. Maintains order with arrays."
msgstr ""

#: ../../stdlib/base.rst:1198
msgid ""
"IntSet s is destructively modified to toggle the inclusion of integer ``n``."
msgstr ""

#: ../../stdlib/base.rst:1202
msgid ""
"For each element in ``itr``, destructively toggle its inclusion in set "
"``s``."
msgstr ""

#: ../../stdlib/base.rst:1206
msgid ""
"Construct the symmetric difference of IntSets ``s1`` and ``s2``, storing the"
" result in ``s1``."
msgstr ""

#: ../../stdlib/base.rst:1210
msgid "Returns the set-complement of IntSet ``s``."
msgstr ""

#: ../../stdlib/base.rst:1214
msgid "Mutates IntSet ``s`` into its set-complement."
msgstr ""

#: ../../stdlib/base.rst:1218
msgid ""
"Intersects IntSets ``s1`` and ``s2`` and overwrites the set ``s1`` with the "
"result. If needed, s1 will be expanded to the size of ``s2``."
msgstr ""

#: ../../stdlib/base.rst:1223
msgid "True if A is a subset of or equal to S."
msgstr ""

#: ../../stdlib/base.rst:1225
msgid "Fully implemented by: ``IntSet``, ``Set``."
msgstr ""

#: ../../stdlib/base.rst:1227
msgid "Partially implemented by: ``Array``."
msgstr ""

#: ../../stdlib/base.rst:1230
msgid "Dequeues"
msgstr ""

#: ../../stdlib/base.rst:1234
msgid "Insert items at the end of a collection."
msgstr ""

#: ../../stdlib/base.rst:1238
msgid "Remove the last item in a collection and return it."
msgstr ""

#: ../../stdlib/base.rst:1242
msgid "Insert items at the beginning of a collection."
msgstr ""

#: ../../stdlib/base.rst:1246
msgid "Remove the first item in a collection."
msgstr ""

#: ../../stdlib/base.rst:1250
msgid "Insert an item at the given index."
msgstr ""

#: ../../stdlib/base.rst:1254
msgid ""
"Remove the item at the given index, and return the modified collection. "
"Subsequent items are shifted to fill the resulting gap."
msgstr ""

#: ../../stdlib/base.rst:1259
msgid ""
"Remove the items at the indices given by ``itr``, and return the modified "
"collection. Subsequent items are shifted to fill the resulting gap.  ``itr``"
" must be sorted and unique."
msgstr ""

#: ../../stdlib/base.rst:1264
msgid ""
"Remove the item at the given index, and return the removed item. Subsequent "
"items are shifted down to fill the resulting gap. If specified, replacement "
"values from an ordered collection will be spliced in place of the removed "
"item."
msgstr ""

#: ../../stdlib/base.rst:1268 ../../stdlib/base.rst:1277
msgid ""
"To insert ``replacement`` before an index ``n`` without removing any items, "
"use ``splice!(collection, n:n-1, replacement)``."
msgstr ""

#: ../../stdlib/base.rst:1272
msgid ""
"Remove items in the specified index range, and return a collection "
"containing the removed items. Subsequent items are shifted down to fill the "
"resulting gap. If specified, replacement values from an ordered collection "
"will be spliced in place of the removed items."
msgstr ""

#: ../../stdlib/base.rst:1281
msgid ""
"Resize collection to contain ``n`` elements. If ``n`` is smaller than the "
"current collection length, the first ``n`` elements will be retained. If "
"``n`` is larger, the new elements will not be initialized."
msgstr ""

#: ../../stdlib/base.rst:1287
msgid "Add the elements of ``items`` to the end of a collection."
msgstr ""

#: ../../stdlib/base.rst:1299
msgid "Insert the elements of ``items`` to the beginning of a collection."
msgstr ""

#: ../../stdlib/base.rst:1309
msgid ""
"Fully implemented by: ``Vector`` (aka 1-d ``Array``), ``BitVector`` (aka 1-d"
" ``BitArray``)."
msgstr ""

#: ../../stdlib/base.rst:1312
msgid "Nullables"
msgstr ""

#: ../../stdlib/base.rst:1316
msgid ""
"Attempt to access the value of the ``Nullable`` object, ``x``. Returns the "
"value if it is present; otherwise, throws a ``NullException``."
msgstr ""

#: ../../stdlib/base.rst:1321
msgid ""
"Attempt to access the value of the ``Nullable{T}`` object, ``x``. Returns "
"the value if it is present; otherwise, returns ``convert(T, y)``."
msgstr ""

#: ../../stdlib/base.rst:1326
msgid "Is the ``Nullable`` object ``x`` null, i.e. missing a value?"
msgstr ""

#: ../../stdlib/base.rst:1329
msgid "Strings"
msgstr ""

#: ../../stdlib/base.rst:1333
msgid "The number of characters in string ``s``."
msgstr ""

#: ../../stdlib/base.rst:1337
msgid "The number of bytes in string ``s``."
msgstr ""

#: ../../stdlib/base.rst:1341
msgid "Concatenate strings. The ``*`` operator is an alias to this function."
msgstr ""

#: ../../stdlib/base.rst:1350
msgid ""
"Repeat ``n`` times the string ``s``. The ``^`` operator is an alias to this "
"function."
msgstr ""

#: ../../stdlib/base.rst:1359
msgid "Create a string from any values using the ``print`` function."
msgstr ""

#: ../../stdlib/base.rst:1363
msgid "Create a string from any value using the ``showall`` function."
msgstr ""

#: ../../stdlib/base.rst:1367
msgid ""
"Create a string from the address of a C (0-terminated) string encoded in "
"ASCII or UTF-8. A copy is made; the ptr can be safely freed. If ``length`` "
"is specified, the string does not have to be 0-terminated."
msgstr ""

#: ../../stdlib/base.rst:1371
msgid ""
"Convert a string to a contiguous byte array representation appropriate for "
"passing it to C functions. The string will be encoded as either ASCII or "
"UTF-8."
msgstr ""

#: ../../stdlib/base.rst:1375
msgid "Create an ASCII string from a byte array."
msgstr ""

#: ../../stdlib/base.rst:1379
msgid ""
"Convert a string to a contiguous ASCII string (all characters must be valid "
"ASCII characters)."
msgstr ""

#: ../../stdlib/base.rst:1383
msgid "Create a UTF-8 string from a byte array."
msgstr ""

#: ../../stdlib/base.rst:1387
msgid ""
"Convert a string to a contiguous UTF-8 string (all characters must be valid "
"UTF-8 characters)."
msgstr ""

#: ../../stdlib/base.rst:1391
msgid ""
"Normalize the string ``s`` according to one of the four \"normal forms\" of "
"the Unicode standard: ``normalform`` can be ``:NFC``, ``:NFD``, ``:NFKC``, "
"or ``:NFKD``.  Normal forms C (canonical composition) and D (canonical "
"decomposition) convert different visually identical representations of the "
"same abstract string into a single canonical form, with form C being more "
"compact.  Normal forms KC and KD additionally canonicalize \"compatibility "
"equivalents\": they convert characters that are abstractly similar but "
"visually distinct into a single canonical choice (e.g. they expand ligatures"
" into the individual characters), with form KC being more compact."
msgstr ""

#: ../../stdlib/base.rst:1402
msgid ""
"Alternatively, finer control and additional transformations may be be "
"obtained by calling `normalize_string(s; keywords...)`, where any number of "
"the following boolean keywords options (which all default to ``false`` "
"except for ``compose``) are specified:"
msgstr ""

#: ../../stdlib/base.rst:1407
msgid "``compose=false``: do not perform canonical composition"
msgstr ""

#: ../../stdlib/base.rst:1408
msgid ""
"``decompose=true``: do canonical decomposition instead of canonical "
"composition (``compose=true`` is ignored if present)"
msgstr ""

#: ../../stdlib/base.rst:1409
msgid "``compat=true``: compatibility equivalents are canonicalized"
msgstr ""

#: ../../stdlib/base.rst:1410
msgid ""
"``casefold=true``: perform Unicode case folding, e.g. for case-insensitive "
"string comparison"
msgstr ""

#: ../../stdlib/base.rst:1411
msgid ""
"``newline2lf=true``, ``newline2ls=true``, or ``newline2ps=true``: convert "
"various newline sequences (LF, CRLF, CR, NEL) into a linefeed (LF), line-"
"separation (LS), or paragraph-separation (PS) character, respectively"
msgstr ""

#: ../../stdlib/base.rst:1412
msgid "``stripmark=true``: strip diacritical marks (e.g. accents)"
msgstr ""

#: ../../stdlib/base.rst:1413
msgid ""
"``stripignore=true``: strip Unicode's \"default ignorable\" characters (e.g."
" the soft hyphen or the left-to-right marker)"
msgstr ""

#: ../../stdlib/base.rst:1414
msgid ""
"``stripcc=true``: strip control characters; horizontal tabs and form feeds "
"are converted to spaces; newlines are also converted to spaces unless a "
"newline-conversion flag was specified"
msgstr ""

#: ../../stdlib/base.rst:1415
msgid "``rejectna=true``: throw an error if unassigned code points are found"
msgstr ""

#: ../../stdlib/base.rst:1416
msgid "``stable=true``: enforce Unicode Versioning Stability"
msgstr ""

#: ../../stdlib/base.rst:1418
msgid ""
"For example, NFKC corresponds to the options ``compose=true, compat=true, "
"stable=true``."
msgstr ""

#: ../../stdlib/base.rst:1422
msgid ""
"Returns an iterator over substrings of ``s`` that correspond to the extended"
" graphemes in the string, as defined by Unicode UAX #29. (Roughly, these are"
" what users would perceive as single characters,"
msgstr ""

#: ../../stdlib/base.rst:1425
msgid ""
"even though they may contain more than one codepoint; for example a letter "
"combined with an accent mark is a single grapheme.)"
msgstr ""

#: ../../stdlib/base.rst:1430
msgid ""
"Returns true if the argument (``ASCIIString``, ``UTF8String``, or byte "
"vector) is valid ASCII, false otherwise."
msgstr ""

#: ../../stdlib/base.rst:1434
msgid ""
"Returns true if the argument (``ASCIIString``, ``UTF8String``, or byte "
"vector) is valid UTF-8, false otherwise."
msgstr ""

#: ../../stdlib/base.rst:1438
msgid ""
"Returns true if the given char or integer is a valid Unicode code point."
msgstr ""

#: ../../stdlib/base.rst:1442
msgid ""
"Returns true if the given char or integer is an assigned Unicode code point."
msgstr ""

#: ../../stdlib/base.rst:1446
msgid ""
"Test whether a string contains a match of the given regular expression."
msgstr ""

#: ../../stdlib/base.rst:1450
msgid ""
"Search for the first match of the regular expression ``r`` in ``s`` and "
"return a RegexMatch object containing the match, or nothing if the match "
"failed. The matching substring can be retrieved by accessing ``m.match`` and"
" the captured sequences can be retrieved by accessing ``m.captures`` The "
"optional ``idx`` argument specifies an index at which to start the search."
msgstr ""

#: ../../stdlib/base.rst:1454
msgid ""
"Search for all matches of a the regular expression ``r`` in ``s`` and return"
" a iterator over the matches. If overlap is true, the matching sequences are"
" allowed to overlap indices in the original string, otherwise they must be "
"from distinct character ranges."
msgstr ""

#: ../../stdlib/base.rst:1458
msgid "Return a vector of the matching substrings from eachmatch."
msgstr ""

#: ../../stdlib/base.rst:1462
msgid ""
"Make a string at least ``n`` characters long by padding on the left with "
"copies of ``p``."
msgstr ""

#: ../../stdlib/base.rst:1466
msgid ""
"Make a string at least ``n`` characters long by padding on the right with "
"copies of ``p``."
msgstr ""

#: ../../stdlib/base.rst:1470
msgid ""
"Search for the first occurrence of the given characters within the given "
"string. The second argument may be a single character, a vector or a set of "
"characters, a string, or a regular expression (though regular expressions "
"are only allowed on contiguous strings, such as ASCII or UTF-8 strings). The"
" third argument optionally specifies a starting index. The return value is a"
" range of indexes where the matching sequence is found, such that "
"``s[search(s,x)] == x``:"
msgstr ""

#: ../../stdlib/base.rst:1472
msgid ""
"``search(string, \"substring\")`` = ``start:end`` such that "
"``string[start:end] == \"substring\"``, or ``0:-1`` if unmatched."
msgstr ""

#: ../../stdlib/base.rst:1474
msgid ""
"``search(string, 'c')``         = ``index`` such that ``string[index] == "
"'c'``, or ``0`` if unmatched."
msgstr ""

#: ../../stdlib/base.rst:1478
msgid ""
"Similar to ``search``, but returning the last occurrence of the given "
"characters within the given string, searching in reverse from ``start``."
msgstr ""

#: ../../stdlib/base.rst:1482
msgid ""
"Similar to ``search``, but return only the start index at which the "
"substring is found, or 0 if it is not."
msgstr ""

#: ../../stdlib/base.rst:1486
msgid ""
"Similar to ``rsearch``, but return only the start index at which the "
"substring is found, or 0 if it is not."
msgstr ""

#: ../../stdlib/base.rst:1490
msgid "Determine whether the second argument is a substring of the first."
msgstr ""

#: ../../stdlib/base.rst:1494
msgid ""
"Search for the given pattern ``pat``, and replace each occurrence with "
"``r``. If ``n`` is provided, replace at most ``n`` occurrences.  As with "
"search, the second argument may be a single character, a vector or a set of "
"characters, a string, or a regular expression. If ``r`` is a function, each "
"occurrence is replaced with ``r(s)`` where ``s`` is the matched substring."
msgstr ""

#: ../../stdlib/base.rst:1498
msgid ""
"Return an array of substrings by splitting the given string on occurrences "
"of the given character delimiters, which may be specified in any of the "
"formats allowed by ``search``'s second argument (i.e. a single character, "
"collection of characters, string, or regular expression). If ``chars`` is "
"omitted, it defaults to the set of all space characters, and ``keep`` is "
"taken to be false. The two keyword arguments are optional: they are are a "
"maximum size for the result and a flag determining whether empty fields "
"should be kept in the result."
msgstr ""

#: ../../stdlib/base.rst:1502
msgid "Similar to ``split``, but starting from the end of the string."
msgstr ""

#: ../../stdlib/base.rst:1506
msgid ""
"Return ``string`` with any leading and trailing whitespace removed. If "
"``chars`` (a character, or vector or set of characters) is provided, instead"
" remove characters contained in it."
msgstr ""

#: ../../stdlib/base.rst:1510
msgid ""
"Return ``string`` with any leading whitespace removed. If ``chars`` (a "
"character, or vector or set of characters) is provided, instead remove "
"characters contained in it."
msgstr ""

#: ../../stdlib/base.rst:1514
msgid ""
"Return ``string`` with any trailing whitespace removed. If ``chars`` (a "
"character, or vector or set of characters) is provided, instead remove "
"characters contained in it."
msgstr ""

#: ../../stdlib/base.rst:1518
msgid ""
"Returns ``true`` if ``string`` starts with ``prefix``. If the second "
"argument is a vector or set of characters, tests whether the first character"
" of ``string`` belongs to that set."
msgstr ""

#: ../../stdlib/base.rst:1522
msgid ""
"Returns ``true`` if ``string`` ends with ``suffix``. If the second argument "
"is a vector or set of characters, tests whether the last character of "
"``string`` belongs to that set."
msgstr ""

#: ../../stdlib/base.rst:1526
msgid "Returns ``string`` with all characters converted to uppercase."
msgstr ""

#: ../../stdlib/base.rst:1530
msgid "Returns ``string`` with all characters converted to lowercase."
msgstr ""

#: ../../stdlib/base.rst:1534
msgid "Returns ``string`` with the first character converted to uppercase."
msgstr ""

#: ../../stdlib/base.rst:1538
msgid "Returns ``string`` with the first character converted to lowercase."
msgstr ""

#: ../../stdlib/base.rst:1542
msgid ""
"Join an array of ``strings`` into a single string, inserting the given "
"delimiter between adjacent strings. If ``last`` is given, it will be used "
"instead of ``delim`` between the last two strings. For example, "
"``join([\"apples\", \"bananas\", \"pineapples\"], \", \", \" and \") == "
"\"apples, bananas and pineapples\"``."
msgstr ""

#: ../../stdlib/base.rst:1546
msgid ""
"``strings`` can be any iterable over elements ``x`` which are convertible to"
" strings via ``print(io::IOBuffer, x)``."
msgstr ""

#: ../../stdlib/base.rst:1550
msgid "Remove the last character from a string"
msgstr ""

#: ../../stdlib/base.rst:1554
msgid "Remove a trailing newline from a string"
msgstr ""

#: ../../stdlib/base.rst:1558
msgid "Convert a byte index to a character index"
msgstr ""

#: ../../stdlib/base.rst:1562
msgid "Convert a character index to a byte index"
msgstr ""

#: ../../stdlib/base.rst:1566
msgid "Tells whether index ``i`` is valid for the given string"
msgstr ""

#: ../../stdlib/base.rst:1570
msgid ""
"Get the next valid string index after ``i``. Returns a value greater than "
"``endof(str)`` at or after the end of the string."
msgstr ""

#: ../../stdlib/base.rst:1575
msgid ""
"Get the previous valid string index before ``i``. Returns a value less than "
"``1`` at the beginning of the string."
msgstr ""

#: ../../stdlib/base.rst:1580
msgid ""
"Create a random ASCII string of length ``len``, consisting of upper- and "
"lower-case letters and the digits 0-9"
msgstr ""

#: ../../stdlib/base.rst:1584
msgid "Gives the number of columns needed to print a character."
msgstr ""

#: ../../stdlib/base.rst:1588
msgid "Gives the number of columns needed to print a string."
msgstr ""

#: ../../stdlib/base.rst:1592
msgid ""
"Tests whether a character is alphanumeric, or whether this is true for all "
"elements of a string.  A character is classified as alphabetic if it belongs"
" to the Unicode general category Letter or Number, i.e. a character whose "
"category code begins with 'L' or 'N'."
msgstr ""

#: ../../stdlib/base.rst:1599
msgid ""
"Tests whether a character is alphabetic, or whether this is true for all "
"elements of a string. A character is classified as alphabetic if it belongs "
"to the Unicode general category Letter, i.e. a character whose category code"
" begins with 'L'."
msgstr ""

#: ../../stdlib/base.rst:1606
msgid ""
"Tests whether a character belongs to the ASCII character set, or whether "
"this is true for all elements of a string."
msgstr ""

#: ../../stdlib/base.rst:1611
msgid ""
"Tests whether a character is a control character, or whether this is true "
"for all elements of a string.  Control characters are the non-printing "
"characters of the Latin-1 subset of Unicode."
msgstr ""

#: ../../stdlib/base.rst:1617
msgid ""
"Tests whether a character is a numeric digit (0-9), or whether this is true "
"for all elements of a string."
msgstr ""

#: ../../stdlib/base.rst:1622
msgid ""
"Tests whether a character is printable, and not a space, or whether this is "
"true for all elements of a string.  Any character that would cause a printer"
" to use ink should be classified with isgraph(c)==true."
msgstr ""

#: ../../stdlib/base.rst:1628
msgid ""
"Tests whether a character is a lowercase letter, or whether this is true for"
" all elements of a string.  A character is classified as lowercase if it "
"belongs to Unicode category Ll, Letter: Lowercase."
msgstr ""

#: ../../stdlib/base.rst:1634
msgid ""
"Tests whether a character is numeric, or whether this is true for all "
"elements of a string.   A character is classified as numeric if it belongs "
"to the Unicode general category Number, i.e. a character whose category code"
" begins with 'N'."
msgstr ""

#: ../../stdlib/base.rst:1641
msgid ""
"Tests whether a character is printable, including spaces, but not a control "
"character. For strings, tests whether this is true for all elements of the "
"string."
msgstr ""

#: ../../stdlib/base.rst:1645
msgid ""
"Tests whether a character belongs to the Unicode general category "
"Punctuation, i.e. a character whose category code begins with 'P'. For "
"strings, tests whether this is true for all elements of the string."
msgstr ""

#: ../../stdlib/base.rst:1649
msgid ""
"Tests whether a character is any whitespace character.  Includes ASCII "
"characters '\\\\t', '\\\\n', '\\\\v', '\\\\f', '\\\\r', and ' ', Latin-1 "
"character U+0085, and characters in Unicode category Zs.  For strings, tests"
" whether this    is true for all elements of the string."
msgstr ""

#: ../../stdlib/base.rst:1653
msgid ""
"Tests whether a character is an uppercase letter, or whether this is true "
"for all elements of a string.    A character is classified as uppercase if "
"it belongs to Unicode category Lu, Letter: Uppercase, or Lt, Letter: "
"Titlecase."
msgstr ""

#: ../../stdlib/base.rst:1659
msgid ""
"Tests whether a character is a valid hexadecimal digit, or whether this is "
"true for all elements of a string."
msgstr ""

#: ../../stdlib/base.rst:1664
msgid "Convert a string to a ``Symbol``."
msgstr ""

#: ../../stdlib/base.rst:1668
msgid ""
"General escaping of traditional C and Unicode escape sequences. See "
":func:`print_escaped` for more general escaping."
msgstr ""

#: ../../stdlib/base.rst:1672
msgid ""
"General unescaping of traditional C and Unicode escape sequences. Reverse of"
" :func:`escape_string`. See also :func:`print_unescaped`."
msgstr ""

#: ../../stdlib/base.rst:1676
msgid ""
"Create a UTF-16 string from a byte array, array of ``UInt16``, or any other "
"string type.  (Data must be valid UTF-16.  Conversions of byte arrays check "
"for a byte-order marker in the first two bytes, and do not include it in the"
" resulting string.)"
msgstr ""

#: ../../stdlib/base.rst:1681
msgid ""
"Note that the resulting ``UTF16String`` data is terminated by the NUL "
"codepoint (16-bit zero), which is not treated as a character in the string "
"(so that it is mostly invisible in Julia); this allows the string to be "
"passed directly to external functions requiring NUL-terminated data.  This "
"NUL is appended automatically by the `utf16(s)` conversion function.  If you"
" have a ``UInt16`` array ``A`` that is already NUL-terminated valid UTF-16 "
"data, then you can instead use `UTF16String(A)`` to construct the string "
"without making a copy of the data and treating the NUL as a terminator "
"rather than as part of the string."
msgstr ""

#: ../../stdlib/base.rst:1694
msgid ""
"Create a string from the address of a NUL-terminated UTF-16 string. A copy "
"is made; the pointer can be safely freed. If ``length`` is specified, the "
"string does not have to be NUL-terminated."
msgstr ""

#: ../../stdlib/base.rst:1698
msgid ""
"Returns true if the argument (``UTF16String`` or ``UInt16`` array) is valid "
"UTF-16."
msgstr ""

#: ../../stdlib/base.rst:1702
msgid ""
"Create a UTF-32 string from a byte array, array of ``UInt32``, or any other "
"string type.  (Conversions of byte arrays check for a byte-order marker in "
"the first four bytes, and do not include it in the resulting string.)"
msgstr ""

#: ../../stdlib/base.rst:1707
msgid ""
"Note that the resulting ``UTF32String`` data is terminated by the NUL "
"codepoint (32-bit zero), which is not treated as a character in the string "
"(so that it is mostly invisible in Julia); this allows the string to be "
"passed directly to external functions requiring NUL-terminated data.  This "
"NUL is appended automatically by the `utf32(s)` conversion function.  If you"
" have a ``UInt32`` array ``A`` that is already NUL-terminated UTF-32 data, "
"then you can instead use `UTF32String(A)`` to construct the string without "
"making a copy of the data and treating the NUL as a terminator rather than "
"as part of the string."
msgstr ""

#: ../../stdlib/base.rst:1720
msgid ""
"Create a string from the address of a NUL-terminated UTF-32 string. A copy "
"is made; the pointer can be safely freed. If ``length`` is specified, the "
"string does not have to be NUL-terminated."
msgstr ""

#: ../../stdlib/base.rst:1724
msgid ""
"This is a synonym for either ``utf32(s)`` or ``utf16(s)``, depending on "
"whether ``Cwchar_t`` is 32 or 16 bits, respectively. The synonym ``WString``"
" for ``UTF32String`` or ``UTF16String`` is also provided."
msgstr ""

#: ../../stdlib/base.rst:1730
msgid "I/O"
msgstr ""

#: ../../stdlib/base.rst:1734
msgid "Global variable referring to the standard out stream."
msgstr ""

#: ../../stdlib/base.rst:1738
msgid "Global variable referring to the standard error stream."
msgstr ""

#: ../../stdlib/base.rst:1742
msgid "Global variable referring to the standard input stream."
msgstr ""

#: ../../stdlib/base.rst:1746
msgid ""
"Open a file in a mode specified by five boolean arguments. The default is to"
" open files for reading only. Returns a stream for accessing the file."
msgstr ""

#: ../../stdlib/base.rst:1750
msgid ""
"Alternate syntax for open, where a string-based mode specifier is used "
"instead of the five booleans. The values of ``mode`` correspond to those "
"from ``fopen(3)`` or Perl ``open``, and are equivalent to setting the "
"following boolean groups:"
msgstr ""

#: ../../stdlib/base.rst:1753
msgid "r"
msgstr ""

#: ../../stdlib/base.rst:1753
msgid "read"
msgstr ""

#: ../../stdlib/base.rst:1754
msgid "r+"
msgstr ""

#: ../../stdlib/base.rst:1754
msgid "read, write"
msgstr ""

#: ../../stdlib/base.rst:1755
msgid "w"
msgstr ""

#: ../../stdlib/base.rst:1755
msgid "write, create, truncate"
msgstr ""

#: ../../stdlib/base.rst:1756
msgid "w+"
msgstr ""

#: ../../stdlib/base.rst:1756
msgid "read, write, create, truncate"
msgstr ""

#: ../../stdlib/base.rst:1757
msgid "a"
msgstr ""

#: ../../stdlib/base.rst:1757
msgid "write, create, append"
msgstr ""

#: ../../stdlib/base.rst:1758
msgid "a+"
msgstr ""

#: ../../stdlib/base.rst:1758
msgid "read, write, create, append"
msgstr ""

#: ../../stdlib/base.rst:1764
msgid ""
"Apply the function ``f`` to the result of ``open(args...)`` and close the "
"resulting file descriptor upon completion."
msgstr ""

#: ../../stdlib/base.rst:1766
msgid "**Example**: ``open(readall, \"file.txt\")``"
msgstr ""

#: ../../stdlib/base.rst:1770
msgid "Create an in-memory I/O stream."
msgstr ""

#: ../../stdlib/base.rst:1774
msgid "Create a fixed size IOBuffer. The buffer will not grow dynamically."
msgstr ""

#: ../../stdlib/base.rst:1778
msgid "Create a read-only IOBuffer on the data underlying the given string"
msgstr ""

#: ../../stdlib/base.rst:1782
msgid ""
"Create an IOBuffer, which may optionally operate on a pre-existing array. If"
" the readable/writable arguments are given, they restrict whether or not the"
" buffer may be read from or written to respectively. By default the buffer "
"is readable but not writable. The last argument optionally specifies a size "
"beyond which the buffer may not be grown."
msgstr ""

#: ../../stdlib/base.rst:1788
msgid ""
"Obtain the contents of an ``IOBuffer`` as an array, without copying. "
"Afterwards, the IOBuffer is reset to its initial state."
msgstr ""

#: ../../stdlib/base.rst:1792
msgid ""
"Obtain the contents of an ``IOBuffer`` as a string, without copying. "
"Afterwards, the IOBuffer is reset to its initial state."
msgstr ""

#: ../../stdlib/base.rst:1796
msgid ""
"Create an ``IOStream`` object from an integer file descriptor. If ``own`` is"
" true, closing this object will close the underlying descriptor. By default,"
" an ``IOStream`` is closed when it is garbage collected. ``name`` allows you"
" to associate the descriptor with a named file."
msgstr ""

#: ../../stdlib/base.rst:1800
msgid "Commit all currently buffered writes to the given stream."
msgstr ""

#: ../../stdlib/base.rst:1804
msgid ""
"Flushes the C ``stdout`` and ``stderr`` streams (which may have been written"
" to by external C code)."
msgstr ""

#: ../../stdlib/base.rst:1809
msgid "Close an I/O stream. Performs a ``flush`` first."
msgstr ""

#: ../../stdlib/base.rst:1813
msgid ""
"Write the canonical binary representation of a value to the given stream."
msgstr ""

#: ../../stdlib/base.rst:1817
msgid ""
"Read a value of the given type from a stream, in canonical binary "
"representation."
msgstr ""

#: ../../stdlib/base.rst:1821
msgid ""
"Read a series of values of the given type from a stream, in canonical binary"
" representation. ``dims`` is either a tuple or a series of integer arguments"
" specifying the size of ``Array`` to return."
msgstr ""

#: ../../stdlib/base.rst:1825
msgid "Read binary data from a stream, filling in the argument ``array``."
msgstr ""

#: ../../stdlib/base.rst:1829
msgid ""
"Read at most ``nb`` bytes from the stream into ``b``, returning the number "
"of bytes read (increasing the size of ``b`` as needed)."
msgstr ""

#: ../../stdlib/base.rst:1834
msgid ""
"Read at most ``nb`` bytes from the stream, returning a ``Vector{UInt8}`` of "
"the bytes read."
msgstr ""

#: ../../stdlib/base.rst:1839
msgid "Get the current position of a stream."
msgstr ""

#: ../../stdlib/base.rst:1843
msgid "Seek a stream to the given position."
msgstr ""

#: ../../stdlib/base.rst:1847
msgid "Seek a stream to its beginning."
msgstr ""

#: ../../stdlib/base.rst:1851
msgid "Seek a stream to its end."
msgstr ""

#: ../../stdlib/base.rst:1855
msgid "Seek a stream relative to the current position."
msgstr ""

#: ../../stdlib/base.rst:1859
msgid ""
"Add a mark at the current position of stream ``s``.  Returns the marked "
"position."
msgstr ""

#: ../../stdlib/base.rst:1861
msgid "See also :func:`unmark`, :func:`reset`, :func:`ismarked`"
msgstr ""

#: ../../stdlib/base.rst:1865
msgid ""
"Remove a mark from stream ``s``. Returns ``true`` if the stream was marked, "
"``false`` otherwise."
msgstr ""

#: ../../stdlib/base.rst:1868
msgid "See also :func:`mark`, :func:`reset`, :func:`ismarked`"
msgstr ""

#: ../../stdlib/base.rst:1872
msgid ""
"Reset a stream ``s`` to a previously marked position, and remove the mark. "
"Returns the previously marked position. Throws an error if the stream is not"
" marked."
msgstr ""

#: ../../stdlib/base.rst:1876
msgid "See also :func:`mark`, :func:`unmark`, :func:`ismarked`"
msgstr ""

#: ../../stdlib/base.rst:1880
msgid "Returns true if stream ``s`` is marked."
msgstr ""

#: ../../stdlib/base.rst:1882
msgid "See also :func:`mark`, :func:`unmark`, :func:`reset`"
msgstr ""

#: ../../stdlib/base.rst:1886
msgid ""
"Tests whether an I/O stream is at end-of-file. If the stream is not yet "
"exhausted, this function will block to wait for more data if necessary, and "
"then return ``false``. Therefore it is always safe to read one byte after "
"seeing ``eof`` return ``false``. ``eof`` will return ``false`` as long as "
"buffered data is still available, even if the remote end of a connection is "
"closed."
msgstr ""

#: ../../stdlib/base.rst:1895
msgid "Determine whether a stream is read-only."
msgstr ""

#: ../../stdlib/base.rst:1899
msgid ""
"Determine whether a stream is open (i.e. has not been closed yet). If the "
"connection has been closed remotely (in case of e.g. a socket), ``isopen`` "
"will return ``false`` even though buffered data may still be available. Use "
"``eof`` to check if necessary."
msgstr ""

#: ../../stdlib/base.rst:1906
msgid ""
"Converts the endianness of a value from Network byte order (big-endian) to "
"that used by the Host."
msgstr ""

#: ../../stdlib/base.rst:1911
msgid ""
"Converts the endianness of a value from that used by the Host to Network "
"byte order (big-endian)."
msgstr ""

#: ../../stdlib/base.rst:1916
msgid ""
"Converts the endianness of a value from Little-endian to that used by the "
"Host."
msgstr ""

#: ../../stdlib/base.rst:1921
msgid ""
"Converts the endianness of a value from that used by the Host to Little-"
"endian."
msgstr ""

#: ../../stdlib/base.rst:1926
msgid ""
"The 32-bit byte-order-mark indicates the native byte order of the host "
"machine. Little-endian machines will contain the value 0x04030201. Big-"
"endian machines will contain the value 0x01020304."
msgstr ""

#: ../../stdlib/base.rst:1930
msgid ""
"Write an arbitrary value to a stream in an opaque format, such that it can "
"be read back by ``deserialize``. The read-back value will be as identical as"
" possible to the original. In general, this process will not work if the "
"reading and writing are done by different versions of Julia, or an instance "
"of Julia with a different system image."
msgstr ""

#: ../../stdlib/base.rst:1938
msgid "Read a value written by ``serialize``."
msgstr ""

#: ../../stdlib/base.rst:1942
msgid ""
"General escaping of traditional C and Unicode escape sequences, plus any "
"characters in esc are also escaped (with a backslash)."
msgstr ""

#: ../../stdlib/base.rst:1946
msgid ""
"General unescaping of traditional C and Unicode escape sequences. Reverse of"
" :func:`print_escaped`."
msgstr ""

#: ../../stdlib/base.rst:1950
msgid ""
"Print elements of ``items`` to ``io`` with ``delim`` between them. If "
"``last`` is specified, it is used as the final delimiter instead of "
"``delim``."
msgstr ""

#: ../../stdlib/base.rst:1954
msgid ""
"Print the shortest possible representation of number ``x`` as a floating "
"point number, ensuring that it would parse to the exact same number."
msgstr ""

#: ../../stdlib/base.rst:1958
msgid ""
"Returns the file descriptor backing the stream or file. Note that this "
"function only applies to synchronous `File`'s and `IOStream`'s not to any of"
" the asynchronous streams."
msgstr ""

#: ../../stdlib/base.rst:1963
msgid ""
"Create a pipe to which all C and Julia level STDOUT output will be "
"redirected. Returns a tuple (rd,wr) representing the pipe ends. Data written"
" to STDOUT may now be read from the rd end of the pipe. The wr end is given "
"for convenience in case the old STDOUT object was cached by the user and "
"needs to be replaced elsewhere."
msgstr ""

#: ../../stdlib/base.rst:1970
msgid ""
"Replace STDOUT by stream for all C and julia level output to STDOUT. Note "
"that `stream` must be a TTY, a Pipe or a TcpSocket."
msgstr ""

#: ../../stdlib/base.rst:1975
msgid "Like redirect_stdout, but for STDERR"
msgstr ""

#: ../../stdlib/base.rst:1979
msgid ""
"Like redirect_stdout, but for STDIN. Note that the order of the return tuple"
" is still (rd,wr), i.e. data to be read from STDIN, may be written to wr."
msgstr ""

#: ../../stdlib/base.rst:1984
msgid ""
"Read the entirety of x as a string but remove trailing newlines. Equivalent "
"to chomp(readall(x))."
msgstr ""

#: ../../stdlib/base.rst:1988
msgid ""
"Returns the files and directories in the directory `dir` (or the current "
"working directory if not given)."
msgstr ""

#: ../../stdlib/base.rst:1992
msgid ""
"Resize the file or buffer given by the first argument to exactly `n` bytes, "
"filling previously unallocated space with '\\0' if the file or buffer is "
"grown"
msgstr ""

#: ../../stdlib/base.rst:1997
msgid ""
"Advance the stream until before the first character for which ``predicate`` "
"returns false. For example ``skipchars(stream, isspace)`` will skip all "
"whitespace. If keyword argument ``linecomment`` is specified, characters "
"from that character through the end of a line will also be skipped."
msgstr ""

#: ../../stdlib/base.rst:2001
msgid ""
"Read io until the end of the stream/file and count the number of non-empty "
"lines. To specify a file pass the filename as the first argument. EOL "
"markers other than '\\n' are supported by passing them as the second "
"argument."
msgstr ""

#: ../../stdlib/base.rst:2006
msgid ""
"An IOBuffer that allows reading and performs writes by appending. Seeking "
"and truncating are not supported. See IOBuffer for the available "
"constructors."
msgstr ""

#: ../../stdlib/base.rst:2010
msgid ""
"Create a PipeBuffer to operate on a data vector, optionally specifying a "
"size beyond which the underlying Array may not be grown."
msgstr ""

#: ../../stdlib/base.rst:2014
msgid ""
"Read all available data on the stream, blocking the task only if no data is "
"available."
msgstr ""

#: ../../stdlib/base.rst:2018
msgid ""
"Returns a structure whose fields contain information about the file. The "
"fields of the structure are:"
msgstr ""

#: ../../stdlib/base.rst:2021
msgid "size"
msgstr ""

#: ../../stdlib/base.rst:2021
msgid "The size (in bytes) of the file"
msgstr ""

#: ../../stdlib/base.rst:2022
msgid "device"
msgstr ""

#: ../../stdlib/base.rst:2022
msgid "ID of the device that contains the file"
msgstr ""

#: ../../stdlib/base.rst:2023
msgid "inode"
msgstr ""

#: ../../stdlib/base.rst:2023
msgid "The inode number of the file"
msgstr ""

#: ../../stdlib/base.rst:2024
msgid "mode"
msgstr ""

#: ../../stdlib/base.rst:2024
msgid "The protection mode of the file"
msgstr ""

#: ../../stdlib/base.rst:2025
msgid "nlink"
msgstr ""

#: ../../stdlib/base.rst:2025
msgid "The number of hard links to the file"
msgstr ""

#: ../../stdlib/base.rst:2026
msgid "uid"
msgstr ""

#: ../../stdlib/base.rst:2026
msgid "The user id of the owner of the file"
msgstr ""

#: ../../stdlib/base.rst:2027
msgid "gid"
msgstr ""

#: ../../stdlib/base.rst:2027
msgid "The group id of the file owner"
msgstr ""

#: ../../stdlib/base.rst:2028
msgid "rdev"
msgstr ""

#: ../../stdlib/base.rst:2028
msgid "If this file refers to a device, the ID of the device it refers to"
msgstr ""

#: ../../stdlib/base.rst:2029
msgid "blksize"
msgstr ""

#: ../../stdlib/base.rst:2029
msgid "The file-system preferred block size for the file"
msgstr ""

#: ../../stdlib/base.rst:2030
msgid "blocks"
msgstr ""

#: ../../stdlib/base.rst:2030
msgid "The number of such blocks allocated"
msgstr ""

#: ../../stdlib/base.rst:2031
msgid "mtime"
msgstr ""

#: ../../stdlib/base.rst:2031
msgid "Unix timestamp of when the file was last modified"
msgstr ""

#: ../../stdlib/base.rst:2032
msgid "ctime"
msgstr ""

#: ../../stdlib/base.rst:2032
msgid "Unix timestamp of when the file was created"
msgstr ""

#: ../../stdlib/base.rst:2037
msgid ""
"Like stat, but for symbolic links gets the info for the link itself rather "
"than the file it refers to. This function must be called on a file path "
"rather than a file object or a file descriptor."
msgstr ""

#: ../../stdlib/base.rst:2041
msgid "Equivalent to stat(file).ctime"
msgstr ""

#: ../../stdlib/base.rst:2045
msgid "Equivalent to stat(file).mtime"
msgstr ""

#: ../../stdlib/base.rst:2049
msgid "Equivalent to stat(file).mode"
msgstr ""

#: ../../stdlib/base.rst:2053
msgid "Equivalent to stat(file).size"
msgstr ""

#: ../../stdlib/base.rst:2057
msgid "Gets the permissions of the owner of the file as a bitfield of"
msgstr ""

#: ../../stdlib/base.rst:2060
msgid "01"
msgstr ""

#: ../../stdlib/base.rst:2060
msgid "Execute Permission"
msgstr ""

#: ../../stdlib/base.rst:2061
msgid "02"
msgstr ""

#: ../../stdlib/base.rst:2061
msgid "Write Permission"
msgstr ""

#: ../../stdlib/base.rst:2062
msgid "04"
msgstr ""

#: ../../stdlib/base.rst:2062
msgid "Read Permission"
msgstr ""

#: ../../stdlib/base.rst:2065
msgid "For allowed arguments, see ``stat``."
msgstr ""

#: ../../stdlib/base.rst:2069
msgid "Like uperm but gets the permissions of the group owning the file"
msgstr ""

#: ../../stdlib/base.rst:2073
msgid ""
"Like uperm but gets the permissions for people who neither own the file nor "
"are a member of the group owning the file"
msgstr ""

#: ../../stdlib/base.rst:2078
msgid "Copy a file from `src` to `dest`."
msgstr ""

#: ../../stdlib/base.rst:2082
msgid ""
"Download a file from the given url, optionally renaming it to the given "
"local file name. Note that this function relies on the availability of "
"external tools such as ``curl``, ``wget`` or ``fetch`` to download the file "
"and is provided for convenience. For production use or situations in which "
"more options are need, please use a package that provides the desired "
"functionality instead."
msgstr ""

#: ../../stdlib/base.rst:2090
msgid "Move a file from `src` to `dst`."
msgstr ""

#: ../../stdlib/base.rst:2094
msgid ""
"Delete the file, link, or empty directory at the given path. If "
"``recursive=true`` is passed and the path is a directory, then all contents "
"are removed recursively."
msgstr ""

#: ../../stdlib/base.rst:2099
msgid "Update the last-modified timestamp on a file to the current time."
msgstr ""

#: ../../stdlib/base.rst:2103
msgid "Network I/O"
msgstr ""

#: ../../stdlib/base.rst:2107
msgid "Connect to the host ``host`` on port ``port``"
msgstr ""

#: ../../stdlib/base.rst:2111
msgid "Connect to the Named Pipe/Domain Socket at ``path``"
msgstr ""

#: ../../stdlib/base.rst:2115
msgid ""
"Listen on port on the address specified by ``addr``. By default this listens"
" on localhost only. To listen on all interfaces pass, ``IPv4(0)`` or "
"``IPv6(0)`` as appropriate."
msgstr ""

#: ../../stdlib/base.rst:2120
msgid "Listens on/Creates a Named Pipe/Domain Socket"
msgstr ""

#: ../../stdlib/base.rst:2124
msgid "Gets the IP address of the ``host`` (may have to do a DNS lookup)"
msgstr ""

#: ../../stdlib/base.rst:2128
msgid "Parse a string specifying an IPv4 or IPv6 ip address."
msgstr ""

#: ../../stdlib/base.rst:2132
msgid "Returns IPv4 object from ip address formatted as Integer"
msgstr ""

#: ../../stdlib/base.rst:2136
msgid "Returns IPv6 object from ip address formatted as Integer"
msgstr ""

#: ../../stdlib/base.rst:2140
msgid ""
"Returns the number of bytes available for reading before a read from this "
"stream or buffer will block."
msgstr ""

#: ../../stdlib/base.rst:2144
msgid ""
"Accepts a connection on the given server and returns a connection to the "
"client. An uninitialized client stream may be provided, in which case it "
"will be used instead of creating a new stream."
msgstr ""

#: ../../stdlib/base.rst:2149
msgid ""
"Create a TcpServer on any port, using hint as a starting point. Returns a "
"tuple of the actual port that the server was created on and the server "
"itself."
msgstr ""

#: ../../stdlib/base.rst:2154
msgid ""
"Watch file or directory ``s`` and run callback ``cb`` when ``s`` is "
"modified. The ``poll`` parameter specifies whether to use file system event "
"monitoring or polling. The callback function ``cb`` should accept 3 "
"arguments: ``(filename, events, status)`` where ``filename`` is the name of "
"file that was modified, ``events`` is an object with boolean fields "
"``changed`` and ``renamed`` when using file system event monitoring, or "
"``readable`` and ``writable`` when using polling, and ``status`` is always "
"0. Pass ``false`` for ``cb`` to not use a callback function."
msgstr ""

#: ../../stdlib/base.rst:2158
msgid ""
"Poll a file descriptor fd for changes in the read or write availability and "
"with a timeout given by the second argument. If the timeout is not needed, "
"use ``wait(fd)`` instead. The keyword arguments determine which of read "
"and/or write status should be monitored and at least one of them needs to be"
" set to true. The returned value is an object with boolean fields "
"``readable``, ``writable``, and ``timedout``, giving the result of the "
"polling."
msgstr ""

#: ../../stdlib/base.rst:2166
msgid ""
"Monitor a file for changes by polling every `interval_seconds` seconds for "
"`seconds` seconds. A return value of true indicates the file changed, a "
"return value of false indicates a timeout."
msgstr ""

#: ../../stdlib/base.rst:2171
msgid ""
"Bind ``socket`` to the given ``host:port``. Note that `0.0.0.0` will listen "
"on all devices."
msgstr ""

#: ../../stdlib/base.rst:2175
msgid "Send ``msg`` over ``socket to ``host:port``."
msgstr ""

#: ../../stdlib/base.rst:2179
msgid ""
"Read a UDP packet from the specified socket, and return the bytes received. "
"This call blocks."
msgstr ""

#: ../../stdlib/base.rst:2183
msgid ""
"Set UDP socket options. ``multicast_loop``: loopback for multicast packets "
"(default: true). ``multicast_ttl``: TTL for multicast packets. "
"``enable_broadcast``: flag must be set to true if socket will be used for "
"broadcast messages, or else the UDP system will return an access error "
"(default: false). ``ttl``: Time-to-live of packets sent on the socket."
msgstr ""

#: ../../stdlib/base.rst:2187
msgid "Text I/O"
msgstr ""

#: ../../stdlib/base.rst:2191
msgid ""
"Write an informative text representation of a value to the current output "
"stream. New types should overload ``show(io, x)`` where the first argument "
"is a stream. The representation used by ``show`` generally includes Julia-"
"specific formatting and type information."
msgstr ""

#: ../../stdlib/base.rst:2196
msgid ""
"Show a more compact representation of a value. This is used for printing "
"array elements. If a new type has a different compact representation, it "
"should overload ``showcompact(io, x)`` where the first argument is a stream."
msgstr ""

#: ../../stdlib/base.rst:2202
msgid "Similar to ``show``, except shows all elements of arrays."
msgstr ""

#: ../../stdlib/base.rst:2206
msgid ""
"Return a string giving a brief description of a value. By default returns "
"``string(typeof(x))``. For arrays, returns strings like \"2x2 Float64 "
"Array\"."
msgstr ""

#: ../../stdlib/base.rst:2211
msgid ""
"Write (to the default output stream) a canonical (un-decorated) text "
"representation of a value if there is one, otherwise call ``show``. The "
"representation used by ``print`` includes minimal formatting and tries to "
"avoid Julia-specific details."
msgstr ""

#: ../../stdlib/base.rst:2216
msgid "Print (using :func:`print`) ``x`` followed by a newline."
msgstr ""

#: ../../stdlib/base.rst:2220
msgid ""
"Print strings in a color specified as a symbol, for example ``:red`` or "
"``:blue``."
msgstr ""

#: ../../stdlib/base.rst:2224
msgid "Display an informational message."
msgstr ""

#: ../../stdlib/base.rst:2228
msgid "Display a warning."
msgstr ""

#: ../../stdlib/base.rst:2232
msgid ""
"Print arg(s) using C ``printf()`` style format specification string. "
"Optionally, an IOStream may be passed as the first argument to redirect "
"output."
msgstr ""

#: ../../stdlib/base.rst:2236
msgid "Return ``@printf`` formatted output as string."
msgstr ""

#: ../../stdlib/base.rst:2240
msgid ""
"Call the given function with an I/O stream and the supplied extra arguments."
" Everything written to this I/O stream is returned as a string."
msgstr ""

#: ../../stdlib/base.rst:2245
msgid "Show a descriptive representation of an exception object."
msgstr ""

#: ../../stdlib/base.rst:2249
msgid "Show all user-visible structure of a value."
msgstr ""

#: ../../stdlib/base.rst:2253
msgid "Show all structure of a value, including all fields of objects."
msgstr ""

#: ../../stdlib/base.rst:2257
msgid "Read the entire contents of an I/O stream as a string."
msgstr ""

#: ../../stdlib/base.rst:2261
msgid ""
"Open ``filename``, read the entire contents as a string, then close the "
"file. Equivalent to ``open(readall, filename)``."
msgstr ""

#: ../../stdlib/base.rst:2266
msgid ""
"Read a single line of text, including a trailing newline character (if one "
"is reached before the end of the input), from the given ``stream`` (defaults"
" to ``STDIN``),"
msgstr ""

#: ../../stdlib/base.rst:2270
msgid "Read a string, up to and including the given delimiter byte."
msgstr ""

#: ../../stdlib/base.rst:2274
msgid "Read all lines as an array."
msgstr ""

#: ../../stdlib/base.rst:2278
msgid "Create an iterable object that will yield each line from a stream."
msgstr ""

#: ../../stdlib/base.rst:2282
msgid ""
"Read a matrix from the source where each line (separated by ``eol``) gives "
"one row, with elements separated by the given delimeter. The source can be a"
" text file, stream or byte array. Memory mapped files can be used by passing"
" the byte array representation of the mapped segment as source."
msgstr ""

#: ../../stdlib/base.rst:2284
msgid ""
"If ``T`` is a numeric type, the result is an array of that type, with any "
"non-numeric elements as ``NaN`` for floating-point types, or zero. Other "
"useful values of ``T`` include ``ASCIIString``, ``AbstractString``, and "
"``Any``."
msgstr ""

#: ../../stdlib/base.rst:2286
msgid ""
"If ``header`` is ``true``, the first row of data will be read as header and "
"the tuple ``(data_cells, header_cells)`` is returned instead of only "
"``data_cells``."
msgstr ""

#: ../../stdlib/base.rst:2288
msgid ""
"Specifying ``skipstart`` will ignore the corresponding number of initial "
"lines from the input."
msgstr ""

#: ../../stdlib/base.rst:2290
msgid ""
"If ``skipblanks`` is ``true``, blank lines in the input will be ignored."
msgstr ""

#: ../../stdlib/base.rst:2292
msgid ""
"If ``use_mmap`` is ``true``, the file specified by ``source`` is memory "
"mapped for potential speedups. Default is ``true`` except on Windows. On "
"Windows, you may want to specify ``true`` if the file is large, and is only "
"read once and not written to."
msgstr ""

#: ../../stdlib/base.rst:2294
msgid ""
"If ``ignore_invalid_chars`` is ``true``, bytes in ``source`` with invalid "
"character encoding will be ignored. Otherwise an error is thrown indicating "
"the offending character position."
msgstr ""

#: ../../stdlib/base.rst:2296
msgid ""
"If ``quotes`` is ``true``, column enclosed within double-quote (``) "
"characters are allowed to contain new lines and column delimiters. Double-"
"quote characters within a quoted field must be escaped with another double-"
"quote."
msgstr ""

#: ../../stdlib/base.rst:2298
msgid ""
"Specifying ``dims`` as a tuple of the expected rows and columns (including "
"header, if any) may speed up reading of large files."
msgstr ""

#: ../../stdlib/base.rst:2300
msgid ""
"If ``comments`` is ``true``, lines beginning with ``comment_char`` and text "
"following ``comment_char`` in any line are ignored."
msgstr ""

#: ../../stdlib/base.rst:2304
msgid ""
"If all data is numeric, the result will be a numeric array. If some elements"
" cannot be parsed as numbers, a cell array of numbers and strings is "
"returned."
msgstr ""

#: ../../stdlib/base.rst:2308
msgid "The end of line delimiter is taken as ``\\n``."
msgstr ""

#: ../../stdlib/base.rst:2312
msgid ""
"The end of line delimiter is taken as ``\\n``. If all data is numeric, the "
"result will be a numeric array. If some elements cannot be parsed as "
"numbers, a cell array of numbers and strings is returned."
msgstr ""

#: ../../stdlib/base.rst:2316
msgid ""
"The columns are assumed to be separated by one or more whitespaces. The end "
"of line delimiter is taken as ``\\n``."
msgstr ""

#: ../../stdlib/base.rst:2320
msgid ""
"The columns are assumed to be separated by one or more whitespaces. The end "
"of line delimiter is taken as ``\\n``. If all data is numeric, the result "
"will be a numeric array. If some elements cannot be parsed as numbers, a "
"cell array of numbers and strings is returned."
msgstr ""

#: ../../stdlib/base.rst:2324
msgid ""
"Write ``A`` (a vector, matrix or an iterable collection of iterable rows) as"
" text to ``f`` (either a filename string or an ``IO`` stream) using the "
"given delimeter ``delim`` (which defaults to tab, but can be any printable "
"Julia object, typically a ``Char`` or ``AbstractString``)."
msgstr ""

#: ../../stdlib/base.rst:2326
msgid ""
"For example, two vectors ``x`` and ``y`` of the same length can be written "
"as two columns of tab-delimited text to ``f`` by either ``writedlm(f, [x "
"y])`` or by ``writedlm(f, zip(x, y))``."
msgstr ""

#: ../../stdlib/base.rst:2332
msgid "Equivalent to ``readdlm`` with ``delim`` set to comma."
msgstr ""

#: ../../stdlib/base.rst:2336
msgid "Equivalent to ``writedlm`` with ``delim`` set to comma."
msgstr ""

#: ../../stdlib/base.rst:2340
msgid ""
"Returns a new write-only I/O stream, which converts any bytes written to it "
"into base64-encoded ASCII bytes written to ``ostream``.  Calling ``close`` "
"on the ``Base64Pipe`` stream is necessary to complete the encoding (but does"
" not close ``ostream``)."
msgstr ""

#: ../../stdlib/base.rst:2348
msgid ""
"Given a ``write``-like function ``writefunc``, which takes an I/O stream as "
"its first argument, ``base64(writefunc, args...)`` calls ``writefunc`` to "
"write ``args...`` to a base64-encoded string, and returns the string.  "
"``base64(args...)`` is equivalent to ``base64(write, args...)``: it converts"
" its arguments into bytes using the standard ``write`` functions and returns"
" the base64-encoded string."
msgstr ""

#: ../../stdlib/base.rst:2357
msgid "Multimedia I/O"
msgstr ""

#: ../../stdlib/base.rst:2359
msgid ""
"Just as text output is performed by ``print`` and user-defined types can "
"indicate their textual representation by overloading ``show``, Julia "
"provides a standardized mechanism for rich multimedia output (such as "
"images, formatted text, or even audio and video), consisting of three parts:"
msgstr ""

#: ../../stdlib/base.rst:2365
msgid ""
"A function ``display(x)`` to request the richest available multimedia "
"display of a Julia object ``x`` (with a plain-text fallback)."
msgstr ""

#: ../../stdlib/base.rst:2367
msgid ""
"Overloading ``writemime`` allows one to indicate arbitrary multimedia "
"representations (keyed by standard MIME types) of user-defined types."
msgstr ""

#: ../../stdlib/base.rst:2369
msgid ""
"Multimedia-capable display backends may be registered by subclassing a "
"generic ``Display`` type and pushing them onto a stack of display backends "
"via ``pushdisplay``."
msgstr ""

#: ../../stdlib/base.rst:2373
msgid ""
"The base Julia runtime provides only plain-text display, but richer displays"
" may be enabled by loading external modules or by using graphical Julia "
"environments (such as the IPython-based IJulia notebook)."
msgstr ""

#: ../../stdlib/base.rst:2382
msgid ""
"Display ``x`` using the topmost applicable display in the display stack, "
"typically using the richest supported multimedia output for ``x``, with "
"plain-text ``STDOUT`` output as a fallback.  The ``display(d, x)`` variant "
"attempts to display ``x`` on the given display ``d`` only, throwing a "
"``MethodError`` if ``d`` cannot display objects of this type."
msgstr ""

#: ../../stdlib/base.rst:2388
msgid ""
"There are also two variants with a ``mime`` argument (a MIME type string, "
"such as ``\"image/png\"``), which attempt to display ``x`` using the "
"requested MIME type *only*, throwing a ``MethodError`` if this type is not "
"supported by either the display(s) or by ``x``.   With these variants, one "
"can also supply the \"raw\" data in the requested MIME type by passing "
"``x::AbstractString`` (for MIME types with text-based storage, such as "
"text/html or application/postscript) or ``x::Vector{UInt8}`` (for binary "
"MIME types)."
msgstr ""

#: ../../stdlib/base.rst:2402
msgid ""
"By default, the ``redisplay`` functions simply call ``display``.  However, "
"some display backends may override ``redisplay`` to modify an existing "
"display of ``x`` (if any).   Using ``redisplay`` is also a hint to the "
"backend that ``x`` may be redisplayed several times, and the backend may "
"choose to defer the display until (for example) the next interactive prompt."
msgstr ""

#: ../../stdlib/base.rst:2412
msgid ""
"Returns a boolean value indicating whether the given ``mime`` type (string) "
"is displayable by any of the displays in the current display stack, or "
"specifically by the display ``d`` in the second variant."
msgstr ""

#: ../../stdlib/base.rst:2418
msgid ""
"The ``display`` functions ultimately call ``writemime`` in order to write an"
" object ``x`` as a given ``mime`` type to a given I/O ``stream`` (usually a "
"memory buffer), if possible.  In order to provide a rich multimedia "
"representation of a user-defined type ``T``, it is only necessary to define "
"a new ``writemime`` method for ``T``, via: ``writemime(stream, "
"::MIME\"mime\", x::T) = ...``, where ``mime`` is a MIME-type string and the "
"function body calls ``write`` (or similar) to write that representation of "
"``x`` to ``stream``. (Note that the ``MIME\"\"`` notation only supports "
"literal strings; to construct ``MIME`` types in a more flexible manner use "
"``MIME{symbol(\"\")}``.)"
msgstr ""

#: ../../stdlib/base.rst:2430
msgid ""
"For example, if you define a ``MyImage`` type and know how to write it to a "
"PNG file, you could define a function ``writemime(stream, "
"::MIME\"image/png\", x::MyImage) = ...``` to allow your images to be "
"displayed on any PNG-capable ``Display`` (such as IJulia). As usual, be sure"
" to ``import Base.writemime`` in order to add new methods to the built-in "
"Julia function ``writemime``."
msgstr ""

#: ../../stdlib/base.rst:2437
msgid ""
"Technically, the ``MIME\"mime\"`` macro defines a singleton type for the "
"given ``mime`` string, which allows us to exploit Julia's dispatch "
"mechanisms in determining how to display objects of any given type."
msgstr ""

#: ../../stdlib/base.rst:2444
msgid ""
"Returns a boolean value indicating whether or not the object ``x`` can be "
"written as the given ``mime`` type.  (By default, this is determined "
"automatically by the existence of the corresponding ``writemime`` function "
"for ``typeof(x)``.)"
msgstr ""

#: ../../stdlib/base.rst:2451
msgid ""
"Returns a ``AbstractString`` or ``Vector{UInt8}`` containing the "
"representation of ``x`` in the requested ``mime`` type, as written by "
"``writemime`` (throwing a ``MethodError`` if no appropriate ``writemime`` is"
" available).  A ``AbstractString`` is returned for MIME types with textual "
"representations (such as ``\"text/html\"`` or "
"``\"application/postscript\"``), whereas binary data is returned as "
"``Vector{UInt8}``.  (The function ``istext(mime)`` returns whether or not "
"Julia treats a given ``mime`` type as text.)"
msgstr ""

#: ../../stdlib/base.rst:2460
msgid ""
"As a special case, if ``x`` is a ``AbstractString`` (for textual MIME types)"
" or a ``Vector{UInt8}`` (for binary MIME types), the ``reprmime`` function "
"assumes that ``x`` is already in the requested ``mime`` format and simply "
"returns ``x``."
msgstr ""

#: ../../stdlib/base.rst:2467
msgid ""
"Returns a ``AbstractString`` containing the representation of ``x`` in the "
"requested ``mime`` type.  This is similar to ``reprmime`` except that binary"
" data is base64-encoded as an ASCII string."
msgstr ""

#: ../../stdlib/base.rst:2471
msgid ""
"As mentioned above, one can also define new display backends. For example, a"
" module that can display PNG images in a window can register this capability"
" with Julia, so that calling ``display(x)`` on types with PNG "
"representations will automatically display the image using the module's "
"window."
msgstr ""

#: ../../stdlib/base.rst:2477
msgid ""
"In order to define a new display backend, one should first create a subtype "
"``D`` of the abstract class ``Display``.  Then, for each MIME type (``mime``"
" string) that can be displayed on ``D``, one should define a function "
"``display(d::D, ::MIME\"mime\", x) = ...`` that displays ``x`` as that MIME "
"type, usually by calling ``reprmime(mime, x)``.  A ``MethodError`` should be"
" thrown if ``x`` cannot be displayed as that MIME type; this is automatic if"
" one calls ``reprmime``. Finally, one should define a function "
"``display(d::D, x)`` that queries ``mimewritable(mime, x)`` for the ``mime``"
" types supported by ``D`` and displays the \"best\" one; a ``MethodError`` "
"should be thrown if no supported MIME types are found for ``x``.  Similarly,"
" some subtypes may wish to override ``redisplay(d::D, ...)``.  (Again, one "
"should ``import Base.display`` to add new methods to ``display``.) The "
"return values of these functions are up to the implementation (since in some"
" cases it may be useful to return a display \"handle\" of some type).  The "
"display functions for ``D`` can then be called directly, but they can also "
"be invoked automatically from ``display(x)`` simply by pushing a new display"
" onto the display-backend stack with:"
msgstr ""

#: ../../stdlib/base.rst:2499
msgid ""
"Pushes a new display ``d`` on top of the global display-backend stack.  "
"Calling ``display(x)`` or ``display(mime, x)`` will display ``x`` on the "
"topmost compatible backend in the stack (i.e., the topmost backend that does"
" not throw a ``MethodError``)."
msgstr ""

#: ../../stdlib/base.rst:2507
msgid ""
"Pop the topmost backend off of the display-backend stack, or the topmost "
"copy of ``d`` in the second variant."
msgstr ""

#: ../../stdlib/base.rst:2512
msgid ""
"Returns a ``TextDisplay <: Display``, which can display any object as the "
"text/plain MIME type (only), writing the text representation to the given "
"I/O stream.  (The text representation is the same as the way an object is "
"printed in the Julia REPL.)"
msgstr ""

#: ../../stdlib/base.rst:2519
msgid "Determine whether a MIME type is text data."
msgstr ""

#: ../../stdlib/base.rst:2522
msgid "Memory-mapped I/O"
msgstr ""

#: ../../stdlib/base.rst:2526
msgid ""
"Create an ``Array`` whose values are linked to a file, using memory-mapping."
" This provides a convenient way of working with data too large to fit in the"
" computer's memory."
msgstr ""

#: ../../stdlib/base.rst:2528
msgid ""
"The type determines how the bytes of the array are interpreted. Note that "
"the file must be stored in binary format, and no format conversions are "
"possible (this is a limitation of operating systems, not Julia)."
msgstr ""

#: ../../stdlib/base.rst:2530
msgid "``dims`` is a tuple specifying the size of the array."
msgstr ""

#: ../../stdlib/base.rst:2532
msgid ""
"The file is passed via the stream argument.  When you initialize the stream,"
" use ``\"r\"`` for a \"read-only\" array, and ``\"w+\"`` to create a new "
"array used to write values to disk."
msgstr ""

#: ../../stdlib/base.rst:2534
msgid ""
"Optionally, you can specify an offset (in bytes) if, for example, you want "
"to skip over a header in the file. The default value for the offset is the "
"current stream position."
msgstr ""

#: ../../stdlib/base.rst:2536
msgid "For example, the following code::"
msgstr ""

#: ../../stdlib/base.rst:2555
msgid ""
"creates a ``m``-by-``n`` ``Matrix{Int}``, linked to the file associated with"
" stream ``s``."
msgstr ""

#: ../../stdlib/base.rst:2557
msgid ""
"A more portable file would need to encode the word size---32 bit or 64 bit"
"---and endianness information in the header. In practice, consider encoding "
"binary data using standard formats like HDF5 (which can be used with memory-"
"mapping)."
msgstr ""

#: ../../stdlib/base.rst:2561
msgid ""
"Create a ``BitArray`` whose values are linked to a file, using memory-"
"mapping; it has the same purpose, works in the same way, and has the same "
"arguments, as :func:`mmap_array`, but the byte representation is different. "
"The ``type`` parameter is optional, and must be ``Bool`` if given."
msgstr ""

#: ../../stdlib/base.rst:2563
msgid "**Example**:  ``B = mmap_bitarray((25,30000), s)``"
msgstr ""

#: ../../stdlib/base.rst:2565
msgid ""
"This would create a 25-by-30000 ``BitArray``, linked to the file associated "
"with stream ``s``."
msgstr ""

#: ../../stdlib/base.rst:2569
msgid ""
"Forces synchronization between the in-memory version of a memory-mapped "
"``Array`` or ``BitArray`` and the on-disk version."
msgstr ""

#: ../../stdlib/base.rst:2573
msgid ""
"Forces synchronization of the :func:`mmap`\\ ped memory region from ``ptr`` "
"to ``ptr+len``. Flags defaults to ``MS_SYNC``, but can be a combination of "
"``MS_ASYNC``, ``MS_SYNC``, or ``MS_INVALIDATE``. See your platform man page "
"for specifics. The flags argument is not valid on Windows."
msgstr ""

#: ../../stdlib/base.rst:2575
msgid ""
"You may not need to call ``msync``, because synchronization is performed at "
"intervals automatically by the operating system. However, you can call this "
"directly if, for example, you are concerned about losing the result of a "
"long-running calculation."
msgstr ""

#: ../../stdlib/base.rst:2579 ../../stdlib/base.rst:2583
#: ../../stdlib/base.rst:2587
msgid ""
"Enum constant for :func:`msync`. See your platform man page for details. "
"(not available on Windows)."
msgstr ""

#: ../../stdlib/base.rst:2591
msgid "Low-level interface to the ``mmap`` system call. See the man page."
msgstr ""

#: ../../stdlib/base.rst:2595
msgid ""
"Low-level interface for unmapping memory (see the man page). With "
":func:`mmap_array` you do not need to call this directly; the memory is "
"unmapped for you when the array goes out of scope."
msgstr ""

#: ../../stdlib/base.rst:2598
msgid "Standard Numeric Types"
msgstr ""

#: ../../stdlib/base.rst:2600
msgid ""
"``Bool`` ``Int8`` ``UInt8`` ``Int16`` ``UInt16`` ``Int32`` ``UInt32`` "
"``Int64`` ``UInt64`` ``Int128`` ``UInt128`` ``Float16`` ``Float32`` "
"``Float64`` ``Complex64`` ``Complex128``"
msgstr ""

#: ../../stdlib/base.rst:2605
msgid "Mathematical Operators"
msgstr ""

#: ../../stdlib/base.rst:2609
msgid "Unary minus operator."
msgstr ""

#: ../../stdlib/base.rst:2614
msgid ""
"Addition operator. ``x+y+z+...`` calls this function with all arguments, "
"i.e. ``+(x, y, z, ...)``."
msgstr ""

#: ../../stdlib/base.rst:2620
msgid "Subtraction operator."
msgstr ""

#: ../../stdlib/base.rst:2625
msgid ""
"Multiplication operator. ``x*y*z*...`` calls this function with all "
"arguments, i.e. ``*(x, y, z, ...)``."
msgstr ""

#: ../../stdlib/base.rst:2631
msgid ""
"Right division operator: multiplication of ``x`` by the inverse of ``y`` on "
"the right. Gives floating-point results for integer arguments."
msgstr ""

#: ../../stdlib/base.rst:2637
msgid ""
"Left division operator: multiplication of ``y`` by the inverse of ``x`` on "
"the left. Gives floating-point results for integer arguments."
msgstr ""

#: ../../stdlib/base.rst:2643
msgid "Exponentiation operator."
msgstr ""

#: ../../stdlib/base.rst:2648
msgid "Element-wise addition operator."
msgstr ""

#: ../../stdlib/base.rst:2653
msgid "Element-wise subtraction operator."
msgstr ""

#: ../../stdlib/base.rst:2658
msgid "Element-wise multiplication operator."
msgstr ""

#: ../../stdlib/base.rst:2663
msgid "Element-wise right division operator."
msgstr ""

#: ../../stdlib/base.rst:2668
msgid "Element-wise left division operator."
msgstr ""

#: ../../stdlib/base.rst:2673
msgid "Element-wise exponentiation operator."
msgstr ""

#: ../../stdlib/base.rst:2678
msgid ""
"The quotient from Euclidean division. Computes ``x/y``, truncated to an "
"integer."
msgstr ""

#: ../../stdlib/base.rst:2682
msgid "Largest integer less than or equal to ``x/y``."
msgstr ""

#: ../../stdlib/base.rst:2686
msgid "Smallest integer larger than or equal to ``x/y``."
msgstr ""

#: ../../stdlib/base.rst:2690
msgid ""
"Modulus after division, returning in the range [0,``y``), if ``y`` is "
"positive, or (``y``,0] if ``y`` is negative."
msgstr ""

#: ../../stdlib/base.rst:2695
msgid "Modulus after division by 2pi, returning in the range [0,2pi)."
msgstr ""

#: ../../stdlib/base.rst:2697
msgid ""
"This function computes a floating point representation of the modulus after "
"division by numerically exact 2pi, and is therefore not exactly the same as "
"mod(x,2pi), which would compute the modulus of x relative to division by the"
" floating-point number 2pi."
msgstr ""

#: ../../stdlib/base.rst:2705
msgid ""
"Remainder from Euclidean division, returning a value of the same sign "
"as``x``, and smaller in magnitude than ``y``. This value is always exact."
msgstr ""

#: ../../stdlib/base.rst:2710
msgid ""
"The quotient and remainder from Euclidean division. Equivalent to ``(x÷y, "
"x%y)``."
msgstr ""

#: ../../stdlib/base.rst:2714
msgid "Modulus after division, returning in the range (0,m]"
msgstr ""

#: ../../stdlib/base.rst:2718
msgid "Remainder after division, returning in the range (0,m]"
msgstr ""

#: ../../stdlib/base.rst:2723
msgid "Divide two integers or rational numbers, giving a ``Rational`` result."
msgstr ""

#: ../../stdlib/base.rst:2727
msgid ""
"Approximate floating point number ``x`` as a Rational number with components"
" of the given integer type. The result will differ from ``x`` by no more "
"than ``tol``."
msgstr ""

#: ../../stdlib/base.rst:2732
msgid "Numerator of the rational representation of ``x``"
msgstr ""

#: ../../stdlib/base.rst:2736
msgid "Denominator of the rational representation of ``x``"
msgstr ""

#: ../../stdlib/base.rst:2741
msgid "Left bit shift operator."
msgstr ""

#: ../../stdlib/base.rst:2746
msgid "Right bit shift operator, preserving the sign of ``x``."
msgstr ""

#: ../../stdlib/base.rst:2751
msgid "Unsigned right bit shift operator."
msgstr ""

#: ../../stdlib/base.rst:2756
msgid ""
"Range operator. ``a:b`` constructs a range from ``a`` to ``b`` with a step "
"size of 1, and ``a:s:b`` is similar but uses a step size of ``s``. These "
"syntaxes call the function ``colon``. The colon is also used in indexing to "
"select whole dimensions."
msgstr ""

#: ../../stdlib/base.rst:2763
msgid "Called by ``:`` syntax for constructing ranges."
msgstr ""

#: ../../stdlib/base.rst:2767
msgid ""
"Construct a range by length, given a starting value and optional step "
"(defaults to 1)."
msgstr ""

#: ../../stdlib/base.rst:2771
msgid "Construct a range by length, given a starting and ending value."
msgstr ""

#: ../../stdlib/base.rst:2776
msgid ""
"Generic equality operator, giving a single ``Bool`` result. Falls back to "
"``===``. Should be implemented for all types with a notion of equality, "
"based on the abstract value that an instance represents. For example, all "
"numeric types are compared by numeric value, ignoring type. Strings are "
"compared as sequences of characters, ignoring encoding."
msgstr ""

#: ../../stdlib/base.rst:2782
msgid "Follows IEEE semantics for floating-point numbers."
msgstr ""

#: ../../stdlib/base.rst:2784
msgid ""
"Collections should generally implement ``==`` by calling ``==`` recursively "
"on all contents."
msgstr ""

#: ../../stdlib/base.rst:2786
msgid ""
"New numeric types should implement this function for two arguments of the "
"new type, and handle comparison to other types via promotion rules where "
"possible."
msgstr ""

#: ../../stdlib/base.rst:2793
msgid ""
"Not-equals comparison operator. Always gives the opposite answer as ``==``. "
"New types should generally not implement this, and rely on the fallback "
"definition ``!=(x,y) = !(x==y)`` instead."
msgstr ""

#: ../../stdlib/base.rst:2801
msgid "See the :func:`is` operator"
msgstr ""

#: ../../stdlib/base.rst:2807
msgid "Equivalent to ``!is(x, y)``"
msgstr ""

#: ../../stdlib/base.rst:2812
msgid ""
"Less-than comparison operator. New numeric types should implement this "
"function for two arguments of the new type. Because of the behavior of "
"floating-point NaN values, ``<`` implements a partial order. Types with a "
"canonical partial order should implement ``<``, and types with a canonical "
"total order should implement ``isless``."
msgstr ""

#: ../../stdlib/base.rst:2822
msgid "Less-than-or-equals comparison operator."
msgstr ""

#: ../../stdlib/base.rst:2827
msgid ""
"Greater-than comparison operator. Generally, new types should implement "
"``<`` instead of this function, and rely on the fallback definition ``>(x,y)"
" = y<x``."
msgstr ""

#: ../../stdlib/base.rst:2834
msgid "Greater-than-or-equals comparison operator."
msgstr ""

#: ../../stdlib/base.rst:2839
msgid "Element-wise equality comparison operator."
msgstr ""

#: ../../stdlib/base.rst:2845
msgid "Element-wise not-equals comparison operator."
msgstr ""

#: ../../stdlib/base.rst:2850
msgid "Element-wise less-than comparison operator."
msgstr ""

#: ../../stdlib/base.rst:2856
msgid "Element-wise less-than-or-equals comparison operator."
msgstr ""

#: ../../stdlib/base.rst:2861
msgid "Element-wise greater-than comparison operator."
msgstr ""

#: ../../stdlib/base.rst:2867
msgid "Element-wise greater-than-or-equals comparison operator."
msgstr ""

#: ../../stdlib/base.rst:2871
msgid ""
"Return -1, 0, or 1 depending on whether ``x`` is less than, equal to, or "
"greater than ``y``, respectively. Uses the total order implemented by "
"``isless``. For floating-point numbers, uses ``<`` but throws an error for "
"unordered arguments."
msgstr ""

#: ../../stdlib/base.rst:2878
msgid "Bitwise not"
msgstr ""

#: ../../stdlib/base.rst:2883
msgid "Bitwise and"
msgstr ""

#: ../../stdlib/base.rst:2888
msgid "Bitwise or"
msgstr ""

#: ../../stdlib/base.rst:2893
msgid "Bitwise exclusive or"
msgstr ""

#: ../../stdlib/base.rst:2898
msgid "Boolean not"
msgstr ""

#: ../../stdlib/base.rst:2903
msgid "Short-circuiting boolean and"
msgstr ""

#: ../../stdlib/base.rst:2908
msgid "Short-circuiting boolean or"
msgstr ""

#: ../../stdlib/base.rst:2912
msgid "Matrix operator A \\\\ B\\ :sup:`H`"
msgstr ""

#: ../../stdlib/base.rst:2916
msgid "Matrix operator A \\\\ B\\ :sup:`T`"
msgstr ""

#: ../../stdlib/base.rst:2920
msgid "Matrix operator A B"
msgstr ""

#: ../../stdlib/base.rst:2924
msgid "Matrix operator A B\\ :sup:`H`"
msgstr ""

#: ../../stdlib/base.rst:2928
msgid "Matrix operator A B\\ :sup:`T`"
msgstr ""

#: ../../stdlib/base.rst:2932
msgid "Matrix operator A / B\\ :sup:`H`"
msgstr ""

#: ../../stdlib/base.rst:2936
msgid "Matrix operator A / B\\ :sup:`T`"
msgstr ""

#: ../../stdlib/base.rst:2940
msgid "Matrix operator A\\ :sup:`H` \\\\ B"
msgstr ""

#: ../../stdlib/base.rst:2944
msgid "Matrix operator A\\ :sup:`H` \\\\ B\\ :sup:`H`"
msgstr ""

#: ../../stdlib/base.rst:2948
msgid "Matrix operator A\\ :sup:`H` B"
msgstr ""

#: ../../stdlib/base.rst:2952
msgid "Matrix operator A\\ :sup:`H` B\\ :sup:`H`"
msgstr ""

#: ../../stdlib/base.rst:2956
msgid "Matrix operator A\\ :sup:`H` / B"
msgstr ""

#: ../../stdlib/base.rst:2960
msgid "Matrix operator A\\ :sup:`H` / B\\ :sup:`H`"
msgstr ""

#: ../../stdlib/base.rst:2964
msgid "Matrix operator A\\ :sup:`T` \\\\ B"
msgstr ""

#: ../../stdlib/base.rst:2968
msgid "Matrix operator A\\ :sup:`T` \\\\ B\\ :sup:`T`"
msgstr ""

#: ../../stdlib/base.rst:2972
msgid "Matrix operator A\\ :sup:`T` B"
msgstr ""

#: ../../stdlib/base.rst:2976
msgid "Matrix operator A\\ :sup:`T` B\\ :sup:`T`"
msgstr ""

#: ../../stdlib/base.rst:2980
msgid "Matrix operator A\\ :sup:`T` / B"
msgstr ""

#: ../../stdlib/base.rst:2984
msgid "Matrix operator A\\ :sup:`T` / B\\ :sup:`T`"
msgstr ""

#: ../../stdlib/base.rst:2988
msgid "Mathematical Functions"
msgstr ""

#: ../../stdlib/base.rst:2992
msgid ""
"Inexact equality comparison - behaves slightly different depending on types "
"of input args:"
msgstr ""

#: ../../stdlib/base.rst:2994
msgid ""
"For ``FloatingPoint`` numbers, ``isapprox`` returns ``true`` if ``abs(x-y) "
"<= atol + rtol*max(abs(x), abs(y))``."
msgstr ""

#: ../../stdlib/base.rst:2996
msgid ""
"For ``Integer`` and ``Rational`` numbers, ``isapprox`` returns ``true`` if "
"``abs(x-y) <= atol``. The `rtol` argument is ignored. If one of ``x`` and "
"``y`` is ``FloatingPoint``, the other is promoted, and the method above is "
"called instead."
msgstr ""

#: ../../stdlib/base.rst:2998
msgid ""
"For ``Complex`` numbers, the distance in the complex plane is compared, "
"using the same criterion as above."
msgstr ""

#: ../../stdlib/base.rst:3000
msgid ""
"For default tolerance arguments, ``maxeps = max(eps(abs(x)), eps(abs(y)))``."
msgstr ""

#: ../../stdlib/base.rst:3004
msgid "Compute sine of ``x``, where ``x`` is in radians"
msgstr ""

#: ../../stdlib/base.rst:3008
msgid "Compute cosine of ``x``, where ``x`` is in radians"
msgstr ""

#: ../../stdlib/base.rst:3012
msgid "Compute tangent of ``x``, where ``x`` is in radians"
msgstr ""

#: ../../stdlib/base.rst:3016
msgid "Compute sine of ``x``, where ``x`` is in degrees"
msgstr ""

#: ../../stdlib/base.rst:3020
msgid "Compute cosine of ``x``, where ``x`` is in degrees"
msgstr ""

#: ../../stdlib/base.rst:3024
msgid "Compute tangent of ``x``, where ``x`` is in degrees"
msgstr ""

#: ../../stdlib/base.rst:3028
msgid ""
"Compute :math:`\\sin(\\pi x)` more accurately than ``sin(pi*x)``, especially"
" for large ``x``."
msgstr ""

#: ../../stdlib/base.rst:3032
msgid ""
"Compute :math:`\\cos(\\pi x)` more accurately than ``cos(pi*x)``, especially"
" for large ``x``."
msgstr ""

#: ../../stdlib/base.rst:3036
msgid "Compute hyperbolic sine of ``x``"
msgstr ""

#: ../../stdlib/base.rst:3040
msgid "Compute hyperbolic cosine of ``x``"
msgstr ""

#: ../../stdlib/base.rst:3044
msgid "Compute hyperbolic tangent of ``x``"
msgstr ""

#: ../../stdlib/base.rst:3048
msgid "Compute the inverse sine of ``x``, where the output is in radians"
msgstr ""

#: ../../stdlib/base.rst:3052
msgid "Compute the inverse cosine of ``x``, where the output is in radians"
msgstr ""

#: ../../stdlib/base.rst:3056
msgid "Compute the inverse tangent of ``x``, where the output is in radians"
msgstr ""

#: ../../stdlib/base.rst:3060
msgid ""
"Compute the inverse tangent of ``y/x``, using the signs of both ``x`` and "
"``y`` to determine the quadrant of the return value."
msgstr ""

#: ../../stdlib/base.rst:3064
msgid "Compute the inverse sine of ``x``, where the output is in degrees"
msgstr ""

#: ../../stdlib/base.rst:3068
msgid "Compute the inverse cosine of ``x``, where the output is in degrees"
msgstr ""

#: ../../stdlib/base.rst:3072
msgid "Compute the inverse tangent of ``x``, where the output is in degrees"
msgstr ""

#: ../../stdlib/base.rst:3076
msgid "Compute the secant of ``x``, where ``x`` is in radians"
msgstr ""

#: ../../stdlib/base.rst:3080
msgid "Compute the cosecant of ``x``, where ``x`` is in radians"
msgstr ""

#: ../../stdlib/base.rst:3084
msgid "Compute the cotangent of ``x``, where ``x`` is in radians"
msgstr ""

#: ../../stdlib/base.rst:3088
msgid "Compute the secant of ``x``, where ``x`` is in degrees"
msgstr ""

#: ../../stdlib/base.rst:3092
msgid "Compute the cosecant of ``x``, where ``x`` is in degrees"
msgstr ""

#: ../../stdlib/base.rst:3096
msgid "Compute the cotangent of ``x``, where ``x`` is in degrees"
msgstr ""

#: ../../stdlib/base.rst:3100
msgid "Compute the inverse secant of ``x``, where the output is in radians"
msgstr ""

#: ../../stdlib/base.rst:3104
msgid "Compute the inverse cosecant of ``x``, where the output is in radians"
msgstr ""

#: ../../stdlib/base.rst:3108
msgid "Compute the inverse cotangent of ``x``, where the output is in radians"
msgstr ""

#: ../../stdlib/base.rst:3112
msgid "Compute the inverse secant of ``x``, where the output is in degrees"
msgstr ""

#: ../../stdlib/base.rst:3116
msgid "Compute the inverse cosecant of ``x``, where the output is in degrees"
msgstr ""

#: ../../stdlib/base.rst:3120
msgid "Compute the inverse cotangent of ``x``, where the output is in degrees"
msgstr ""

#: ../../stdlib/base.rst:3124
msgid "Compute the hyperbolic secant of ``x``"
msgstr ""

#: ../../stdlib/base.rst:3128
msgid "Compute the hyperbolic cosecant of ``x``"
msgstr ""

#: ../../stdlib/base.rst:3132
msgid "Compute the hyperbolic cotangent of ``x``"
msgstr ""

#: ../../stdlib/base.rst:3136
msgid "Compute the inverse hyperbolic sine of ``x``"
msgstr ""

#: ../../stdlib/base.rst:3140
msgid "Compute the inverse hyperbolic cosine of ``x``"
msgstr ""

#: ../../stdlib/base.rst:3144
msgid "Compute the inverse hyperbolic tangent of ``x``"
msgstr ""

#: ../../stdlib/base.rst:3148
msgid "Compute the inverse hyperbolic secant of ``x``"
msgstr ""

#: ../../stdlib/base.rst:3152
msgid "Compute the inverse hyperbolic cosecant of ``x``"
msgstr ""

#: ../../stdlib/base.rst:3156
msgid "Compute the inverse hyperbolic cotangent of ``x``"
msgstr ""

#: ../../stdlib/base.rst:3160
msgid ""
"Compute :math:`\\sin(\\pi x) / (\\pi x)` if :math:`x \\neq 0`, and :math:`1`"
" if :math:`x = 0`."
msgstr ""

#: ../../stdlib/base.rst:3164
msgid ""
"Compute :math:`\\cos(\\pi x) / x - \\sin(\\pi x) / (\\pi x^2)` if :math:`x "
"\\neq 0`, and :math:`0` if :math:`x = 0`. This is the derivative of "
"``sinc(x)``."
msgstr ""

#: ../../stdlib/base.rst:3169
msgid "Convert ``x`` from degrees to radians"
msgstr ""

#: ../../stdlib/base.rst:3173
msgid "Convert ``x`` from radians to degrees"
msgstr ""

#: ../../stdlib/base.rst:3177
msgid "Compute the :math:`\\sqrt{x^2+y^2}` avoiding overflow and underflow"
msgstr ""

#: ../../stdlib/base.rst:3181
msgid ""
"Compute the natural logarithm of ``x``. Throws ``DomainError`` for negative "
"``Real`` arguments. Use complex negative arguments instead."
msgstr ""

#: ../../stdlib/base.rst:3185
msgid ""
"Compute the base ``b`` logarithm of ``x``. Throws ``DomainError`` for "
"negative ``Real`` arguments."
msgstr ""

#: ../../stdlib/base.rst:3189
msgid ""
"Compute the logarithm of ``x`` to base 2. Throws ``DomainError`` for "
"negative ``Real`` arguments."
msgstr ""

#: ../../stdlib/base.rst:3193
msgid ""
"Compute the logarithm of ``x`` to base 10. Throws ``DomainError`` for "
"negative ``Real`` arguments."
msgstr ""

#: ../../stdlib/base.rst:3197
msgid ""
"Accurate natural logarithm of ``1+x``.  Throws ``DomainError`` for ``Real`` "
"arguments less than -1."
msgstr ""

#: ../../stdlib/base.rst:3201
msgid ""
"Return ``(x,exp)`` such that ``x`` has a magnitude in the interval ``[1/2, "
"1)`` or 0, and val = :math:`x \\times 2^{exp}`."
msgstr ""

#: ../../stdlib/base.rst:3206
msgid "Compute :math:`e^x`"
msgstr ""

#: ../../stdlib/base.rst:3210
msgid "Compute :math:`2^x`"
msgstr ""

#: ../../stdlib/base.rst:3214
msgid "Compute :math:`10^x`"
msgstr ""

#: ../../stdlib/base.rst:3218
msgid "Compute :math:`x \\times 2^n`"
msgstr ""

#: ../../stdlib/base.rst:3222
msgid ""
"Return a tuple (fpart,ipart) of the fractional and integral parts of a "
"number. Both parts have the same sign as the argument."
msgstr ""

#: ../../stdlib/base.rst:3227
msgid "Accurately compute :math:`e^x-1`"
msgstr ""

#: ../../stdlib/base.rst:3231
msgid ""
"``round(x)`` returns an integral value of the same type as ``x`` to ``x``, "
"according to the default rounding mode (see ``get_rounding``). By default, "
"this will round to the nearest integer, with ties (fractional values of 0.5)"
" being rounded to the even integer."
msgstr ""

#: ../../stdlib/base.rst:3247
msgid ""
"The optional ``roundingmode`` argument will change this behaviour. Currently"
" supported are"
msgstr ""

#: ../../stdlib/base.rst:3250
msgid ""
"`RoundNearestTiesAway`: this emulates C-style ``round`` behaviour, by "
"rounding ties away from zero."
msgstr ""

#: ../../stdlib/base.rst:3252
msgid ""
"`RoundNearestTiesUp`: this emulates Java-style ``round`` behaviour, by "
"rounding ties toward positive infinity."
msgstr ""

#: ../../stdlib/base.rst:3254
msgid "`RoundToZero`: an alias for `trunc`"
msgstr ""

#: ../../stdlib/base.rst:3255
msgid "`RoundUp`: an alias for `ceil`"
msgstr ""

#: ../../stdlib/base.rst:3256
msgid "`RoundDown`: an alias for `floor`"
msgstr ""

#: ../../stdlib/base.rst:3258
msgid ""
"``round(T, x, [r::RoundingMode])`` converts the result to type ``T``, "
"throwing an ``InexactError`` if the value is not representable."
msgstr ""

#: ../../stdlib/base.rst:3261
msgid ""
"``round(x, digits)`` rounds to the specified number of digits after the "
"decimal place, or before if negative, e.g., ``round(pi,2)`` is ``3.14``. "
"``round(x, digits, base)`` rounds using a different base, defaulting to 10, "
"e.g., ``round(pi, 1, 8)`` is ``3.125``."
msgstr ""

#: ../../stdlib/base.rst:3265
msgid ""
"``ceil(x)`` returns the nearest integral value of the same type as ``x`` "
"that is greater than or equal to ``x``."
msgstr ""

#: ../../stdlib/base.rst:3268
msgid ""
"``ceil(T, x)`` converts the result to type ``T``, throwing an "
"``InexactError`` if the value is not representable."
msgstr ""

#: ../../stdlib/base.rst:3271
msgid "``digits`` and ``base`` work as for ``round``."
msgstr ""

#: ../../stdlib/base.rst:3275
msgid ""
"``floor(x)`` returns the nearest integral value of the same type as ``x`` "
"that is less than or equal to ``x``."
msgstr ""

#: ../../stdlib/base.rst:3278
msgid ""
"``floor(T, x)`` converts the result to type ``T``, throwing an "
"``InexactError`` if the value is not representable."
msgstr ""

#: ../../stdlib/base.rst:3281 ../../stdlib/base.rst:3291
msgid "``digits`` and ``base`` work as above."
msgstr ""

#: ../../stdlib/base.rst:3285
msgid ""
"``trunc(x)`` returns the nearest integral value of the same type as ``x`` "
"whose absolute value is less than or equal to ``x``."
msgstr ""

#: ../../stdlib/base.rst:3288
msgid ""
"``trunc(T, x)`` converts the result to type ``T``, throwing an "
"``InexactError`` if the value is not representable."
msgstr ""

#: ../../stdlib/base.rst:3295
msgid ""
"``unsafe_trunc(T, x)`` returns the nearest integral value of type ``T`` "
"whose absolute value is less than or equal to ``x``. If the value is not "
"representable by ``T``, an arbitrary value will be returned."
msgstr ""

#: ../../stdlib/base.rst:3301
msgid ""
"Rounds (in the sense of ``round``) ``x`` so that there are ``digits`` "
"significant digits, under a base ``base`` representation, default 10. E.g., "
"``signif(123.456, 2)`` is ``120.0``, and ``signif(357.913, 4, 2)`` is "
"``352.0``."
msgstr ""

#: ../../stdlib/base.rst:3305
msgid "Return the minimum of the arguments. Operates elementwise over arrays."
msgstr ""

#: ../../stdlib/base.rst:3309
msgid "Return the maximum of the arguments. Operates elementwise over arrays."
msgstr ""

#: ../../stdlib/base.rst:3313
msgid ""
"Return ``(min(x,y), max(x,y))``. See also: :func:`extrema` that returns "
"``(minimum(x), maximum(x))``"
msgstr ""

#: ../../stdlib/base.rst:3318
msgid ""
"Return x if ``lo <= x <= hi``. If ``x < lo``, return ``lo``. If ``x > hi``, "
"return ``hi``. Arguments are promoted to a common type. Operates elementwise"
" over ``x`` if it is an array."
msgstr ""

#: ../../stdlib/base.rst:3322
msgid "Absolute value of ``x``"
msgstr ""

#: ../../stdlib/base.rst:3326
msgid "Squared absolute value of ``x``"
msgstr ""

#: ../../stdlib/base.rst:3330
msgid "Return ``x`` such that it has the same sign as ``y``"
msgstr ""

#: ../../stdlib/base.rst:3334
msgid ""
"Return ``+1`` if ``x`` is positive, ``0`` if ``x == 0``, and ``-1`` if ``x``"
" is negative."
msgstr ""

#: ../../stdlib/base.rst:3338
msgid ""
"Returns ``true`` if the value of the sign of ``x`` is negative, otherwise "
"``false``."
msgstr ""

#: ../../stdlib/base.rst:3342
msgid ""
"Return ``x`` with its sign flipped if ``y`` is negative. For example "
"``abs(x) = flipsign(x,x)``."
msgstr ""

#: ../../stdlib/base.rst:3346
msgid ""
"Return :math:`\\sqrt{x}`. Throws ``DomainError`` for negative ``Real`` "
"arguments. Use complex negative arguments instead.  The prefix operator "
"``√`` is equivalent to ``sqrt``."
msgstr ""

#: ../../stdlib/base.rst:3350
msgid "Integer square root: the largest integer ``m`` such that ``m*m <= n``."
msgstr ""

#: ../../stdlib/base.rst:3354
msgid ""
"Return :math:`x^{1/3}`.  The prefix operator ``∛`` is equivalent to "
"``cbrt``."
msgstr ""

#: ../../stdlib/base.rst:3358
msgid ""
"Compute the error function of ``x``, defined by "
":math:`\\frac{2}{\\sqrt{\\pi}} \\int_0^x e^{-t^2} dt` for arbitrary complex "
"``x``."
msgstr ""

#: ../../stdlib/base.rst:3364
msgid ""
"Compute the complementary error function of ``x``, defined by :math:`1 - "
"\\operatorname{erf}(x)`."
msgstr ""

#: ../../stdlib/base.rst:3369
msgid ""
"Compute the scaled complementary error function of ``x``, defined by "
":math:`e^{x^2} \\operatorname{erfc}(x)`.  Note also that "
":math:`\\operatorname{erfcx}(-ix)` computes the Faddeeva function "
":math:`w(x)`."
msgstr ""

#: ../../stdlib/base.rst:3376
msgid ""
"Compute the imaginary error function of ``x``, defined by :math:`-i "
"\\operatorname{erf}(ix)`."
msgstr ""

#: ../../stdlib/base.rst:3381
msgid ""
"Compute the Dawson function (scaled imaginary error function) of ``x``, "
"defined by :math:`\\frac{\\sqrt{\\pi}}{2} e^{-x^2} \\operatorname{erfi}(x)`."
msgstr ""

#: ../../stdlib/base.rst:3386
msgid ""
"Compute the inverse error function of a real ``x``, defined by "
":math:`\\operatorname{erf}(\\operatorname{erfinv}(x)) = x`."
msgstr ""

#: ../../stdlib/base.rst:3391
msgid ""
"Compute the inverse error complementary function of a real ``x``, defined by"
" :math:`\\operatorname{erfc}(\\operatorname{erfcinv}(x)) = x`."
msgstr ""

#: ../../stdlib/base.rst:3396
msgid "Return the real part of the complex number ``z``"
msgstr ""

#: ../../stdlib/base.rst:3400
msgid "Return the imaginary part of the complex number ``z``"
msgstr ""

#: ../../stdlib/base.rst:3404
msgid "Return both the real and imaginary parts of the complex number ``z``"
msgstr ""

#: ../../stdlib/base.rst:3408
msgid "Compute the complex conjugate of a complex number ``z``"
msgstr ""

#: ../../stdlib/base.rst:3412
msgid "Compute the phase angle of a complex number ``z``"
msgstr ""

#: ../../stdlib/base.rst:3416
msgid "Return :math:`\\exp(iz)`."
msgstr ""

#: ../../stdlib/base.rst:3420
msgid "Number of ways to choose ``k`` out of ``n`` items"
msgstr ""

#: ../../stdlib/base.rst:3424
msgid "Factorial of n"
msgstr ""

#: ../../stdlib/base.rst:3428
msgid "Compute ``factorial(n)/factorial(k)``"
msgstr ""

#: ../../stdlib/base.rst:3432
msgid ""
"Compute the prime factorization of an integer ``n``. Returns a dictionary. "
"The keys of the dictionary correspond to the factors, and hence are of the "
"same type as ``n``. The value associated with each key indicates the number "
"of times the factor appears in the factorization."
msgstr ""

#: ../../stdlib/base.rst:3443
msgid "Greatest common (positive) divisor (or zero if x and y are both zero)."
msgstr ""

#: ../../stdlib/base.rst:3447
msgid "Least common (non-negative) multiple."
msgstr ""

#: ../../stdlib/base.rst:3451
msgid ""
"Computes the greatest common (positive) divisor of ``x`` and ``y`` and their"
" Bézout coefficients, i.e. the integer coefficients ``u`` and ``v`` that "
"satisfy :math:`ux+vy = d = gcd(x,y)`."
msgstr ""

#: ../../stdlib/base.rst:3465
msgid ""
"Bézout coefficients are *not* uniquely defined. ``gcdx`` returns the minimal"
" Bézout coefficients that are computed by the extended Euclid algorithm. "
"(Ref: D. Knuth, TAoCP, 2/e, p. 325, Algorithm X.) These coefficients ``u`` "
"and ``v`` are minimal in the sense that :math:`|u| < |\\frac y d` and "
":math:`|v| < |\\frac x d`. Furthermore, the signs of ``u`` and ``v`` are "
"chosen so that ``d`` is positive."
msgstr ""

#: ../../stdlib/base.rst:3469
msgid "Test whether ``n`` is a power of two"
msgstr ""

#: ../../stdlib/base.rst:3473
msgid ""
"The smallest power of two not less than ``n``. Returns 0 for ``n==0``, and "
"returns ``-nextpow2(-n)`` for negative arguments."
msgstr ""

#: ../../stdlib/base.rst:3478
msgid ""
"The largest power of two not greater than ``n``. Returns 0 for ``n==0``, and"
" returns ``-prevpow2(-n)`` for negative arguments."
msgstr ""

#: ../../stdlib/base.rst:3483
msgid ""
"The smallest ``a^n`` not less than ``x``, where ``n`` is a non-negative "
"integer. ``a`` must be greater than 1, and ``x`` must be greater than 0."
msgstr ""

#: ../../stdlib/base.rst:3488
msgid ""
"The largest ``a^n`` not greater than ``x``, where ``n`` is a non-negative "
"integer. ``a`` must be greater than 1, and ``x`` must not be less than 1."
msgstr ""

#: ../../stdlib/base.rst:3493
msgid ""
"Next integer not less than ``n`` that can be written as :math:`\\prod "
"k_i^{p_i}` for integers :math:`p_1`, :math:`p_2`, etc."
msgstr ""

#: ../../stdlib/base.rst:3497
msgid ""
"Previous integer not greater than ``n`` that can be written as :math:`\\prod"
" k_i^{p_i}` for integers :math:`p_1`, :math:`p_2`, etc."
msgstr ""

#: ../../stdlib/base.rst:3501
msgid ""
"Take the inverse of ``x`` modulo ``m``: ``y`` such that :math:`xy = 1 \\pmod"
" m`"
msgstr ""

#: ../../stdlib/base.rst:3505
msgid "Compute :math:`x^p \\pmod m`"
msgstr ""

#: ../../stdlib/base.rst:3509
msgid "Compute the gamma function of ``x``"
msgstr ""

#: ../../stdlib/base.rst:3513
msgid "Compute the logarithm of absolute value of ``gamma(x)``"
msgstr ""

#: ../../stdlib/base.rst:3517
msgid "Compute the logarithmic factorial of ``x``"
msgstr ""

#: ../../stdlib/base.rst:3521
msgid ""
"Compute the digamma function of ``x`` (the logarithmic derivative of "
"``gamma(x)``)"
msgstr ""

#: ../../stdlib/base.rst:3525
msgid "Compute the inverse digamma function of ``x``."
msgstr ""

#: ../../stdlib/base.rst:3529
msgid ""
"Compute the trigamma function of ``x`` (the logarithmic second derivative of"
" ``gamma(x)``)"
msgstr ""

#: ../../stdlib/base.rst:3533
msgid ""
"Compute the polygamma function of order ``m`` of argument ``x`` (the "
"``(m+1)th`` derivative of the logarithm of ``gamma(x)``)"
msgstr ""

#: ../../stdlib/base.rst:3537
msgid "kth derivative of the Airy function :math:`\\operatorname{Ai}(x)`."
msgstr ""

#: ../../stdlib/base.rst:3541
msgid "Airy function :math:`\\operatorname{Ai}(x)`."
msgstr ""

#: ../../stdlib/base.rst:3545 ../../stdlib/base.rst:3549
msgid "Airy function derivative :math:`\\operatorname{Ai}'(x)`."
msgstr ""

#: ../../stdlib/base.rst:3553
msgid "Airy function :math:`\\operatorname{Bi}(x)`."
msgstr ""

#: ../../stdlib/base.rst:3557
msgid "Airy function derivative :math:`\\operatorname{Bi}'(x)`."
msgstr ""

#: ../../stdlib/base.rst:3561
msgid ""
"scaled kth derivative of the Airy function, return "
":math:`\\operatorname{Ai}(x) e^{\\frac{2}{3} x \\sqrt{x}}` for ``k == 0 || k"
" == 1``, and :math:`\\operatorname{Ai}(x) e^{- \\left| \\operatorname{Re} "
"\\left( \\frac{2}{3} x \\sqrt{x} \\right) \\right|}` for ``k == 2 || k == "
"3``."
msgstr ""

#: ../../stdlib/base.rst:3565
msgid "Bessel function of the first kind of order 0, :math:`J_0(x)`."
msgstr ""

#: ../../stdlib/base.rst:3569
msgid "Bessel function of the first kind of order 1, :math:`J_1(x)`."
msgstr ""

#: ../../stdlib/base.rst:3573
msgid "Bessel function of the first kind of order ``nu``, :math:`J_\\nu(x)`."
msgstr ""

#: ../../stdlib/base.rst:3577
msgid ""
"Scaled Bessel function of the first kind of order ``nu``, :math:`J_\\nu(x) "
"e^{- | \\operatorname{Im}(x) |}`."
msgstr ""

#: ../../stdlib/base.rst:3581
msgid "Bessel function of the second kind of order 0, :math:`Y_0(x)`."
msgstr ""

#: ../../stdlib/base.rst:3585
msgid "Bessel function of the second kind of order 1, :math:`Y_1(x)`."
msgstr ""

#: ../../stdlib/base.rst:3589
msgid "Bessel function of the second kind of order ``nu``, :math:`Y_\\nu(x)`."
msgstr ""

#: ../../stdlib/base.rst:3593
msgid ""
"Scaled Bessel function of the second kind of order ``nu``, :math:`Y_\\nu(x) "
"e^{- | \\operatorname{Im}(x) |}`."
msgstr ""

#: ../../stdlib/base.rst:3597
msgid ""
"Bessel function of the third kind of order ``nu``, :math:`H^{(1)}_\\nu(x)`."
msgstr ""

#: ../../stdlib/base.rst:3601
msgid ""
"Scaled Bessel function of the third kind of order ``nu``, "
":math:`H^{(1)}_\\nu(x) e^{-x i}`."
msgstr ""

#: ../../stdlib/base.rst:3605
msgid ""
"Bessel function of the third kind of order ``nu``, :math:`H^{(2)}_\\nu(x)`."
msgstr ""

#: ../../stdlib/base.rst:3609
msgid ""
"Scaled Bessel function of the third kind of order ``nu``, "
":math:`H^{(2)}_\\nu(x) e^{x i}`."
msgstr ""

#: ../../stdlib/base.rst:3613
msgid ""
"Bessel function of the third kind of order ``nu`` (Hankel function). ``k`` "
"is either 1 or 2, selecting ``hankelh1`` or ``hankelh2``, respectively."
msgstr ""

#: ../../stdlib/base.rst:3618
msgid ""
"Modified Bessel function of the first kind of order ``nu``, "
":math:`I_\\nu(x)`."
msgstr ""

#: ../../stdlib/base.rst:3622
msgid ""
"Scaled modified Bessel function of the first kind of order ``nu``, "
":math:`I_\\nu(x) e^{- | \\operatorname{Re}(x) |}`."
msgstr ""

#: ../../stdlib/base.rst:3626
msgid ""
"Modified Bessel function of the second kind of order ``nu``, "
":math:`K_\\nu(x)`."
msgstr ""

#: ../../stdlib/base.rst:3630
msgid ""
"Scaled modified Bessel function of the second kind of order ``nu``, "
":math:`K_\\nu(x) e^x`."
msgstr ""

#: ../../stdlib/base.rst:3634
msgid ""
"Euler integral of the first kind :math:`\\operatorname{B}(x,y) = "
"\\Gamma(x)\\Gamma(y)/\\Gamma(x+y)`."
msgstr ""

#: ../../stdlib/base.rst:3638
msgid ""
"Natural logarithm of the absolute value of the beta function "
":math:`\\log(|\\operatorname{B}(x,y)|)`."
msgstr ""

#: ../../stdlib/base.rst:3642
msgid ""
"Dirichlet eta function :math:`\\eta(s) = "
"\\sum^\\infty_{n=1}(-)^{n-1}/n^{s}`."
msgstr ""

#: ../../stdlib/base.rst:3646
msgid "Riemann zeta function :math:`\\zeta(s)`."
msgstr ""

#: ../../stdlib/base.rst:3650
msgid ""
"Hurwitz zeta function :math:`\\zeta(s, z)`.  (This is equivalent to the "
"Riemann zeta function :math:`\\zeta(s)` for the case of ``z=1``.)"
msgstr ""

#: ../../stdlib/base.rst:3655
msgid "Compute the number of digits in number ``n`` written in base ``b``."
msgstr ""

#: ../../stdlib/base.rst:3659
msgid "Multiply ``x`` and ``y``, giving the result as a larger type."
msgstr ""

#: ../../stdlib/base.rst:3663
msgid ""
"Evaluate the polynomial :math:`\\sum_k c[k] z^{k-1}` for the coefficients "
"``c[1]``, ``c[2]``, ...; that is, the coefficients are given in ascending "
"order by power of ``z``.  This macro expands to efficient inline code that "
"uses either Horner's method or, for complex ``z``, a more efficient "
"Goertzel-like algorithm."
msgstr ""

#: ../../stdlib/base.rst:3670
msgid "Data Formats"
msgstr ""

#: ../../stdlib/base.rst:3674
msgid ""
"Convert an integer to a binary string, optionally specifying a number of "
"digits to pad to."
msgstr ""

#: ../../stdlib/base.rst:3678
msgid ""
"Convert an integer to a hexadecimal string, optionally specifying a number "
"of digits to pad to."
msgstr ""

#: ../../stdlib/base.rst:3682
msgid ""
"Convert an integer to a decimal string, optionally specifying a number of "
"digits to pad to."
msgstr ""

#: ../../stdlib/base.rst:3686
msgid ""
"Convert an integer to an octal string, optionally specifying a number of "
"digits to pad to."
msgstr ""

#: ../../stdlib/base.rst:3690
msgid ""
"Convert an integer to a string in the given base, optionally specifying a "
"number of digits to pad to. The base can be specified as either an integer, "
"or as a ``UInt8`` array of character values to use as digit symbols."
msgstr ""

#: ../../stdlib/base.rst:3694
msgid ""
"Returns an array of the digits of ``n`` in the given base, optionally padded"
" with zeros to a specified size. More significant digits are at higher "
"indexes, such that ``n == sum([digits[k]*base^(k-1) for "
"k=1:length(digits)])``."
msgstr ""

#: ../../stdlib/base.rst:3700
msgid ""
"Fills an array of the digits of ``n`` in the given base. More significant "
"digits are at higher indexes. If the array length is insufficient, the least"
" significant digits are filled up to the array length. If the array length "
"is excessive, the excess portion is filled with zeros."
msgstr ""

#: ../../stdlib/base.rst:3706
msgid "A string giving the literal bit representation of a number."
msgstr ""

#: ../../stdlib/base.rst:3710
msgid ""
"Parse a string as an integer in the given base (default 10), yielding a "
"number of the specified type (default ``Int``)."
msgstr ""

#: ../../stdlib/base.rst:3714
msgid ""
"Parse a string as a decimal floating point number, yielding a number of the "
"specified type."
msgstr ""

#: ../../stdlib/base.rst:3718
msgid ""
"Convert a number to a maximum precision representation (typically ``BigInt``"
" or ``BigFloat``). See ``BigFloat`` for information about some pitfalls with"
" floating-point numbers."
msgstr ""

#: ../../stdlib/base.rst:3722
msgid "Convert a number or numeric array to boolean"
msgstr ""

#: ../../stdlib/base.rst:3726
msgid ""
"Convert a number or array to the default integer type on your platform. "
"Alternatively, ``x`` can be a string, which is parsed as an integer."
msgstr ""

#: ../../stdlib/base.rst:3730
msgid ""
"Convert a number or array to the default unsigned integer type on your "
"platform. Alternatively, ``x`` can be a string, which is parsed as an "
"unsigned integer."
msgstr ""

#: ../../stdlib/base.rst:3734
msgid ""
"Convert a number or array to integer type. If ``x`` is already of integer "
"type it is unchanged, otherwise it converts it to the default integer type "
"on your platform."
msgstr ""

#: ../../stdlib/base.rst:3738
msgid ""
"Convert a number to a signed integer. If the argument is unsigned, it is "
"reinterpreted as signed without checking for overflow."
msgstr ""

#: ../../stdlib/base.rst:3742
msgid ""
"Convert a number to an unsigned integer. If the argument is signed, it is "
"reinterpreted as unsigned without checking for negative values."
msgstr ""

#: ../../stdlib/base.rst:3746
msgid "Convert a number or array to ``Int8`` data type"
msgstr ""

#: ../../stdlib/base.rst:3750
msgid "Convert a number or array to ``Int16`` data type"
msgstr ""

#: ../../stdlib/base.rst:3754
msgid "Convert a number or array to ``Int32`` data type"
msgstr ""

#: ../../stdlib/base.rst:3758
msgid "Convert a number or array to ``Int64`` data type"
msgstr ""

#: ../../stdlib/base.rst:3762
msgid "Convert a number or array to ``Int128`` data type"
msgstr ""

#: ../../stdlib/base.rst:3766
msgid "Convert a number or array to ``UInt8`` data type"
msgstr ""

#: ../../stdlib/base.rst:3770
msgid "Convert a number or array to ``UInt16`` data type"
msgstr ""

#: ../../stdlib/base.rst:3774
msgid "Convert a number or array to ``UInt32`` data type"
msgstr ""

#: ../../stdlib/base.rst:3778
msgid "Convert a number or array to ``UInt64`` data type"
msgstr ""

#: ../../stdlib/base.rst:3782
msgid "Convert a number or array to ``UInt128`` data type"
msgstr ""

#: ../../stdlib/base.rst:3786
msgid "Convert a number or array to ``Float16`` data type"
msgstr ""

#: ../../stdlib/base.rst:3790
msgid "Convert a number or array to ``Float32`` data type"
msgstr ""

#: ../../stdlib/base.rst:3794
msgid "Convert a number or array to ``Float64`` data type"
msgstr ""

#: ../../stdlib/base.rst:3798
msgid ""
"Convert a number or array to ``Float32`` data type, returning true if "
"successful. The result of the conversion is stored in ``out[1]``."
msgstr ""

#: ../../stdlib/base.rst:3802
msgid ""
"Convert a number or array to ``Float64`` data type, returning true if "
"successful. The result of the conversion is stored in ``out[1]``."
msgstr ""

#: ../../stdlib/base.rst:3806
msgid ""
"Convert a number, array, or string to a ``FloatingPoint`` data type. For "
"numeric data, the smallest suitable ``FloatingPoint`` type is used. Converts"
" strings to ``Float64``."
msgstr ""

#: ../../stdlib/base.rst:3808
msgid ""
"This function is not recommended for arrays. It is better to use a more "
"specific function such as ``float32`` or ``float64``."
msgstr ""

#: ../../stdlib/base.rst:3812
msgid ""
"Extract the significand(s) (a.k.a. mantissa), in binary representation, of a"
" floating-point number or array."
msgstr ""

#: ../../stdlib/base.rst:3824
msgid "Get the exponent of a normalized floating-point number."
msgstr ""

#: ../../stdlib/base.rst:3828
msgid ""
"Convert to ``r + i*im`` represented as a ``Complex64`` data type. ``i`` "
"defaults to zero."
msgstr ""

#: ../../stdlib/base.rst:3832
msgid ""
"Convert to ``r + i*im`` represented as a ``Complex128`` data type. ``i`` "
"defaults to zero."
msgstr ""

#: ../../stdlib/base.rst:3836
msgid "Convert real numbers or arrays to complex. ``i`` defaults to zero."
msgstr ""

#: ../../stdlib/base.rst:3840
msgid "Convert a number or array to ``Char`` data type"
msgstr ""

#: ../../stdlib/base.rst:3844
msgid "Byte-swap an integer"
msgstr ""

#: ../../stdlib/base.rst:3848
msgid ""
"Get a hexadecimal string of the binary representation of a floating point "
"number"
msgstr ""

#: ../../stdlib/base.rst:3852
msgid ""
"Convert a hexadecimal string to the floating point number it represents"
msgstr ""

#: ../../stdlib/base.rst:3856
msgid ""
"Convert an arbitrarily long hexadecimal string to its binary representation."
" Returns an Array{UInt8, 1}, i.e. an array of bytes."
msgstr ""

#: ../../stdlib/base.rst:3860
msgid ""
"Convert an array of bytes to its hexadecimal representation. All characters "
"are in lower-case. Returns an ASCIIString."
msgstr ""

#: ../../stdlib/base.rst:3864
msgid "Numbers"
msgstr ""

#: ../../stdlib/base.rst:3868
msgid ""
"Get the multiplicative identity element for the type of x (x can also "
"specify the type itself). For matrices, returns an identity matrix of the "
"appropriate size and type."
msgstr ""

#: ../../stdlib/base.rst:3872
msgid ""
"Get the additive identity element for the type of x (x can also specify the "
"type itself)."
msgstr ""

#: ../../stdlib/base.rst:3877
msgid "The constant pi"
msgstr ""

#: ../../stdlib/base.rst:3881
msgid "The imaginary unit"
msgstr ""

#: ../../stdlib/base.rst:3885
msgid "The constant e"
msgstr ""

#: ../../stdlib/base.rst:3889
msgid "Catalan's constant"
msgstr ""

#: ../../stdlib/base.rst:3893
msgid "Euler's constant"
msgstr ""

#: ../../stdlib/base.rst:3897
msgid "The golden ratio"
msgstr ""

#: ../../stdlib/base.rst:3901
msgid "Positive infinity of type Float64"
msgstr ""

#: ../../stdlib/base.rst:3905
msgid "Positive infinity of type Float32"
msgstr ""

#: ../../stdlib/base.rst:3909
msgid "Positive infinity of type Float16"
msgstr ""

#: ../../stdlib/base.rst:3913
msgid "A not-a-number value of type Float64"
msgstr ""

#: ../../stdlib/base.rst:3917
msgid "A not-a-number value of type Float32"
msgstr ""

#: ../../stdlib/base.rst:3921
msgid "A not-a-number value of type Float16"
msgstr ""

#: ../../stdlib/base.rst:3925
msgid "Test whether a floating point number is subnormal"
msgstr ""

#: ../../stdlib/base.rst:3929
msgid "Test whether a number is finite"
msgstr ""

#: ../../stdlib/base.rst:3933
msgid "Test whether a number is infinite"
msgstr ""

#: ../../stdlib/base.rst:3937
msgid "Test whether a floating point number is not a number (NaN)"
msgstr ""

#: ../../stdlib/base.rst:3941
msgid ""
"Returns positive infinity of the floating point type ``f`` or of the same "
"floating point type as ``f``"
msgstr ""

#: ../../stdlib/base.rst:3945
msgid ""
"Returns NaN (not-a-number) of the floating point type ``f`` or of the same "
"floating point type as ``f``"
msgstr ""

#: ../../stdlib/base.rst:3949
msgid "Get the next floating point number in lexicographic order"
msgstr ""

#: ../../stdlib/base.rst:3953
msgid "Get the previous floating point number in lexicographic order"
msgstr ""

#: ../../stdlib/base.rst:3957
msgid ""
"Test whether ``x`` or all its elements are numerically equal to some integer"
msgstr ""

#: ../../stdlib/base.rst:3961
msgid ""
"Test whether ``x`` or all its elements are numerically equal to some real "
"number"
msgstr ""

#: ../../stdlib/base.rst:3965
msgid ""
"Create a Float32 from ``x``. If ``x`` is not exactly representable then "
"``mode`` determines how ``x`` is rounded."
msgstr ""

#: ../../stdlib/base.rst:3976 ../../stdlib/base.rst:3991
#: ../../stdlib/base.rst:4029
msgid "See ``get_rounding`` for available rounding modes."
msgstr ""

#: ../../stdlib/base.rst:3980
msgid ""
"Create a Float64 from ``x``. If ``x`` is not exactly representable then "
"``mode`` determines how ``x`` is rounded."
msgstr ""

#: ../../stdlib/base.rst:3995
msgid ""
"Create an arbitrary precision integer. ``x`` may be an ``Int`` (or anything "
"that can be converted to an ``Int``) or a ``AbstractString``. The usual "
"mathematical operators are defined for this type, and results are promoted "
"to a ``BigInt``."
msgstr ""

#: ../../stdlib/base.rst:4000
msgid ""
"Create an arbitrary precision floating point number. ``x`` may be an "
"``Integer``, a ``Float64``, a ``AbstractString`` or a ``BigInt``. The usual "
"mathematical operators are defined for this type, and results are promoted "
"to a ``BigFloat``. Note that because floating-point numbers are not exactly-"
"representable in decimal notation, ``BigFloat(2.1)`` may not yield what you "
"expect. You may prefer to initialize constants using strings, e.g., "
"``BigFloat(\"2.1\")``."
msgstr ""

#: ../../stdlib/base.rst:4010
msgid ""
"Get the current floating point rounding mode for type ``T``. Valid modes are"
" ``RoundNearest``, ``RoundToZero``, ``RoundUp``, ``RoundDown``, and "
"``RoundFromZero`` (``BigFloat`` only)."
msgstr ""

#: ../../stdlib/base.rst:4016
msgid ""
"Set the rounding mode of floating point type ``T``. Note that this may "
"affect other types, for instance changing the rounding mode of ``Float64`` "
"will change the rounding mode of ``Float32``. See ``get_rounding`` for "
"available modes"
msgstr ""

#: ../../stdlib/base.rst:4022
msgid ""
"Change the rounding mode of floating point type ``T`` for the duration of "
"``f``. It is logically equivalent to::"
msgstr ""

#: ../../stdlib/base.rst:4032
msgid "Integers"
msgstr ""

#: ../../stdlib/base.rst:4036
msgid "Number of ones in the binary representation of ``x``."
msgstr ""

#: ../../stdlib/base.rst:4045
msgid "Number of zeros in the binary representation of ``x``."
msgstr ""

#: ../../stdlib/base.rst:4054
msgid "Number of zeros leading the binary representation of ``x``."
msgstr ""

#: ../../stdlib/base.rst:4063
msgid "Number of ones leading the binary representation of ``x``."
msgstr ""

#: ../../stdlib/base.rst:4072
msgid "Number of zeros trailing the binary representation of ``x``."
msgstr ""

#: ../../stdlib/base.rst:4081
msgid "Number of ones trailing the binary representation of ``x``."
msgstr ""

#: ../../stdlib/base.rst:4090
msgid "Returns ``true`` if ``x`` is prime, and ``false`` otherwise."
msgstr ""

#: ../../stdlib/base.rst:4099
msgid "Returns a collection of the prime numbers <= ``n``."
msgstr ""

#: ../../stdlib/base.rst:4103
msgid ""
"Returns ``true`` if ``x`` is odd (that is, not divisible by 2), and "
"``false`` otherwise."
msgstr ""

#: ../../stdlib/base.rst:4115
msgid ""
"Returns ``true`` is ``x`` is even (that is, divisible by 2), and ``false`` "
"otherwise."
msgstr ""

#: ../../stdlib/base.rst:4126
msgid "BigFloats"
msgstr ""

#: ../../stdlib/base.rst:4127
msgid ""
"The `BigFloat` type implements arbitrary-precision floating-point arithmetic"
" using the `GNU MPFR library <http://www.mpfr.org/>`_."
msgstr ""

#: ../../stdlib/base.rst:4131
msgid ""
"Get the precision of a floating point number, as defined by the effective "
"number of bits in the mantissa."
msgstr ""

#: ../../stdlib/base.rst:4135
msgid "Get the precision (in bits) currently used for BigFloat arithmetic."
msgstr ""

#: ../../stdlib/base.rst:4139
msgid "Set the precision (in bits) to be used to BigFloat arithmetic."
msgstr ""

#: ../../stdlib/base.rst:4143
msgid ""
"Change the BigFloat arithmetic precision (in bits) for the duration of "
"``f``. It is logically equivalent to::"
msgstr ""

#: ../../stdlib/base.rst:4151
msgid "Random Numbers"
msgstr ""

#: ../../stdlib/base.rst:4153
msgid ""
"Random number generation in Julia uses the `Mersenne Twister library "
"<http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/#dSFMT>`_ via "
"``MersenneTwister`` objects. Julia has a global RNG, which is used by "
"default. Other RNG types can be plugged in by inheriting the ``AbstractRNG``"
" type; they can then be used to have multiple streams of random numbers. "
"Besides ``MersenneTwister``, Julia also provides the ``RandomDevice`` RNG "
"type, which is a wrapper over the OS provided entropy."
msgstr ""

#: ../../stdlib/base.rst:4158
msgid ""
"Most functions related to random generation accept an optional "
"``AbstractRNG`` as the first argument, ``rng`` , which defaults to the "
"global one if not provided. Morever, some of them accept optionally "
"dimension specifications ``dims...`` (which can be given as a tuple) to "
"generate arrays of random values."
msgstr ""

#: ../../stdlib/base.rst:4161
msgid ""
"A ``MersenneTwister`` or ``RandomDevice`` RNG can generate random numbers of"
" the following types: ``Float16``, ``Float32``, ``Float64``, ``Bool``, "
"``Int8``, ``UInt8``, ``Int16``, ``UInt16``, ``Int32``, ``UInt32``, "
"``Int64``, ``UInt64``, ``Int128``, ``UInt128``, ``BigInt`` (or complex "
"numbers of those types). Random floating point numbers are generated "
"uniformly in [0,1). As ``BigInt`` represents unbounded integers, the "
"interval must be specified (e.g. ``rand(big(1:6))``)."
msgstr ""

#: ../../stdlib/base.rst:4169
msgid ""
"Reseed the random number generator. If a ``seed`` is provided, the RNG will "
"give a reproducible sequence of numbers, otherwise Julia will get entropy "
"from the system. For ``MersenneTwister``, the ``seed`` may be a non-negative"
" integer, a vector of ``UInt32`` integers or a filename, in which case the "
"seed is read from a file. ``RandomDevice`` does not support seeding."
msgstr ""

#: ../../stdlib/base.rst:4175
msgid ""
"Create a ``MersenneTwister`` RNG object. Different RNG objects can have "
"their own seeds, which may be useful for generating different streams of "
"random numbers."
msgstr ""

#: ../../stdlib/base.rst:4179
msgid ""
"Create a ``RandomDevice`` RNG object. Two such objects will always generate "
"different streams of random numbers."
msgstr ""

#: ../../stdlib/base.rst:4183
msgid ""
"Pick a random element or array of random elements from the set of values "
"specified by ``S``; ``S`` can be"
msgstr ""

#: ../../stdlib/base.rst:4185
msgid "an indexable collection (for example ``1:n`` or ``['x','y','z']``), or"
msgstr ""

#: ../../stdlib/base.rst:4187
msgid ""
"a type: the set of values to pick from is then equivalent to "
"``typemin(S):typemax(S)`` for integers (this is not applicable to "
"``BigInt``), and to [0,1) for floating point numbers;"
msgstr ""

#: ../../stdlib/base.rst:4189
msgid "``S`` defaults to ``Float64``."
msgstr ""

#: ../../stdlib/base.rst:4193
msgid ""
"Populate the array A with random values. If the indexable collection "
"``coll`` is specified, the values are picked randomly from ``coll``. This is"
" equivalent to ``copy!(A, rand(rng, coll, size(A)))`` or ``copy!(A, "
"rand(rng, eltype(A), size(A)))`` but without allocating a new array."
msgstr ""

#: ../../stdlib/base.rst:4197
msgid ""
"Generate a random boolean value. Optionally, generate a ``BitArray`` of "
"random boolean values."
msgstr ""

#: ../../stdlib/base.rst:4201
msgid ""
"Generate a normally-distributed random number with mean 0 and standard "
"deviation 1. Optionally generate an array of normally-distributed random "
"numbers."
msgstr ""

#: ../../stdlib/base.rst:4205
msgid ""
"Fill the array A with normally-distributed (mean 0, standard deviation 1) "
"random numbers. Also see the rand function."
msgstr ""

#: ../../stdlib/base.rst:4209
msgid ""
"Generate a random number according to the exponential distribution with "
"scale 1. Optionally generate an array of such random numbers."
msgstr ""

#: ../../stdlib/base.rst:4213
msgid ""
"Fill the array A with random numbers following the exponential distribution "
"(with scale 1)."
msgstr ""

#: ../../stdlib/base.rst:4216
msgid "Arrays"
msgstr ""

#: ../../stdlib/base.rst:4219
msgid "Basic functions"
msgstr ""

#: ../../stdlib/base.rst:4223
msgid "Returns the number of dimensions of A"
msgstr ""

#: ../../stdlib/base.rst:4227
msgid ""
"Returns a tuple containing the dimensions of A. Optionally you can specify "
"the dimension(s) you want the length of, and get the length of that "
"dimension, or a tuple of the lengths of dimensions you asked for.::"
msgstr ""

#: ../../stdlib/base.rst:4239
msgid "Tests whether A or its elements are of type T"
msgstr ""

#: ../../stdlib/base.rst:4243
msgid "Returns the number of elements in A"
msgstr ""

#: ../../stdlib/base.rst:4247
msgid ""
"Creates an iterable object for visiting each multi-dimensional index of the "
"AbstractArray ``A``.  Example for a 2-d array::"
msgstr ""

#: ../../stdlib/base.rst:4273
msgid ""
"Counts the number of nonzero values in array A (dense or sparse). Note that "
"this is not a constant-time operation. For sparse matrices, one should "
"usually use ``nnz``, which returns the number of stored values."
msgstr ""

#: ../../stdlib/base.rst:4277
msgid "Convert an array to its complex conjugate in-place"
msgstr ""

#: ../../stdlib/base.rst:4281
msgid ""
"Returns the distance in memory (in number of elements) between adjacent "
"elements in dimension k"
msgstr ""

#: ../../stdlib/base.rst:4285
msgid "Returns a tuple of the memory strides in each dimension"
msgstr ""

#: ../../stdlib/base.rst:4289
msgid ""
"Returns a tuple of subscripts into an array with dimensions ``dims``, "
"corresponding to the linear index ``index``"
msgstr ""

#: ../../stdlib/base.rst:4291
msgid ""
"**Example** ``i, j, ... = ind2sub(size(A), indmax(A))`` provides the indices"
" of the maximum element"
msgstr ""

#: ../../stdlib/base.rst:4295
msgid ""
"Returns a tuple of subscripts into array ``a`` corresponding to the linear "
"index ``index``"
msgstr ""

#: ../../stdlib/base.rst:4299
msgid ""
"The inverse of ``ind2sub``, returns the linear index corresponding to the "
"provided subscripts"
msgstr ""

#: ../../stdlib/base.rst:4302
msgid "Constructors"
msgstr ""

#: ../../stdlib/base.rst:4306
msgid ""
"Construct an uninitialized dense array. ``dims`` may be a tuple or a series "
"of integer arguments."
msgstr ""

#: ../../stdlib/base.rst:4310
msgid ""
"Construct a 1-d array of the specified type. This is usually called with the"
" syntax ``Type[]``. Element values can be specified using "
"``Type[a,b,c,...]``."
msgstr ""

#: ../../stdlib/base.rst:4314
msgid ""
"Construct an uninitialized cell array (heterogeneous array). ``dims`` can be"
" either a tuple or a series of integer arguments."
msgstr ""

#: ../../stdlib/base.rst:4317
msgid ""
"Create an array of all zeros of specified type. The type defaults to Float64"
" if not specified."
msgstr ""

#: ../../stdlib/base.rst:4321
msgid ""
"Create an array of all zeros with the same element type and shape as A."
msgstr ""

#: ../../stdlib/base.rst:4325
msgid ""
"Create an array of all ones of specified type. The type defaults to Float64 "
"if not specified."
msgstr ""

#: ../../stdlib/base.rst:4329
msgid "Create an array of all ones with the same element type and shape as A."
msgstr ""

#: ../../stdlib/base.rst:4333
msgid "Create a ``BitArray`` with all values set to true"
msgstr ""

#: ../../stdlib/base.rst:4337
msgid "Create a ``BitArray`` with all values set to false"
msgstr ""

#: ../../stdlib/base.rst:4341
msgid ""
"Create an array filled with the value ``x``. For example, ``fill(1.0, "
"(10,10))`` returns a  10x10 array of floats, with each element initialized "
"to 1.0."
msgstr ""

#: ../../stdlib/base.rst:4345
msgid ""
"If ``x`` is an object reference, all elements will refer to the same object."
" ``fill(Foo(), dims)`` will return an array filled with the result of "
"evaluating ``Foo()`` once."
msgstr ""

#: ../../stdlib/base.rst:4350
msgid ""
"Fill array ``A`` with the value ``x``. If ``x`` is an object reference, all "
"elements will refer to the same object. ``fill!(A, Foo())`` will return "
"``A`` filled with the result of evaluating ``Foo()`` once."
msgstr ""

#: ../../stdlib/base.rst:4355
msgid ""
"Create an array with the same data as the given array, but with different "
"dimensions. An implementation for a particular type of array may choose "
"whether the data is copied or shared."
msgstr ""

#: ../../stdlib/base.rst:4359
msgid ""
"Create an uninitialized array of the same type as the given array, but with "
"the specified element type and dimensions. The second and third arguments "
"are both optional. The ``dims`` argument may be a tuple or a series of "
"integer arguments."
msgstr ""

#: ../../stdlib/base.rst:4363
msgid ""
"Change the type-interpretation of a block of memory. For example, "
"``reinterpret(Float32, uint32(7))`` interprets the 4 bytes corresponding to "
"``uint32(7)`` as a ``Float32``. For arrays, this constructs an array with "
"the same binary data as the given array, but with the specified element "
"type."
msgstr ""

#: ../../stdlib/base.rst:4367
msgid "n-by-n identity matrix"
msgstr ""

#: ../../stdlib/base.rst:4371
msgid "m-by-n identity matrix"
msgstr ""

#: ../../stdlib/base.rst:4375
msgid ""
"Constructs an identity matrix of the same dimensions and type as ``A``."
msgstr ""

#: ../../stdlib/base.rst:4379
msgid ""
"Construct a vector of ``n`` linearly-spaced elements from ``start`` to "
"``stop``. See also: :func:`linrange` that constructs a range object."
msgstr ""

#: ../../stdlib/base.rst:4384
msgid ""
"Construct a vector of ``n`` logarithmically-spaced numbers from ``10^start``"
" to ``10^stop``."
msgstr ""

#: ../../stdlib/base.rst:4387
msgid "Mathematical operators and functions"
msgstr ""

#: ../../stdlib/base.rst:4389
msgid "All mathematical operations and functions are supported for arrays"
msgstr ""

#: ../../stdlib/base.rst:4393
msgid ""
"Broadcasts the arrays ``As`` to a common size by expanding singleton "
"dimensions, and returns an array of the results ``f(as...)`` for each "
"position."
msgstr ""

#: ../../stdlib/base.rst:4397
msgid ""
"Like ``broadcast``, but store the result of ``broadcast(f, As...)`` in the "
"``dest`` array. Note that ``dest`` is only used to store the result, and "
"does not supply arguments to ``f`` unless it is also listed in the ``As``, "
"as in ``broadcast!(f, A, A, B)`` to perform ``A[:] = broadcast(f, A, B)``."
msgstr ""

#: ../../stdlib/base.rst:4404
msgid ""
"Like ``broadcast``, but allocates a ``BitArray`` to store the result, rather"
" then an ``Array``."
msgstr ""

#: ../../stdlib/base.rst:4408
msgid ""
"Returns a function ``broadcast_f`` such that ``broadcast_function(f)(As...) "
"=== broadcast(f, As...)``. Most useful in the form ``const broadcast_f = "
"broadcast_function(f)``."
msgstr ""

#: ../../stdlib/base.rst:4412
msgid "Like ``broadcast_function``, but for ``broadcast!``."
msgstr ""

#: ../../stdlib/base.rst:4415
msgid "Indexing, Assignment, and Concatenation"
msgstr ""

#: ../../stdlib/base.rst:4419
msgid ""
"Returns a subset of array ``A`` as specified by ``inds``, where each ``ind``"
" may be an ``Int``, a ``Range``, or a ``Vector``."
msgstr ""

#: ../../stdlib/base.rst:4423
msgid ""
"Returns a SubArray, which stores the input ``A`` and ``inds`` rather than "
"computing the result immediately. Calling ``getindex`` on a SubArray "
"computes the indices on the fly."
msgstr ""

#: ../../stdlib/base.rst:4427
msgid ""
"Returns the \"parent array\" of an array view type (e.g., SubArray), or the "
"array itself if it is not a view"
msgstr ""

#: ../../stdlib/base.rst:4431
msgid ""
"From an array view ``A``, returns the corresponding indexes in the parent"
msgstr ""

#: ../../stdlib/base.rst:4435
msgid ""
"Return all the data of ``A`` where the index for dimension ``d`` equals "
"``i``. Equivalent to ``A[:,:,...,i,:,:,...]`` where ``i`` is in position "
"``d``."
msgstr ""

#: ../../stdlib/base.rst:4439
msgid ""
"Create a view of the given indexes of array ``A``, dropping dimensions "
"indexed with scalars."
msgstr ""

#: ../../stdlib/base.rst:4444
msgid ""
"Store values from array ``X`` within some subset of ``A`` as specified by "
"``inds``."
msgstr ""

#: ../../stdlib/base.rst:4448
msgid ""
"Broadcasts the ``inds`` arrays to a common size like ``broadcast``, and "
"returns an array of the results ``A[ks...]``, where ``ks`` goes over the "
"positions in the broadcast."
msgstr ""

#: ../../stdlib/base.rst:4452
msgid ""
"Broadcasts the ``X`` and ``inds`` arrays to a common size and stores the "
"value from each position in ``X`` at the indices given by the same positions"
" in ``inds``."
msgstr ""

#: ../../stdlib/base.rst:4456
msgid ""
"Concatenate the input arrays along the specified dimensions in the iterable "
"``dims``. For dimensions not in ``dims``, all input arrays should have the "
"same size, which will also be the size of the output array along that "
"dimension. For dimensions in ``dims``, the size of the output array is the "
"sum of the sizes of the input arrays along that dimension. If ``dims`` is a "
"single number, the different arrays are tightly stacked along that "
"dimension. If ``dims`` is an iterable containing several dimensions, this "
"allows to construct block diagonal matrices and their higher-dimensional "
"analogues by simultaneously increasing several dimensions for every new "
"input array and putting zero blocks elsewhere. For example, `cat([1,2], "
"matrices...)` builds a block diagonal matrix, i.e. a block matrix with "
"`matrices[1]`, `matrices[2]`, ... as diagonal blocks and matching zero "
"blocks away from the diagonal."
msgstr ""

#: ../../stdlib/base.rst:4460
msgid "Concatenate along dimension 1"
msgstr ""

#: ../../stdlib/base.rst:4464
msgid "Concatenate along dimension 2"
msgstr ""

#: ../../stdlib/base.rst:4468
msgid ""
"Horizontal and vertical concatenation in one call. This function is called "
"for block matrix syntax. The first argument specifies the number of "
"arguments to concatenate in each block row. For example, ``[a b;c d e]`` "
"calls ``hvcat((2,3),a,b,c,d,e)``."
msgstr ""

#: ../../stdlib/base.rst:4473
msgid ""
"If the first argument is a single integer ``n``, then all block rows are "
"assumed to have ``n`` block columns."
msgstr ""

#: ../../stdlib/base.rst:4477
msgid "Reverse ``A`` in dimension ``d``."
msgstr ""

#: ../../stdlib/base.rst:4481
msgid "Equivalent to ``flipdim(A,1)``."
msgstr ""

#: ../../stdlib/base.rst:4485
msgid "Equivalent to ``flipdim(A,2)``."
msgstr ""

#: ../../stdlib/base.rst:4489
msgid ""
"Circularly shift the data in an array. The second argument is a vector "
"giving the amount to shift in each dimension."
msgstr ""

#: ../../stdlib/base.rst:4493
msgid ""
"Return a vector of the linear indexes of the non-zeros in ``A`` (determined "
"by ``A[i]!=0``).  A common use of this is to convert a boolean array to an "
"array of indexes of the ``true`` elements."
msgstr ""

#: ../../stdlib/base.rst:4500
msgid ""
"Return a vector of the linear indexes of  ``A`` where ``f`` returns true."
msgstr ""

#: ../../stdlib/base.rst:4504
msgid ""
"Return a vector of indexes for each dimension giving the locations of the "
"non-zeros in ``A`` (determined by ``A[i]!=0``)."
msgstr ""

#: ../../stdlib/base.rst:4508
msgid ""
"Return a tuple ``(I, J, V)`` where ``I`` and ``J`` are the row and column "
"indexes of the non-zero values in matrix ``A``, and ``V`` is a vector of the"
" non-zero values."
msgstr ""

#: ../../stdlib/base.rst:4514
msgid ""
"Return the index of the first non-zero value in ``A`` (determined by "
"``A[i]!=0``)."
msgstr ""

#: ../../stdlib/base.rst:4518
msgid "Return the index of the first element equal to ``v`` in ``A``."
msgstr ""

#: ../../stdlib/base.rst:4522
msgid ""
"Return the index of the first element of ``A`` for which ``predicate`` "
"returns true."
msgstr ""

#: ../../stdlib/base.rst:4526
msgid ""
"Find the next index >= ``i`` of a non-zero element of ``A``, or ``0`` if not"
" found."
msgstr ""

#: ../../stdlib/base.rst:4530
msgid ""
"Find the next index >= ``i`` of an element of ``A`` for which ``predicate`` "
"returns true, or ``0`` if not found."
msgstr ""

#: ../../stdlib/base.rst:4534
msgid ""
"Find the next index >= ``i`` of an element of ``A`` equal to ``v`` (using "
"``==``), or ``0`` if not found."
msgstr ""

#: ../../stdlib/base.rst:4539
msgid ""
"Permute the dimensions of array ``A``. ``perm`` is a vector specifying a "
"permutation of length ``ndims(A)``. This is a generalization of transpose "
"for multi-dimensional arrays. Transpose is equivalent to ``permutedims(A, "
"[2,1])``."
msgstr ""

#: ../../stdlib/base.rst:4543
msgid ""
"Like :func:`permutedims`, except the inverse of the given permutation is "
"applied."
msgstr ""

#: ../../stdlib/base.rst:4547
msgid ""
"Permute the dimensions of array ``src`` and store the result in the array "
"``dest``. ``perm`` is a vector specifying a permutation of length "
"``ndims(src)``. The preallocated array ``dest`` should have ``size(dest) == "
"size(src)[perm]`` and is completely overwritten. No in-place permutation is "
"supported and unexpected results will happen if `src` and `dest` have "
"overlapping memory regions."
msgstr ""

#: ../../stdlib/base.rst:4551
msgid ""
"Remove the dimensions specified by ``dims`` from array ``A``. Elements of "
"``dims`` must be unique and within the range ``1:ndims(A)``."
msgstr ""

#: ../../stdlib/base.rst:4556
msgid "Vectorize an array using column-major convention."
msgstr ""

#: ../../stdlib/base.rst:4560
msgid ""
"Check two array shapes for compatibility, allowing trailing singleton "
"dimensions, and return whichever shape has more dimensions."
msgstr ""

#: ../../stdlib/base.rst:4565
msgid ""
"Throw an error if the specified indexes are not in bounds for the given "
"array."
msgstr ""

#: ../../stdlib/base.rst:4569
msgid ""
"Return a vector consisting of a random subsequence of the given array ``A``,"
" where each element of ``A`` is included (in order) with independent "
"probability ``p``.   (Complexity is linear in ``p*length(A)``, so this "
"function is efficient even if ``p`` is small and ``A`` is large.)  "
"Technically, this process is known as \"Bernoulli sampling\" of ``A``."
msgstr ""

#: ../../stdlib/base.rst:4577
msgid ""
"Like ``randsubseq``, but the results are stored in ``S`` (which is resized "
"as needed)."
msgstr ""

#: ../../stdlib/base.rst:4582
msgid "Array functions"
msgstr ""

#: ../../stdlib/base.rst:4586
msgid "Cumulative product along a dimension. The dimension defaults to 1."
msgstr ""

#: ../../stdlib/base.rst:4591
msgid ""
"Cumulative product of ``A`` along a dimension, storing the result in ``B``. "
"The dimension defaults to 1."
msgstr ""

#: ../../stdlib/base.rst:4596
msgid "Cumulative sum along a dimension. The dimension defaults to 1."
msgstr ""

#: ../../stdlib/base.rst:4601
msgid ""
"Cumulative sum of ``A`` along a dimension, storing the result in ``B``. The "
"dimension defaults to 1."
msgstr ""

#: ../../stdlib/base.rst:4606
msgid ""
"Cumulative sum along a dimension, using the Kahan-Babuska-Neumaier "
"compensated summation algorithm for additional accuracy. The dimension "
"defaults to 1."
msgstr ""

#: ../../stdlib/base.rst:4612
msgid "Cumulative minimum along a dimension. The dimension defaults to 1."
msgstr ""

#: ../../stdlib/base.rst:4617
msgid "Cumulative maximum along a dimension. The dimension defaults to 1."
msgstr ""

#: ../../stdlib/base.rst:4622
msgid "Finite difference operator of matrix or vector."
msgstr ""

#: ../../stdlib/base.rst:4626
msgid ""
"Compute differences along vector ``F``, using ``h`` as the spacing between "
"points. The default spacing is one."
msgstr ""

#: ../../stdlib/base.rst:4631
msgid "Rotate matrix ``A`` 180 degrees."
msgstr ""

#: ../../stdlib/base.rst:4635
msgid "Rotate matrix ``A`` left 90 degrees."
msgstr ""

#: ../../stdlib/base.rst:4639
msgid "Rotate matrix ``A`` right 90 degrees."
msgstr ""

#: ../../stdlib/base.rst:4643
msgid ""
"Reduce 2-argument function ``f`` along dimensions of ``A``. ``dims`` is a "
"vector specifying the dimensions to reduce, and ``initial`` is the initial "
"value to use in the reductions."
msgstr ""

#: ../../stdlib/base.rst:4647
msgid ""
"The associativity of the reduction is implementation-dependent; if you need "
"a particular associativity, e.g. left-to-right, you should write your own "
"loop. See documentation for ``reduce``."
msgstr ""

#: ../../stdlib/base.rst:4653
msgid ""
"Transform the given dimensions of array ``A`` using function ``f``. ``f`` is"
" called on each slice of ``A`` of the form ``A[...,:,...,:,...]``. ``dims`` "
"is an integer vector specifying where the colons go in this expression. The "
"results are concatenated along the remaining dimensions. For example, if "
"``dims`` is ``[1,2]`` and A is 4-dimensional, ``f`` is called on "
"``A[:,:,i,j]`` for all ``i`` and ``j``."
msgstr ""

#: ../../stdlib/base.rst:4662
msgid ""
"Returns the sum of all array elements, using the Kahan-Babuska-Neumaier "
"compensated summation algorithm for additional accuracy."
msgstr ""

#: ../../stdlib/base.rst:4666
msgid ""
"Given a ``dims`` tuple of integers ``(m, n, ...)``, call ``f`` on all "
"combinations of integers in the ranges ``1:m``, ``1:n``, etc."
msgstr ""

#: ../../stdlib/base.rst:4678
msgid "BitArrays"
msgstr ""

#: ../../stdlib/base.rst:4682
msgid "Converts a numeric array to a packed boolean array"
msgstr ""

#: ../../stdlib/base.rst:4686
msgid "Converts a packed boolean array to an array of booleans"
msgstr ""

#: ../../stdlib/base.rst:4690
msgid "Performs a bitwise not operation on B. See :ref:`~ operator <~>`."
msgstr ""

#: ../../stdlib/base.rst:4694
msgid "Left rotation operator."
msgstr ""

#: ../../stdlib/base.rst:4698
msgid "Right rotation operator."
msgstr ""

#: ../../stdlib/base.rst:4702
msgid "Combinatorics"
msgstr ""

#: ../../stdlib/base.rst:4706
msgid "Compute the kth lexicographic permutation of a vector."
msgstr ""

#: ../../stdlib/base.rst:4710
msgid ""
"Return the ``k`` that generated permutation ``p``. Note that "
"``nthperm(nthperm([1:n], k)) == k`` for ``1 <= k <= factorial(n)``."
msgstr ""

#: ../../stdlib/base.rst:4715
msgid "In-place version of :func:`nthperm`."
msgstr ""

#: ../../stdlib/base.rst:4719
msgid "Construct a random permutation of the given length."
msgstr ""

#: ../../stdlib/base.rst:4723
msgid "Return the inverse permutation of v."
msgstr ""

#: ../../stdlib/base.rst:4727
msgid "Returns true if v is a valid permutation."
msgstr ""

#: ../../stdlib/base.rst:4731
msgid ""
"Permute vector ``v`` in-place, according to permutation ``p``.  No checking "
"is done to verify that ``p`` is a permutation."
msgstr ""

#: ../../stdlib/base.rst:4734
msgid ""
"To return a new permutation, use ``v[p]``.  Note that this is generally "
"faster than ``permute!(v,p)`` for large vectors."
msgstr ""

#: ../../stdlib/base.rst:4739
msgid "Like permute!, but the inverse of the given permutation is applied."
msgstr ""

#: ../../stdlib/base.rst:4743
msgid "Construct a random cyclic permutation of the given length."
msgstr ""

#: ../../stdlib/base.rst:4747
msgid "Return a randomly permuted copy of ``v``."
msgstr ""

#: ../../stdlib/base.rst:4751
msgid "In-place version of :func:`shuffle`."
msgstr ""

#: ../../stdlib/base.rst:4755
msgid "Return a copy of ``v`` reversed from start to stop."
msgstr ""

#: ../../stdlib/base.rst:4759
msgid ""
"Given an index ``i`` in ``reverse(v)``, return the corresponding index in "
"``v`` so that ``v[reverseind(v,i)] == reverse(v)[i]``. (This can be "
"nontrivial in the case where ``v`` is a Unicode string.)"
msgstr ""

#: ../../stdlib/base.rst:4765
msgid "In-place version of :func:`reverse`."
msgstr ""

#: ../../stdlib/base.rst:4769
msgid ""
"Generate all combinations of ``n`` elements from an indexable object.  "
"Because the number of combinations can be very large, this function returns "
"an iterator object. Use ``collect(combinations(array,n))`` to get an array "
"of all combinations."
msgstr ""

#: ../../stdlib/base.rst:4776
msgid ""
"Generate all permutations of an indexable object.  Because the number of "
"permutations can be very large, this function returns an iterator object. "
"Use ``collect(permutations(array))`` to get an array of all permutations."
msgstr ""

#: ../../stdlib/base.rst:4783
msgid ""
"Generate all integer arrays that sum to ``n``. Because the number of "
"partitions can be very large, this function returns an iterator object. Use "
"``collect(partitions(n))`` to get an array of all partitions. The number of "
"partitions to generate can be efficiently computed using "
"``length(partitions(n))``."
msgstr ""

#: ../../stdlib/base.rst:4791
msgid ""
"Generate all arrays of ``m`` integers that sum to ``n``. Because the number "
"of partitions can be very large, this function returns an iterator object. "
"Use ``collect(partitions(n,m))`` to get an array of all partitions. The "
"number of partitions to generate can be efficiently computed using "
"``length(partitions(n,m))``."
msgstr ""

#: ../../stdlib/base.rst:4799
msgid ""
"Generate all set partitions of the elements of an array, represented as "
"arrays of arrays. Because the number of partitions can be very large, this "
"function returns an iterator object. Use ``collect(partitions(array))`` to "
"get an array of all partitions. The number of partitions to generate can be "
"efficiently computed using ``length(partitions(array))``."
msgstr ""

#: ../../stdlib/base.rst:4808
msgid ""
"Generate all set partitions of the elements of an array into exactly m "
"subsets, represented as arrays of arrays. Because the number of partitions "
"can be very large, this function returns an iterator object. Use "
"``collect(partitions(array,m))`` to get an array of all partitions. The "
"number of partitions into m subsets is equal to the Stirling number of the "
"second kind and can be efficiently computed using "
"``length(partitions(array,m))``."
msgstr ""

#: ../../stdlib/base.rst:4817
msgid "Statistics"
msgstr ""

#: ../../stdlib/base.rst:4821
msgid ""
"Compute the mean of whole array ``v``, or optionally along the dimensions in"
" ``region``. Note: Julia does not ignore ``NaN`` values in the computation. "
"For applications requiring the handling of missing data, the ``DataArray`` "
"package is recommended."
msgstr ""

#: ../../stdlib/base.rst:4828
msgid ""
"Compute the mean of ``v`` over the singleton dimensions of ``r``, and write "
"results to ``r``."
msgstr ""

#: ../../stdlib/base.rst:4832
msgid ""
"Compute the sample standard deviation of a vector or array ``v``, optionally"
" along dimensions in ``region``. The algorithm returns an estimator of the "
"generative distribution's standard deviation under the assumption that each "
"entry of ``v`` is an IID drawn from that generative distribution. This "
"computation is equivalent to calculating ``sqrt(sum((v - mean(v)).^2) / "
"(length(v) - 1))``. Note: Julia does not ignore ``NaN`` values in the "
"computation. For applications requiring the handling of missing data, the "
"``DataArray`` package is recommended."
msgstr ""

#: ../../stdlib/base.rst:4839
msgid ""
"Compute the sample standard deviation of a vector ``v`` with known mean "
"``m``. Note: Julia does not ignore ``NaN`` values in the computation."
msgstr ""

#: ../../stdlib/base.rst:4844
msgid ""
"Compute the sample variance of a vector or array ``v``, optionally along "
"dimensions in ``region``. The algorithm will return an estimator of the "
"generative distribution's variance under the assumption that each entry of "
"``v`` is an IID drawn from that generative distribution. This computation is"
" equivalent to calculating ``sum((v - mean(v)).^2) / (length(v) - 1)``. "
"Note: Julia does not ignore ``NaN`` values in the computation. For "
"applications requiring the handling of missing data, the ``DataArray`` "
"package is recommended."
msgstr ""

#: ../../stdlib/base.rst:4851
msgid ""
"Compute the sample variance of a vector ``v`` with known mean ``m``. Note: "
"Julia does not ignore ``NaN`` values in the computation."
msgstr ""

#: ../../stdlib/base.rst:4856
msgid ""
"Compute the middle of a scalar value, which is equivalent to ``x`` itself, "
"but of the type of ``middle(x, x)`` for consistency."
msgstr ""

#: ../../stdlib/base.rst:4861
msgid ""
"Compute the middle of two reals ``x`` and ``y``, which is equivalent in both"
" value and type to computing their mean (``(x + y) / 2``)."
msgstr ""

#: ../../stdlib/base.rst:4866
msgid ""
"Compute the middle of a range, which consists in computing the mean of its "
"extrema. Since a range is sorted, the mean is performed with the first and "
"last element."
msgstr ""

#: ../../stdlib/base.rst:4871
msgid ""
"Compute the middle of an array, which consists in finding its extrema and "
"then computing their mean."
msgstr ""

#: ../../stdlib/base.rst:4876
msgid ""
"Compute the median of a vector ``v``. ``NaN`` is returned if the data "
"contains any ``NaN`` values. For applications requiring the handling of "
"missing data, the ``DataArrays`` package is recommended."
msgstr ""

#: ../../stdlib/base.rst:4882
msgid "Like ``median``, but may overwrite the input vector."
msgstr ""

#: ../../stdlib/base.rst:4886
msgid ""
"Compute the histogram of ``v``, optionally using approximately ``n`` bins. "
"The return values are a range ``e``, which correspond to the edges of the "
"bins, and ``counts`` containing the number of elements of ``v`` in each bin."
" Note: Julia does not ignore ``NaN`` values in the computation."
msgstr ""

#: ../../stdlib/base.rst:4894
msgid ""
"Compute the histogram of ``v`` using a vector/range ``e`` as the edges for "
"the bins. The result will be a vector of length ``length(e) - 1``, such that"
" the element at location ``i`` satisfies ``sum(e[i] .< v .<= e[i+1])``. "
"Note: Julia does not ignore ``NaN`` values in the computation."
msgstr ""

#: ../../stdlib/base.rst:4901
msgid ""
"Compute the histogram of ``v``, using a vector/range ``e`` as the edges for "
"the bins. This function writes the resultant counts to a pre-allocated array"
" ``counts``."
msgstr ""

#: ../../stdlib/base.rst:4906
msgid ""
"Compute a \"2d histogram\" of a set of N points specified by N-by-2 matrix "
"``M``. Arguments ``e1`` and ``e2`` are bins for each dimension, specified "
"either as integer bin counts or vectors of bin edges. The result is a tuple "
"of ``edge1`` (the bin edges used in the first dimension), ``edge2`` (the bin"
" edges used in the second dimension), and ``counts``, a histogram matrix of "
"size ``(length(edge1)-1, length(edge2)-1)``. Note: Julia does not ignore "
"``NaN`` values in the computation."
msgstr ""

#: ../../stdlib/base.rst:4916
msgid ""
"Compute a \"2d histogram\" with respect to the bins delimited by the edges "
"given in ``e1`` and ``e2``. This function writes the results to a pre-"
"allocated array ``counts``."
msgstr ""

#: ../../stdlib/base.rst:4922
msgid ""
"Compute *nice* bin ranges for the edges of a histogram of ``v``, using "
"approximately ``n`` bins. The resulting step sizes will be 1, 2 or 5 "
"multiplied by a power of 10. Note: Julia does not ignore ``NaN`` values in "
"the computation."
msgstr ""

#: ../../stdlib/base.rst:4929
msgid ""
"Compute the midpoints of the bins with edges ``e``. The result is a "
"vector/range of length ``length(e) - 1``. Note: Julia does not ignore "
"``NaN`` values in the computation."
msgstr ""

#: ../../stdlib/base.rst:4935
msgid ""
"Compute the quantiles of a vector ``v`` at a specified set of probability "
"values ``p``. Note: Julia does not ignore ``NaN`` values in the computation."
msgstr ""

#: ../../stdlib/base.rst:4940
msgid ""
"Compute the quantile of a vector ``v`` at the probability ``p``. Note: Julia"
" does not ignore ``NaN`` values in the computation."
msgstr ""

#: ../../stdlib/base.rst:4945
msgid "Like ``quantile``, but overwrites the input vector."
msgstr ""

#: ../../stdlib/base.rst:4949
msgid ""
"Compute the Pearson covariance between the vector(s) in ``v1`` and ``v2``. "
"Here, ``v1`` and ``v2`` can be either vectors or matrices."
msgstr ""

#: ../../stdlib/base.rst:4952
msgid "This function accepts three keyword arguments:"
msgstr ""

#: ../../stdlib/base.rst:4954
msgid ""
"``vardim``: the dimension of variables. When ``vardim = 1``, variables are "
"considered in columns while observations in rows; when ``vardim = 2``, "
"variables are in rows while observations in columns. By default, it is set "
"to ``1``."
msgstr ""

#: ../../stdlib/base.rst:4959
msgid ""
"``corrected``: whether to apply Bessel's correction (divide by ``n-1`` "
"instead of ``n``). By default, it is set to ``true``."
msgstr ""

#: ../../stdlib/base.rst:4962
msgid ""
"``mean``: allow users to supply mean values that are known. By default, it "
"is set to ``nothing``, which indicates that the mean(s) are unknown, and the"
" function will compute the mean. Users can use ``mean=0`` to indicate that "
"the input data are centered, and hence there's no need to subtract the mean."
msgstr ""

#: ../../stdlib/base.rst:4968
msgid ""
"The size of the result depends on the size of ``v1`` and ``v2``. When both "
"``v1`` and ``v2`` are vectors, it returns the covariance between them as a "
"scalar. When either one is a matrix, it returns a covariance matrix of size "
"``(n1, n2)``, where ``n1`` and ``n2`` are the numbers of slices in ``v1`` "
"and ``v2``, which depend on the setting of ``vardim``."
msgstr ""

#: ../../stdlib/base.rst:4974
msgid "Note: ``v2`` can be omitted, which indicates ``v2 = v1``."
msgstr ""

#: ../../stdlib/base.rst:4979
msgid ""
"Compute the Pearson correlation between the vector(s) in ``v1`` and ``v2``."
msgstr ""

#: ../../stdlib/base.rst:4981
msgid ""
"Users can use the keyword argument ``vardim`` to specify the variable "
"dimension, and ``mean`` to supply pre-computed mean values."
msgstr ""

#: ../../stdlib/base.rst:4986
msgid "Signal Processing"
msgstr ""

#: ../../stdlib/base.rst:4988
msgid ""
"Fast Fourier transform (FFT) functions in Julia are largely implemented by "
"calling functions from `FFTW <http://www.fftw.org>`_. By default, Julia does"
" not use multi-threaded FFTW. Higher performance may be obtained by "
"experimenting with multi-threading. Use `FFTW.set_num_threads(np)` to use "
"`np` threads."
msgstr ""

#: ../../stdlib/base.rst:4996
msgid ""
"Performs a multidimensional FFT of the array ``A``.  The optional ``dims`` "
"argument specifies an iterable subset of dimensions (e.g. an integer, range,"
" tuple, or array) to transform along.  Most efficient if the size of ``A`` "
"along the transformed dimensions is a product of small primes; see "
":func:`nextprod`.  See also :func:`plan_fft` for even greater efficiency."
msgstr ""

#: ../../stdlib/base.rst:5003
msgid ""
"A one-dimensional FFT computes the one-dimensional discrete Fourier "
"transform (DFT) as defined by"
msgstr ""

#: ../../stdlib/base.rst:5012
msgid ""
"A multidimensional FFT simply performs this operation along each transformed"
" dimension of ``A``."
msgstr ""

#: ../../stdlib/base.rst:5015
msgid ""
"Higher performance is usually possible with multi-threading. Use "
"`FFTW.set_num_threads(np)` to use `np` threads, if you have `np` processors."
msgstr ""

#: ../../stdlib/base.rst:5021
msgid ""
"Same as :func:`fft`, but operates in-place on ``A``, which must be an array "
"of complex floating-point numbers."
msgstr ""

#: ../../stdlib/base.rst:5026
msgid "Multidimensional inverse FFT."
msgstr ""

#: ../../stdlib/base.rst:5028
msgid "A one-dimensional inverse FFT computes"
msgstr ""

#: ../../stdlib/base.rst:5036
msgid ""
"A multidimensional inverse FFT simply performs this operation along each "
"transformed dimension of ``A``."
msgstr ""

#: ../../stdlib/base.rst:5041
msgid "Same as :func:`ifft`, but operates in-place on ``A``."
msgstr ""

#: ../../stdlib/base.rst:5045
msgid ""
"Similar to :func:`ifft`, but computes an unnormalized inverse (backward) "
"transform, which must be divided by the product of the sizes of the "
"transformed dimensions in order to obtain the inverse. (This is slightly "
"more efficient than :func:`ifft` because it omits a scaling step, which in "
"some applications can be combined with other computational steps elsewhere.)"
msgstr ""

#: ../../stdlib/base.rst:5057
msgid "Same as :func:`bfft`, but operates in-place on ``A``."
msgstr ""

#: ../../stdlib/base.rst:5061
msgid ""
"Pre-plan an optimized FFT along given dimensions (``dims``) of arrays "
"matching the shape and type of ``A``.  (The first two arguments have the "
"same meaning as for :func:`fft`.)  Returns a function ``plan(A)`` that "
"computes ``fft(A, dims)`` quickly."
msgstr ""

#: ../../stdlib/base.rst:5066
msgid ""
"The ``flags`` argument is a bitwise-or of FFTW planner flags, defaulting to "
"``FFTW.ESTIMATE``.  e.g. passing ``FFTW.MEASURE`` or ``FFTW.PATIENT`` will "
"instead spend several seconds (or more) benchmarking different possible FFT "
"algorithms and picking the fastest one; see the FFTW manual for more "
"information on planner flags.  The optional ``timelimit`` argument specifies"
" a rough upper bound on the allowed planning time, in seconds. Passing "
"``FFTW.MEASURE`` or ``FFTW.PATIENT`` may cause the input array ``A`` to be "
"overwritten with zeros during plan creation."
msgstr ""

#: ../../stdlib/base.rst:5075
msgid ""
":func:`plan_fft!` is the same as :func:`plan_fft` but creates a plan that "
"operates in-place on its argument (which must be an array of complex "
"floating-point numbers).  :func:`plan_ifft` and so on are similar but "
"produce plans that perform the equivalent of the inverse transforms "
":func:`ifft` and so on."
msgstr ""

#: ../../stdlib/base.rst:5083
msgid ""
"Same as :func:`plan_fft`, but produces a plan that performs inverse "
"transforms :func:`ifft`."
msgstr ""

#: ../../stdlib/base.rst:5088
msgid ""
"Same as :func:`plan_fft`, but produces a plan that performs an unnormalized "
"backwards transform :func:`bfft`."
msgstr ""

#: ../../stdlib/base.rst:5093
msgid "Same as :func:`plan_fft`, but operates in-place on ``A``."
msgstr ""

#: ../../stdlib/base.rst:5097
msgid "Same as :func:`plan_ifft`, but operates in-place on ``A``."
msgstr ""

#: ../../stdlib/base.rst:5101
msgid "Same as :func:`plan_bfft`, but operates in-place on ``A``."
msgstr ""

#: ../../stdlib/base.rst:5105
msgid ""
"Multidimensional FFT of a real array A, exploiting the fact that the "
"transform has conjugate symmetry in order to save roughly half the "
"computational time and storage costs compared with :func:`fft`. If ``A`` has"
" size ``(n_1, ..., n_d)``, the result has size ``(floor(n_1/2)+1, ..., "
"n_d)``."
msgstr ""

#: ../../stdlib/base.rst:5111
msgid ""
"The optional ``dims`` argument specifies an iterable subset of one or more "
"dimensions of ``A`` to transform, similar to :func:`fft`.  Instead of "
"(roughly) halving the first dimension of ``A`` in the result, the "
"``dims[1]`` dimension is (roughly) halved in the same way."
msgstr ""

#: ../../stdlib/base.rst:5118
msgid ""
"Inverse of :func:`rfft`: for a complex array ``A``, gives the corresponding "
"real array whose FFT yields ``A`` in the first half. As for :func:`rfft`, "
"``dims`` is an optional subset of dimensions to transform, defaulting to "
"``1:ndims(A)``."
msgstr ""

#: ../../stdlib/base.rst:5123
msgid ""
"``d`` is the length of the transformed real array along the ``dims[1]`` "
"dimension, which must satisfy ``d == floor(size(A,dims[1])/2)+1``. (This "
"parameter cannot be inferred from ``size(A)`` due to the possibility of "
"rounding by the ``floor`` function here.)"
msgstr ""

#: ../../stdlib/base.rst:5130
msgid ""
"Similar to :func:`irfft` but computes an unnormalized inverse transform "
"(similar to :func:`bfft`), which must be divided by the product of the sizes"
" of the transformed dimensions (of the real output array) in order to obtain"
" the inverse transform."
msgstr ""

#: ../../stdlib/base.rst:5137
msgid ""
"Pre-plan an optimized real-input FFT, similar to :func:`plan_fft` except for"
" :func:`rfft` instead of :func:`fft`.  The first two arguments, and the size"
" of the transformed result, are the same as for :func:`rfft`."
msgstr ""

#: ../../stdlib/base.rst:5144
msgid ""
"Pre-plan an optimized real-input unnormalized transform, similar to "
":func:`plan_rfft` except for :func:`brfft` instead of :func:`rfft`. The "
"first two arguments and the size of the transformed result, are the same as "
"for :func:`brfft`."
msgstr ""

#: ../../stdlib/base.rst:5151
msgid ""
"Pre-plan an optimized inverse real-input FFT, similar to :func:`plan_rfft` "
"except for :func:`irfft` and :func:`brfft`, respectively.  The first three "
"arguments have the same meaning as for :func:`irfft`."
msgstr ""

#: ../../stdlib/base.rst:5157
msgid ""
"Performs a multidimensional type-II discrete cosine transform (DCT) of the "
"array ``A``, using the unitary normalization of the DCT. The optional "
"``dims`` argument specifies an iterable subset of dimensions (e.g. an "
"integer, range, tuple, or array) to transform along.  Most efficient if the "
"size of ``A`` along the transformed dimensions is a product of small primes;"
" see :func:`nextprod`.  See also :func:`plan_dct` for even greater "
"efficiency."
msgstr ""

#: ../../stdlib/base.rst:5167
msgid ""
"Same as :func:`dct!`, except that it operates in-place on ``A``, which must "
"be an array of real or complex floating-point values."
msgstr ""

#: ../../stdlib/base.rst:5173
msgid ""
"Computes the multidimensional inverse discrete cosine transform (DCT) of the"
" array ``A`` (technically, a type-III DCT with the unitary normalization). "
"The optional ``dims`` argument specifies an iterable subset of dimensions "
"(e.g. an integer, range, tuple, or array) to transform along.  Most "
"efficient if the size of ``A`` along the transformed dimensions is a product"
" of small primes; see :func:`nextprod`.  See also :func:`plan_idct` for even"
" greater efficiency."
msgstr ""

#: ../../stdlib/base.rst:5184
msgid "Same as :func:`idct!`, but operates in-place on ``A``."
msgstr ""

#: ../../stdlib/base.rst:5188
msgid ""
"Pre-plan an optimized discrete cosine transform (DCT), similar to "
":func:`plan_fft` except producing a function that computes :func:`dct`. The "
"first two arguments have the same meaning as for :func:`dct`."
msgstr ""

#: ../../stdlib/base.rst:5194
msgid "Same as :func:`plan_dct`, but operates in-place on ``A``."
msgstr ""

#: ../../stdlib/base.rst:5198
msgid ""
"Pre-plan an optimized inverse discrete cosine transform (DCT), similar to "
":func:`plan_fft` except producing a function that computes :func:`idct`. The"
" first two arguments have the same meaning as for :func:`idct`."
msgstr ""

#: ../../stdlib/base.rst:5204
msgid "Same as :func:`plan_idct`, but operates in-place on ``A``."
msgstr ""

#: ../../stdlib/base.rst:5208
msgid "Swap the first and second halves of each dimension of ``x``."
msgstr ""

#: ../../stdlib/base.rst:5212
msgid ""
"Swap the first and second halves of the given dimension of array ``x``."
msgstr ""

#: ../../stdlib/base.rst:5216
msgid "Undoes the effect of ``fftshift``."
msgstr ""

#: ../../stdlib/base.rst:5220
msgid ""
"Apply filter described by vectors ``a`` and ``b`` to vector ``x``, with an "
"optional initial filter state vector ``si`` (defaults to zeros)."
msgstr ""

#: ../../stdlib/base.rst:5225
msgid ""
"Same as :func:`filt` but writes the result into the ``out`` argument, which "
"may alias the input ``x`` to modify it in-place."
msgstr ""

#: ../../stdlib/base.rst:5230
msgid ""
"Construct vector ``c`` such that ``b = conv(a,c) + r``. Equivalent to "
"polynomial division."
msgstr ""

#: ../../stdlib/base.rst:5234
msgid "Convolution of two vectors. Uses FFT algorithm."
msgstr ""

#: ../../stdlib/base.rst:5238
msgid ""
"2-D convolution of the matrix ``A`` with the 2-D separable kernel generated "
"by the vectors ``u`` and ``v``.  Uses 2-D FFT algorithm"
msgstr ""

#: ../../stdlib/base.rst:5243
msgid ""
"2-D convolution of the matrix ``B`` with the matrix ``A``.  Uses 2-D FFT "
"algorithm"
msgstr ""

#: ../../stdlib/base.rst:5247
msgid "Compute the cross-correlation of two vectors."
msgstr ""

#: ../../stdlib/base.rst:5249
msgid "The following functions are defined within the ``Base.FFTW`` module."
msgstr ""

#: ../../stdlib/base.rst:5255
msgid ""
"Performs a multidimensional real-input/real-output (r2r) transform of type "
"``kind`` of the array ``A``, as defined in the FFTW manual. ``kind`` "
"specifies either a discrete cosine transform of various types "
"(``FFTW.REDFT00``, ``FFTW.REDFT01``, ``FFTW.REDFT10``, or ``FFTW.REDFT11``),"
" a discrete sine transform of various types (``FFTW.RODFT00``, "
"``FFTW.RODFT01``, ``FFTW.RODFT10``, or ``FFTW.RODFT11``), a real-input DFT "
"with halfcomplex-format output (``FFTW.R2HC`` and its inverse "
"``FFTW.HC2R``), or a discrete Hartley transform (``FFTW.DHT``).  The "
"``kind`` argument may be an array or tuple in order to specify different "
"transform types along the different dimensions of ``A``; ``kind[end]`` is "
"used for any unspecified dimensions.  See the FFTW manual for precise "
"definitions of these transform types, at http://www.fftw.org/doc."
msgstr ""

#: ../../stdlib/base.rst:5269
msgid ""
"The optional ``dims`` argument specifies an iterable subset of dimensions "
"(e.g. an integer, range, tuple, or array) to transform along. ``kind[i]`` is"
" then the transform type for ``dims[i]``, with ``kind[end]`` being used for "
"``i > length(kind)``."
msgstr ""

#: ../../stdlib/base.rst:5274
msgid "See also :func:`plan_r2r` to pre-plan optimized r2r transforms."
msgstr ""

#: ../../stdlib/base.rst:5278
msgid ""
"Same as :func:`r2r`, but operates in-place on ``A``, which must be an array "
"of real or complex floating-point numbers."
msgstr ""

#: ../../stdlib/base.rst:5283
msgid ""
"Pre-plan an optimized r2r transform, similar to :func:`Base.plan_fft` except"
" that the transforms (and the first three arguments) correspond to "
":func:`r2r` and :func:`r2r!`, respectively."
msgstr ""

#: ../../stdlib/base.rst:5289
msgid "Similar to :func:`Base.plan_fft`, but corresponds to :func:`r2r!`."
msgstr ""

#: ../../stdlib/base.rst:5294
msgid "Numerical Integration"
msgstr ""

#: ../../stdlib/base.rst:5296
msgid ""
"Although several external packages are available for numeric integration and"
" solution of ordinary differential equations, we also provide some built-in "
"integration support in Julia."
msgstr ""

#: ../../stdlib/base.rst:5302
msgid ""
"Numerically integrate the function ``f(x)`` from ``a`` to ``b``, and "
"optionally over additional intervals ``b`` to ``c`` and so on. Keyword "
"options include a relative error tolerance ``reltol`` (defaults to "
"``sqrt(eps)`` in the precision of the endpoints), an absolute error "
"tolerance ``abstol`` (defaults to 0), a maximum number of function "
"evaluations ``maxevals`` (defaults to ``10^7``), and the ``order`` of the "
"integration rule (defaults to 7)."
msgstr ""

#: ../../stdlib/base.rst:5310
msgid ""
"Returns a pair ``(I,E)`` of the estimated integral ``I`` and an estimated "
"upper bound on the absolute error ``E``.  If ``maxevals`` is not exceeded "
"then ``E <= max(abstol, reltol*norm(I))`` will hold. (Note that it is useful"
" to specify a positive ``abstol`` in cases where ``norm(I)`` may be zero.)"
msgstr ""

#: ../../stdlib/base.rst:5316
msgid ""
"The endpoints ``a`` etcetera can also be complex (in which case the integral"
" is performed over straight-line segments in the complex plane).  If the "
"endpoints are ``BigFloat``, then the integration will be performed in "
"``BigFloat`` precision as well (note: it is advisable to increase the "
"integration ``order`` in rough proportion to the precision, for smooth "
"integrands).  More generally, the precision is set by the precision of the "
"integration endpoints (promoted to floating-point types)."
msgstr ""

#: ../../stdlib/base.rst:5325
msgid ""
"The integrand ``f(x)`` can return any numeric scalar, vector, or matrix "
"type, or in fact any type supporting ``+``, ``-``, multiplication by real "
"values, and a ``norm`` (i.e., any normed vector space). Alternatively, a "
"different norm can be specified by passing a `norm`-like function as the "
"`norm` keyword argument (which defaults to `vecnorm`)."
msgstr ""

#: ../../stdlib/base.rst:5331
msgid ""
"The algorithm is an adaptive Gauss-Kronrod integration technique: the "
"integral in each interval is estimated using a Kronrod rule (``2*order+1`` "
"points) and the error is estimated using an embedded Gauss rule (``order`` "
"points).   The interval with the largest error is then subdivided into two "
"intervals and the process is repeated until the desired error tolerance is "
"achieved."
msgstr ""

#: ../../stdlib/base.rst:5338
msgid ""
"These quadrature rules work best for smooth functions within each interval, "
"so if your function has a known discontinuity or other singularity, it is "
"best to subdivide your interval to put the singularity at an endpoint.  For "
"example, if ``f`` has a discontinuity at ``x=0.7`` and you want to integrate"
" from 0 to 1, you should use ``quadgk(f, 0,0.7,1)`` to subdivide the "
"interval at the point of discontinuity.  The integrand is never evaluated "
"exactly at the endpoints of the intervals, so it is possible to integrate "
"functions that diverge at the endpoints as long as the singularity is "
"integrable (for example, a ``log(x)`` or ``1/sqrt(x)`` singularity)."
msgstr ""

#: ../../stdlib/base.rst:5349
msgid ""
"For real-valued endpoints, the starting and/or ending points may be "
"infinite.  (A coordinate transformation is performed internally to map the "
"infinite interval to a finite one.)"
msgstr ""

#: ../../stdlib/base.rst:5354
msgid "Parallel Computing"
msgstr ""

#: ../../stdlib/base.rst:5358
msgid ""
"Launches workers using the in-built ``LocalManager`` which only launches "
"workers on the local host. This can be used to take advantage of multiple "
"cores. `addprocs(4)`` will add 4 processes on the local machine."
msgstr ""

#: ../../stdlib/base.rst:5363
msgid "Equivalent to ``addprocs(CPU_CORES)``"
msgstr ""

#: ../../stdlib/base.rst:5367
msgid ""
"Add processes on remote machines via SSH. Requires julia to be installed in "
"the same location on each node, or to be available via a shared file system."
msgstr ""

#: ../../stdlib/base.rst:5370
msgid ""
"``machines`` is a vector of machine specifications.  Worker are started for "
"each specification."
msgstr ""

#: ../../stdlib/base.rst:5372
msgid ""
"A machine specification is either a string ``machine_spec`` or a tuple - "
"``(machine_spec, count)``"
msgstr ""

#: ../../stdlib/base.rst:5374
msgid ""
"``machine_spec`` is a string of the form ``[user@]host[:port] "
"[bind_addr[:port]]``. ``user`` defaults to current user, ``port`` to the "
"standard ssh port. If ``[bind_addr[:port]]`` is specified, other workers "
"will connect to this worker at the specified ``bind_addr`` and ``port``."
msgstr ""

#: ../../stdlib/base.rst:5378
msgid ""
"``count`` is the number of workers to be launched on the specified host. If "
"specified as ``\"auto\"`` or ``:auto`` it will launch as many workers as the"
" number of cores on the specific host."
msgstr ""

#: ../../stdlib/base.rst:5382
msgid "Keyword arguments:"
msgstr ""

#: ../../stdlib/base.rst:5384
msgid ""
"``tunnel`` : if ``true`` then SSH tunneling will be used to connect to the "
"worker from the master process."
msgstr ""

#: ../../stdlib/base.rst:5386
msgid ""
"``sshflags`` : specifies additional ssh options, e.g. "
":literal:`sshflags=\\`-i /home/foo/bar.pem\\`` ."
msgstr ""

#: ../../stdlib/base.rst:5388
msgid ""
"``max_parallel`` : specifies the maximum number of workers connected to in "
"parallel at a host. Defaults to 10."
msgstr ""

#: ../../stdlib/base.rst:5390
msgid ""
"``dir`` :  specifies the location of the julia binaries on the worker nodes."
" Defaults to JULIA_HOME."
msgstr ""

#: ../../stdlib/base.rst:5392
msgid ""
"``exename`` :  name of the julia executable. Defaults to \"./julia\" or "
"\"./julia-debug\" as the case may be."
msgstr ""

#: ../../stdlib/base.rst:5394
msgid "``exeflags`` :  additional flags passed to the worker processes."
msgstr ""

#: ../../stdlib/base.rst:5399
msgid "Launches worker processes via the specified cluster manager."
msgstr ""

#: ../../stdlib/base.rst:5401
msgid ""
"For example Beowulf clusters are  supported via a custom cluster manager "
"implemented in  package ``ClusterManagers``."
msgstr ""

#: ../../stdlib/base.rst:5404
msgid ""
"See the documentation for package ``ClusterManagers`` for more information "
"on how to write a custom cluster manager."
msgstr ""

#: ../../stdlib/base.rst:5410
msgid "Get the number of available processes."
msgstr ""

#: ../../stdlib/base.rst:5414
msgid ""
"Get the number of available worker processes. This is one less than "
"nprocs(). Equal to nprocs() if nprocs() == 1."
msgstr ""

#: ../../stdlib/base.rst:5418
msgid "Returns a list of all process identifiers."
msgstr ""

#: ../../stdlib/base.rst:5422
msgid "Returns a list of all worker process identifiers."
msgstr ""

#: ../../stdlib/base.rst:5426
msgid "Removes the specified workers."
msgstr ""

#: ../../stdlib/base.rst:5430
msgid ""
"Interrupt the current executing task on the specified workers. This is "
"equivalent to pressing Ctrl-C on the local machine. If no arguments are "
"given, all workers are interrupted."
msgstr ""

#: ../../stdlib/base.rst:5436
msgid "Get the id of the current process."
msgstr ""

#: ../../stdlib/base.rst:5440
msgid ""
"Transform collections ``lsts`` by applying ``f`` to each element in "
"parallel. If ``nprocs() > 1``, the calling process will be dedicated to "
"assigning tasks. All other available processes will be used as parallel "
"workers."
msgstr ""

#: ../../stdlib/base.rst:5444
msgid ""
"If ``err_retry`` is true, it retries a failed application of ``f`` on a "
"different worker. If ``err_stop`` is true, it takes precedence over the "
"value of ``err_retry`` and ``pmap`` stops execution on the first error."
msgstr ""

#: ../../stdlib/base.rst:5450
msgid ""
"Call a function asynchronously on the given arguments on the specified "
"process. Returns a ``RemoteRef``."
msgstr ""

#: ../../stdlib/base.rst:5454
msgid ""
"Block the current task until some event occurs, depending on the type of the"
" argument:"
msgstr ""

#: ../../stdlib/base.rst:5457
msgid ""
"``RemoteRef``: Wait for a value to become available for the specified remote"
" reference."
msgstr ""

#: ../../stdlib/base.rst:5459
msgid "``Condition``: Wait for ``notify`` on a condition."
msgstr ""

#: ../../stdlib/base.rst:5461
msgid ""
"``Process``: Wait for a process or process chain to exit. The ``exitcode`` "
"field of a process can be used to determine success or failure."
msgstr ""

#: ../../stdlib/base.rst:5463
msgid "``Task``: Wait for a ``Task`` to finish, returning its result value."
msgstr ""

#: ../../stdlib/base.rst:5465
msgid ""
"``RawFD``: Wait for changes on a file descriptor (see `poll_fd` for keyword "
"arguments and return code)"
msgstr ""

#: ../../stdlib/base.rst:5467
msgid ""
"If no argument is passed, the task blocks for an undefined period. If the "
"task's state is set to ``:waiting``, it can only be restarted by an explicit"
" call to ``schedule`` or ``yieldto``. If the task's state is ``:runnable``, "
"it might be restarted unpredictably."
msgstr ""

#: ../../stdlib/base.rst:5472
msgid ""
"Often ``wait`` is called within a ``while`` loop to ensure a waited-for "
"condition is met before proceeding."
msgstr ""

#: ../../stdlib/base.rst:5477
msgid "Wait for and get the value of a remote reference."
msgstr ""

#: ../../stdlib/base.rst:5481
msgid "Perform ``wait(remotecall(...))`` in one message."
msgstr ""

#: ../../stdlib/base.rst:5485
msgid "Perform ``fetch(remotecall(...))`` in one message."
msgstr ""

#: ../../stdlib/base.rst:5489
msgid ""
"Store a value to a remote reference. Implements \"shared queue of length 1\""
" semantics: if a value is already present, blocks until the value is removed"
" with ``take!``. Returns its first argument."
msgstr ""

#: ../../stdlib/base.rst:5493
msgid ""
"Fetch the value of a remote reference, removing it so that the reference is "
"empty again."
msgstr ""

#: ../../stdlib/base.rst:5497
msgid ""
"Determine whether a ``RemoteRef`` has a value stored to it. Note that this "
"function can cause race conditions, since by the time you receive its result"
" it may no longer be true. It is recommended that this function only be used"
" on a ``RemoteRef`` that is assigned once."
msgstr ""

#: ../../stdlib/base.rst:5502
msgid ""
"If the argument ``RemoteRef`` is owned by a different node, this call will "
"block to wait for the answer. It is recommended to wait for ``r`` in a "
"separate task instead, or to use a local ``RemoteRef`` as a proxy::"
msgstr ""

#: ../../stdlib/base.rst:5512
msgid "Make an uninitialized remote reference on the local machine."
msgstr ""

#: ../../stdlib/base.rst:5516
msgid "Make an uninitialized remote reference on process ``n``."
msgstr ""

#: ../../stdlib/base.rst:5520
msgid ""
"Waits till ``testcb`` returns ``true`` or for ``secs``` seconds, whichever "
"is earlier. ``testcb`` is polled every ``pollint`` seconds."
msgstr ""

#: ../../stdlib/base.rst:5525
msgid ""
"Execute an expression on an automatically-chosen process, returning a "
"``RemoteRef`` to the result."
msgstr ""

#: ../../stdlib/base.rst:5530
msgid ""
"Accepts two arguments, ``p`` and an expression, and runs the expression "
"asynchronously on process ``p``, returning a ``RemoteRef`` to the result."
msgstr ""

#: ../../stdlib/base.rst:5535
msgid "Equivalent to ``fetch(@spawn expr)``."
msgstr ""

#: ../../stdlib/base.rst:5539
msgid "Equivalent to ``fetch(@spawnat p expr)``."
msgstr ""

#: ../../stdlib/base.rst:5543
msgid ""
"Schedule an expression to run on the local machine, also adding it to the "
"set of items that the nearest enclosing ``@sync`` waits for."
msgstr ""

#: ../../stdlib/base.rst:5548
msgid ""
"Wait until all dynamically-enclosed uses of ``@async``, ``@spawn``, "
"``@spawnat`` and ``@parallel`` are complete."
msgstr ""

#: ../../stdlib/base.rst:5553
msgid "A parallel for loop of the form ::"
msgstr ""

#: ../../stdlib/base.rst:5559
msgid ""
"The specified range is partitioned and locally executed across all workers. "
"In case an optional reducer function is specified, @parallel performs local "
"reductions on each worker with a final reduction on the calling process."
msgstr ""

#: ../../stdlib/base.rst:5563
msgid ""
"Note that without a reducer function, @parallel executes asynchronously, "
"i.e. it spawns independent tasks on all available workers and returns "
"immediately without waiting for completion. To wait for completion, prefix "
"the call with ``@sync``, like ::"
msgstr ""

#: ../../stdlib/base.rst:5575
msgid "Distributed Arrays"
msgstr ""

#: ../../stdlib/base.rst:5579
msgid ""
"Construct a distributed array. The parameter ``init`` is a function that "
"accepts a tuple of index ranges. This function should allocate a local chunk"
" of the distributed array and initialize it for the specified indices. "
"``dims`` is the overall size of the distributed array. ``procs`` optionally "
"specifies a vector of process IDs to use. If unspecified, the array is "
"distributed over all worker processes only. Typically, when running in "
"distributed mode, i.e., ``nprocs() > 1``, this would mean that no chunk of "
"the distributed array exists on the process hosting the interactive julia "
"prompt. ``dist`` is an integer vector specifying how many chunks the "
"distributed array should be divided into in each dimension."
msgstr ""

#: ../../stdlib/base.rst:5587
msgid ""
"For example, the ``dfill`` function that creates a distributed array and "
"fills it with a value ``v`` is implemented as:"
msgstr ""

#: ../../stdlib/base.rst:5589
msgid "``dfill(v, args...) = DArray(I->fill(v, map(length,I)), args...)``"
msgstr ""

#: ../../stdlib/base.rst:5593
msgid ""
"Construct a distributed array of zeros. Trailing arguments are the same as "
"those accepted by :func:`DArray`."
msgstr ""

#: ../../stdlib/base.rst:5597
msgid ""
"Construct a distributed array of ones. Trailing arguments are the same as "
"those accepted by :func:`DArray`."
msgstr ""

#: ../../stdlib/base.rst:5601
msgid ""
"Construct a distributed array filled with value ``x``. Trailing arguments "
"are the same as those accepted by :func:`DArray`."
msgstr ""

#: ../../stdlib/base.rst:5605
msgid ""
"Construct a distributed uniform random array. Trailing arguments are the "
"same as those accepted by :func:`DArray`."
msgstr ""

#: ../../stdlib/base.rst:5609
msgid ""
"Construct a distributed normal random array. Trailing arguments are the same"
" as those accepted by :func:`DArray`."
msgstr ""

#: ../../stdlib/base.rst:5613
msgid "Convert a local array to distributed."
msgstr ""

#: ../../stdlib/base.rst:5617
msgid ""
"Get the local piece of a distributed array. Returns an empty array if no "
"local part exists on the calling process."
msgstr ""

#: ../../stdlib/base.rst:5621
msgid ""
"A tuple describing the indexes owned by the local process. Returns a tuple "
"with empty ranges if no local part exists on the calling process."
msgstr ""

#: ../../stdlib/base.rst:5626
msgid "Get the vector of processes storing pieces of ``d``."
msgstr ""

#: ../../stdlib/base.rst:5630
msgid "Shared Arrays (Experimental, UNIX-only feature)"
msgstr ""

#: ../../stdlib/base.rst:5634
msgid ""
"Construct a SharedArray of a bitstype ``T``  and size ``dims`` across the "
"processes specified by ``pids`` - all of which have to be on the same host."
msgstr ""

#: ../../stdlib/base.rst:5637
msgid ""
"If ``pids`` is left unspecified, the shared array will be mapped across all "
"processes on the current host, including the master. But, ``localindexes`` "
"and ``indexpids`` will only refer to worker processes. This facilitates work"
" distribution code to use workers for actual computation with the master "
"process acting as a driver."
msgstr ""

#: ../../stdlib/base.rst:5642
msgid ""
"If an ``init`` function of the type ``initfn(S::SharedArray)`` is specified,"
" it is called on all the participating workers."
msgstr ""

#: ../../stdlib/base.rst:5647
msgid "Get the vector of processes that have mapped the shared array"
msgstr ""

#: ../../stdlib/base.rst:5651
msgid "Returns the actual ``Array`` object backing ``S``"
msgstr ""

#: ../../stdlib/base.rst:5655
msgid ""
"Returns the index of the current worker into the ``pids`` vector, i.e., the "
"list of workers mapping the SharedArray"
msgstr ""

#: ../../stdlib/base.rst:5660
msgid "System"
msgstr ""

#: ../../stdlib/base.rst:5664
msgid ""
"Run a command object, constructed with backticks. Throws an error if "
"anything goes wrong, including the process exiting with a non-zero status."
msgstr ""

#: ../../stdlib/base.rst:5668
msgid ""
"Run a command object asynchronously, returning the resulting ``Process`` "
"object."
msgstr ""

#: ../../stdlib/base.rst:5672
msgid ""
"Used in a stream redirect to discard all data written to it. Essentially "
"equivalent to /dev/null on Unix or NUL on Windows. Usage: ``run(`cat "
"test.txt` |> DevNull)``"
msgstr ""

#: ../../stdlib/base.rst:5677
msgid ""
"Run a command object, constructed with backticks, and tell whether it was "
"successful (exited with a code of 0). An exception is raised if the process "
"cannot be started."
msgstr ""

#: ../../stdlib/base.rst:5681
msgid "Determine whether a process is currently running."
msgstr ""

#: ../../stdlib/base.rst:5685
msgid "Determine whether a process has exited."
msgstr ""

#: ../../stdlib/base.rst:5689
msgid "Send a signal to a process. The default is to terminate the process."
msgstr ""

#: ../../stdlib/base.rst:5693
msgid ""
"Start running ``command`` asynchronously, and return a tuple "
"``(stream,process)``.  If ``mode`` is ``\"r\"``, then ``stream`` reads from "
"the process's standard output and ``stdio`` optionally specifies the "
"process's standard input stream.  If ``mode`` is ``\"w\"``, then ``stream`` "
"writes to the process's standard input and ``stdio`` optionally specifies "
"the process's standard output stream."
msgstr ""

#: ../../stdlib/base.rst:5703
msgid ""
"Similar to ``open(command, mode, stdio)``, but calls ``f(stream)`` on the "
"resulting read or write stream, then closes the stream and waits for the "
"process to complete.  Returns the value returned by ``f``."
msgstr ""

#: ../../stdlib/base.rst:5710
msgid ""
"Starts running a command asynchronously, and returns a tuple "
"(stdout,stdin,process) of the output stream and input stream of the process,"
" and the process object itself."
msgstr ""

#: ../../stdlib/base.rst:5714
msgid ""
"Mark a command object so that running it will not throw an error if the "
"result code is non-zero."
msgstr ""

#: ../../stdlib/base.rst:5719
msgid ""
"Mark a command object so that it will be run in a new process group, "
"allowing it to outlive the julia process, and not have Ctrl-C interrupts "
"passed to it."
msgstr ""

#: ../../stdlib/base.rst:5725
msgid ""
"Set environment variables to use when running the given command. ``env`` is "
"either a dictionary mapping strings to strings, or an array of strings of "
"the form ``\"var=val\"``."
msgstr ""

#: ../../stdlib/base.rst:5729
msgid ""
"The ``dir`` keyword argument can be used to specify a working directory for "
"the command."
msgstr ""

#: ../../stdlib/base.rst:5736
msgid ""
"Redirect operator. Used for piping the output of a process into another "
"(first form) or to redirect the standard output/input of a command to/from a"
" file (second and third forms)."
msgstr ""

#: ../../stdlib/base.rst:5740
msgid "**Examples**:"
msgstr ""

#: ../../stdlib/base.rst:5739
msgid "``run(`ls` |> `grep xyz`)``"
msgstr ""

#: ../../stdlib/base.rst:5740
msgid "``run(`ls` |> \"out.txt\")``"
msgstr ""

#: ../../stdlib/base.rst:5741
msgid "``run(\"out.txt\" |> `grep xyz`)``"
msgstr ""

#: ../../stdlib/base.rst:5745
msgid ""
"Redirect standard output of a process, appending to the destination file."
msgstr ""

#: ../../stdlib/base.rst:5749
msgid "Redirect the standard error stream of a process."
msgstr ""

#: ../../stdlib/base.rst:5753
msgid "Get the local machine's host name."
msgstr ""

#: ../../stdlib/base.rst:5757
msgid ""
"Get the IP address of the local machine, as a string of the form "
"\"x.x.x.x\"."
msgstr ""

#: ../../stdlib/base.rst:5761
msgid "Get the current working directory."
msgstr ""

#: ../../stdlib/base.rst:5765
msgid "Set the current working directory."
msgstr ""

#: ../../stdlib/base.rst:5769
msgid ""
"Temporarily changes the current working directory (HOME if not specified) "
"and applies function f before returning."
msgstr ""

#: ../../stdlib/base.rst:5773
msgid ""
"Make a new directory with name ``path`` and permissions ``mode``. ``mode`` "
"defaults to 0o777, modified by the current file creation mask."
msgstr ""

#: ../../stdlib/base.rst:5778
msgid ""
"Create all directories in the given ``path``, with permissions ``mode``. "
"``mode`` defaults to 0o777, modified by the current file creation mask."
msgstr ""

#: ../../stdlib/base.rst:5783
msgid "Creates a symbolic link to ``target`` with the name ``link``."
msgstr ""

#: ../../stdlib/base.rst:5787
msgid ""
"This function raises an error under operating systems that do not support "
"soft symbolic links, such as Windows XP."
msgstr ""

#: ../../stdlib/base.rst:5792
msgid ""
"Change the permissions mode of ``path`` to ``mode``. Only integer ``mode``\\"
" s (e.g. 0o777) are currently supported."
msgstr ""

#: ../../stdlib/base.rst:5797
msgid "Get julia's process ID."
msgstr ""

#: ../../stdlib/base.rst:5801
msgid ""
"Get the system time in seconds since the epoch, with fairly high (typically,"
" microsecond) resolution. When passed a ``TmStruct``, converts it to a "
"number of seconds since the epoch."
msgstr ""

#: ../../stdlib/base.rst:5805
msgid ""
"Get the time in nanoseconds. The time corresponding to 0 is undefined, and "
"wraps every 5.8 years."
msgstr ""

#: ../../stdlib/base.rst:5809
msgid ""
"Convert time, given as a number of seconds since the epoch or a "
"``TmStruct``, to a formatted string using the given format. Supported "
"formats are the same as those in the standard C library."
msgstr ""

#: ../../stdlib/base.rst:5813
msgid ""
"Parse a formatted time string into a ``TmStruct`` giving the seconds, "
"minute, hour, date, etc. Supported formats are the same as those in the "
"standard C library. On some platforms, timezones will not be parsed "
"correctly. If the result of this function will be passed to ``time`` to "
"convert it to seconds since the epoch, the ``isdst`` field should be filled "
"in manually. Setting it to ``-1`` will tell the C library to use the current"
" system settings to determine the timezone."
msgstr ""

#: ../../stdlib/base.rst:5817
msgid ""
"Convert a number of seconds since the epoch to broken-down format, with "
"fields ``sec``, ``min``, ``hour``, ``mday``, ``month``, ``year``, ``wday``, "
"``yday``, and ``isdst``."
msgstr ""

#: ../../stdlib/base.rst:5821
msgid ""
"Set a timer to be read by the next call to :func:`toc` or :func:`toq`. The "
"macro call ``@time expr`` can also be used to time evaluation."
msgstr ""

#: ../../stdlib/base.rst:5825
msgid "Print and return the time elapsed since the last :func:`tic`."
msgstr ""

#: ../../stdlib/base.rst:5829
msgid "Return, but do not print, the time elapsed since the last :func:`tic`."
msgstr ""

#: ../../stdlib/base.rst:5833
msgid ""
"A macro to execute an expression, printing the time it took to execute and "
"the total number of bytes its execution caused to be allocated, before "
"returning the value of the expression."
msgstr ""

#: ../../stdlib/base.rst:5837
msgid ""
"A macro to evaluate an expression, discarding the resulting value, instead "
"returning the number of seconds it took to execute as a floating-point "
"number."
msgstr ""

#: ../../stdlib/base.rst:5841
msgid ""
"A macro to evaluate an expression, discarding the resulting value, instead "
"returning the total number of bytes allocated during evaluation of the "
"expression."
msgstr ""

#: ../../stdlib/base.rst:5845
msgid ""
"A singleton of this type provides a hash table interface to environment "
"variables."
msgstr ""

#: ../../stdlib/base.rst:5849
msgid ""
"Reference to the singleton ``EnvHash``, providing a dictionary interface to "
"system environment variables."
msgstr ""

#: ../../stdlib/base.rst:5853
msgid ""
"Given ``@unix? a : b``, do ``a`` on Unix systems (including Linux and OS X) "
"and ``b`` elsewhere. See documentation for Handling Platform Variations in "
"the Calling C and Fortran Code section of the manual."
msgstr ""

#: ../../stdlib/base.rst:5858
msgid ""
"Given ``@osx? a : b``, do ``a`` on OS X and ``b`` elsewhere. See "
"documentation for Handling Platform Variations in the Calling C and Fortran "
"Code section of the manual."
msgstr ""

#: ../../stdlib/base.rst:5863
msgid ""
"Given ``@linux? a : b``, do ``a`` on Linux and ``b`` elsewhere. See "
"documentation for Handling Platform Variations in the Calling C and Fortran "
"Code section of the manual."
msgstr ""

#: ../../stdlib/base.rst:5868
msgid ""
"Given ``@windows? a : b``, do ``a`` on Windows and ``b`` elsewhere. See "
"documentation for Handling Platform Variations in the Calling C and Fortran "
"Code section of the manual."
msgstr ""

#: ../../stdlib/base.rst:5872
msgid "C Interface"
msgstr ""

#: ../../stdlib/base.rst:5876
msgid ""
"Call function in C-exported shared library, specified by ``(function name, "
"library)`` tuple, where each component is a AbstractString or :Symbol. "
"Alternatively, ccall may be used to call a function pointer returned by "
"dlsym, but note that this usage is generally discouraged to facilitate "
"future static compilation. Note that the argument type tuple must be a "
"literal tuple, and not a tuple-valued variable or expression."
msgstr ""

#: ../../stdlib/base.rst:5882
msgid ""
"Obtain a pointer to a global variable in a C-exported shared library, "
"specified exactly as in ``ccall``.  Returns a ``Ptr{Type}``, defaulting to "
"``Ptr{Void}`` if no Type argument is supplied.  The values can be read or "
"written by ``unsafe_load`` or ``unsafe_store!``, respectively."
msgstr ""

#: ../../stdlib/base.rst:5886
msgid ""
"Generate C-callable function pointer from Julia function. Type annotation of"
" the return value in the callback function is a must for situations where "
"Julia cannot infer the return type automatically."
msgstr ""

#: ../../stdlib/base.rst:5889
msgid "For example::"
msgstr ""

#: ../../stdlib/base.rst:5902
msgid "Load a shared library, returning an opaque handle."
msgstr ""

#: ../../stdlib/base.rst:5904
msgid ""
"The optional flags argument is a bitwise-or of zero or more of "
"``RTLD_LOCAL``, ``RTLD_GLOBAL``, ``RTLD_LAZY``, ``RTLD_NOW``, "
"``RTLD_NODELETE``, ``RTLD_NOLOAD``, ``RTLD_DEEPBIND``, and ``RTLD_FIRST``.  "
"These are converted to the corresponding flags of the POSIX (and/or GNU libc"
" and/or MacOS) dlopen command, if possible, or are ignored if the specified "
"functionality is not available on the current platform.  The default is "
"``RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL``.  An important usage of these flags, "
"on POSIX platforms, is to specify ``RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL`` in"
" order for the library's symbols to be available for usage in other shared "
"libraries, in situations where there are dependencies between shared "
"libraries."
msgstr ""

#: ../../stdlib/base.rst:5918
msgid ""
"Similar to :func:`dlopen`, except returns a ``NULL`` pointer instead of "
"raising errors."
msgstr ""

#: ../../stdlib/base.rst:5922 ../../stdlib/base.rst:5926
#: ../../stdlib/base.rst:5930 ../../stdlib/base.rst:5934
#: ../../stdlib/base.rst:5938 ../../stdlib/base.rst:5942
#: ../../stdlib/base.rst:5946 ../../stdlib/base.rst:5950
msgid ""
"Enum constant for :func:`dlopen`. See your platform man page for details, if"
" applicable."
msgstr ""

#: ../../stdlib/base.rst:5954
msgid ""
"Look up a symbol from a shared library handle, return callable function "
"pointer on success."
msgstr ""

#: ../../stdlib/base.rst:5958
msgid ""
"Look up a symbol from a shared library handle, silently return NULL pointer "
"on lookup failure."
msgstr ""

#: ../../stdlib/base.rst:5962
msgid "Close shared library referenced by handle."
msgstr ""

#: ../../stdlib/base.rst:5966
msgid ""
"Searches for the first library in ``names`` in the paths in the "
"``locations`` list, ``DL_LOAD_PATH``, or system library paths (in that "
"order) which can successfully be dlopen'd. On success, the return value will"
" be one of the names (potentially prefixed by one of the paths in "
"locations). This string can be assigned to a ``global const`` and used as "
"the library name in future ``ccall``'s. On failure, it returns the empty "
"string."
msgstr ""

#: ../../stdlib/base.rst:5973
msgid ""
"When calling ``dlopen``, the paths in this list will be searched first, in "
"order, before searching the system locations for a valid library handle."
msgstr ""

#: ../../stdlib/base.rst:5978
msgid "Call ``malloc`` from the C standard library."
msgstr ""

#: ../../stdlib/base.rst:5982
msgid "Call ``calloc`` from the C standard library."
msgstr ""

#: ../../stdlib/base.rst:5986
msgid "Call ``realloc`` from the C standard library."
msgstr ""

#: ../../stdlib/base.rst:5990
msgid "Call ``free`` from the C standard library."
msgstr ""

#: ../../stdlib/base.rst:5994
msgid ""
"Load a value of type ``T`` from the address of the ith element (1-indexed) "
"starting at ``p``. This is equivalent to the C expression ``p[i-1]``."
msgstr ""

#: ../../stdlib/base.rst:5999
msgid ""
"Store a value of type ``T`` to the address of the ith element (1-indexed) "
"starting at ``p``. This is equivalent to the C expression ``p[i-1] = x``."
msgstr ""

#: ../../stdlib/base.rst:6004
msgid ""
"Copy ``N`` elements from a source pointer to a destination, with no "
"checking. The size of an element is determined by the type of the pointers."
msgstr ""

#: ../../stdlib/base.rst:6009
msgid ""
"Copy ``N`` elements from a source array to a destination, starting at offset"
" ``so`` in the source and ``do`` in the destination (1-indexed)."
msgstr ""

#: ../../stdlib/base.rst:6014
msgid ""
"Copy all elements from collection ``src`` to array ``dest``. Returns "
"``dest``."
msgstr ""

#: ../../stdlib/base.rst:6018
msgid ""
"Copy ``N`` elements from collection ``src`` starting at offset ``so``, to "
"array ``dest`` starting at offset ``do``. Returns ``dest``."
msgstr ""

#: ../../stdlib/base.rst:6023
msgid ""
"Get the native address of an array or string element. Be careful to ensure "
"that a julia reference to ``a`` exists as long as this pointer will be used."
msgstr ""

#: ../../stdlib/base.rst:6029
msgid "Convert an integer to a pointer of the specified element type."
msgstr ""

#: ../../stdlib/base.rst:6033
msgid ""
"Wrap a native pointer as a Julia Array object. The pointer element type "
"determines the array element type. ``own`` optionally specifies whether "
"Julia should take ownership of the memory, calling ``free`` on the pointer "
"when the array is no longer referenced."
msgstr ""

#: ../../stdlib/base.rst:6040
msgid ""
"Get the memory address of a Julia object as a ``Ptr``. The existence of the "
"resulting ``Ptr`` will not protect the object from garbage collection, so "
"you must ensure that the object remains referenced for the whole time that "
"the ``Ptr`` will be used."
msgstr ""

#: ../../stdlib/base.rst:6046
msgid ""
"Convert a ``Ptr`` to an object reference. Assumes the pointer refers to a "
"valid heap-allocated Julia object. If this is not the case, undefined "
"behavior results, hence this function is considered \"unsafe\" and should be"
" used with care."
msgstr ""

#: ../../stdlib/base.rst:6052
msgid ""
"Disable Ctrl-C handler during execution of a function, for calling external "
"code that is not interrupt safe. Intended to be called using ``do`` block "
"syntax as follows::"
msgstr ""

#: ../../stdlib/base.rst:6063
msgid ""
"Re-enable Ctrl-C handler during execution of a function. Temporarily "
"reverses the effect of ``disable_sigint``."
msgstr ""

#: ../../stdlib/base.rst:6068
msgid ""
"Get the value of the C library's ``errno``. If an argument is specified, it "
"is used to set the value of ``errno``."
msgstr ""

#: ../../stdlib/base.rst:6071
msgid ""
"The value of ``errno`` is only valid immediately after a ``ccall`` to a C "
"library routine that sets it. Specifically, you cannot call ``errno`` at the"
" next prompt in a REPL, because lots of code is executed between prompts."
msgstr ""

#: ../../stdlib/base.rst:6077
msgid ""
"Raises a ``SystemError`` for ``errno`` with the descriptive string "
"``sysfunc`` if ``bool`` is true"
msgstr ""

#: ../../stdlib/base.rst:6081
msgid "Convert a system call error code to a descriptive string"
msgstr ""

#: ../../stdlib/base.rst:6085
msgid "Equivalent to the native ``char`` c-type"
msgstr ""

#: ../../stdlib/base.rst:6089
msgid "Equivalent to the native ``unsigned char`` c-type (UInt8)"
msgstr ""

#: ../../stdlib/base.rst:6093
msgid "Equivalent to the native ``signed short`` c-type (Int16)"
msgstr ""

#: ../../stdlib/base.rst:6097
msgid "Equivalent to the native ``unsigned short`` c-type (UInt16)"
msgstr ""

#: ../../stdlib/base.rst:6101
msgid "Equivalent to the native ``signed int`` c-type (Int32)"
msgstr ""

#: ../../stdlib/base.rst:6105
msgid "Equivalent to the native ``unsigned int`` c-type (UInt32)"
msgstr ""

#: ../../stdlib/base.rst:6109
msgid "Equivalent to the native ``signed long`` c-type"
msgstr ""

#: ../../stdlib/base.rst:6113
msgid "Equivalent to the native ``unsigned long`` c-type"
msgstr ""

#: ../../stdlib/base.rst:6117
msgid "Equivalent to the native ``signed long long`` c-type (Int64)"
msgstr ""

#: ../../stdlib/base.rst:6121
msgid "Equivalent to the native ``unsigned long long`` c-type (UInt64)"
msgstr ""

#: ../../stdlib/base.rst:6125
msgid "Equivalent to the native ``intmax_t`` c-type (Int64)"
msgstr ""

#: ../../stdlib/base.rst:6129
msgid "Equivalent to the native ``uintmax_t`` c-type (UInt64)"
msgstr ""

#: ../../stdlib/base.rst:6133
msgid "Equivalent to the native ``size_t`` c-type (UInt)"
msgstr ""

#: ../../stdlib/base.rst:6137
msgid "Equivalent to the native ``ssize_t`` c-type"
msgstr ""

#: ../../stdlib/base.rst:6141
msgid "Equivalent to the native ``ptrdiff_t`` c-type (Int)"
msgstr ""

#: ../../stdlib/base.rst:6145
msgid "Equivalent to the native ``off_t`` c-type"
msgstr ""

#: ../../stdlib/base.rst:6149
msgid "Equivalent to the native ``wchar_t`` c-type (Int32)"
msgstr ""

#: ../../stdlib/base.rst:6153
msgid "Equivalent to the native ``float`` c-type (Float32)"
msgstr ""

#: ../../stdlib/base.rst:6157
msgid "Equivalent to the native ``double`` c-type (Float64)"
msgstr ""

#: ../../stdlib/base.rst:6161
msgid "Errors"
msgstr ""

#: ../../stdlib/base.rst:6165
msgid "Raise an error with the given message"
msgstr ""

#: ../../stdlib/base.rst:6169
msgid "Throw an object as an exception"
msgstr ""

#: ../../stdlib/base.rst:6173
msgid ""
"Throw an object without changing the current exception backtrace. The "
"default argument is the current exception (if called within a ``catch`` "
"block)."
msgstr ""

#: ../../stdlib/base.rst:6179
msgid "Get a backtrace object for the current program point."
msgstr ""

#: ../../stdlib/base.rst:6183
msgid ""
"Get the backtrace of the current exception, for use within ``catch`` blocks."
msgstr ""

#: ../../stdlib/base.rst:6188
msgid ""
"Raise an error if ``cond`` is false. Also available as the macro ``@assert "
"expr``."
msgstr ""

#: ../../stdlib/base.rst:6192
msgid ""
"Raise an error if ``cond`` is false. Preferred syntax for writings "
"assertions."
msgstr ""

#: ../../stdlib/base.rst:6196
msgid "The parameters given to a function call are not valid."
msgstr ""

#: ../../stdlib/base.rst:6200
msgid ""
"An indexing operation into an array tried to access an out-of-bounds "
"element."
msgstr ""

#: ../../stdlib/base.rst:6204
msgid "No more data was available to read from a file or stream."
msgstr ""

#: ../../stdlib/base.rst:6208
msgid ""
"Generic error type. The error message, in the `.msg` field, may provide more"
" specific details."
msgstr ""

#: ../../stdlib/base.rst:6212
msgid ""
"An indexing operation into an ``Associative`` (``Dict``) or ``Set`` like "
"object tried to access or delete a non-existent element."
msgstr ""

#: ../../stdlib/base.rst:6216
msgid ""
"An error occurred while `including`, `requiring`, or `using` a file. The "
"error specifics should be available in the `.error` field."
msgstr ""

#: ../../stdlib/base.rst:6220
msgid ""
"A method with the required type signature does not exist in the given "
"generic function."
msgstr ""

#: ../../stdlib/base.rst:6224
msgid ""
"The expression passed to the `parse` function could not be interpreted as a "
"valid Julia expression."
msgstr ""

#: ../../stdlib/base.rst:6228
msgid ""
"After a client Julia process has exited, further attempts to reference the "
"dead child will throw this exception."
msgstr ""

#: ../../stdlib/base.rst:6232
msgid ""
"A system call failed with an error code (in the ``errno`` global variable)."
msgstr ""

#: ../../stdlib/base.rst:6236
msgid ""
"A type assertion failure, or calling an intrinsic function with an incorrect"
" argument type."
msgstr ""

#: ../../stdlib/base.rst:6240
msgid "Tasks"
msgstr ""

#: ../../stdlib/base.rst:6244
msgid ""
"Create a ``Task`` (i.e. thread, or coroutine) to execute the given function "
"(which must be callable with no arguments). The task exits when this "
"function returns."
msgstr ""

#: ../../stdlib/base.rst:6248
msgid ""
"Switch to the given task. The first time a task is switched to, the task's "
"function is called with no arguments. On subsequent switches, ``args`` are "
"returned from the task's last call to ``yieldto``. This is a low-level call "
"that only switches tasks, not considering states or scheduling in any way."
msgstr ""

#: ../../stdlib/base.rst:6252
msgid "Get the currently running Task."
msgstr ""

#: ../../stdlib/base.rst:6256
msgid "Tell whether a task has exited."
msgstr ""

#: ../../stdlib/base.rst:6260
msgid ""
"Receive the next value passed to ``produce`` by the specified task. "
"Additional arguments may be passed, to be returned from the last ``produce``"
" call in the producer."
msgstr ""

#: ../../stdlib/base.rst:6266
msgid ""
"Send the given value to the last ``consume`` call, switching to the consumer"
" task. If the next ``consume`` call passes any values, they are returned by "
"``produce``."
msgstr ""

#: ../../stdlib/base.rst:6271
msgid ""
"Switch to the scheduler to allow another scheduled task to run. A task that "
"calls this function is still runnable, and will be restarted immediately if "
"there are no other runnable tasks."
msgstr ""

#: ../../stdlib/base.rst:6275
msgid ""
"Look up the value of a symbol in the current task's task-local storage."
msgstr ""

#: ../../stdlib/base.rst:6279
msgid "Assign a value to a symbol in the current task's task-local storage."
msgstr ""

#: ../../stdlib/base.rst:6283
msgid ""
"Call the function ``body`` with a modified task-local storage, in which "
"``value`` is assigned to ``symbol``; the previous value of ``symbol``, or "
"lack thereof, is restored afterwards. Useful for emulating dynamic scoping."
msgstr ""

#: ../../stdlib/base.rst:6289
msgid ""
"Create an edge-triggered event source that tasks can wait for. Tasks that "
"call ``wait`` on a ``Condition`` are suspended and queued. Tasks are woken "
"up when ``notify`` is later called on the ``Condition``. Edge triggering "
"means that only tasks waiting at the time ``notify`` is called can be woken "
"up. For level-triggered notifications, you must keep extra state to keep "
"track of whether a notification has happened. The ``RemoteRef`` type does "
"this, and so can be used for level-triggered events."
msgstr ""

#: ../../stdlib/base.rst:6300
msgid ""
"Wake up tasks waiting for a condition, passing them ``val``. If ``all`` is "
"true (the default), all waiting tasks are woken, otherwise only one is. If "
"``error`` is true, the passed value is raised as an exception in the woken "
"tasks."
msgstr ""

#: ../../stdlib/base.rst:6307
msgid ""
"Add a task to the scheduler's queue. This causes the task to run constantly "
"when the system is otherwise idle, unless the task performs a blocking "
"operation such as ``wait``."
msgstr ""

#: ../../stdlib/base.rst:6311
msgid ""
"If a second argument is provided, it will be passed to the task (via the "
"return value of ``yieldto``) when it runs again. If ``error`` is true, the "
"value is raised as an exception in the woken task."
msgstr ""

#: ../../stdlib/base.rst:6317
msgid "Wrap an expression in a Task and add it to the scheduler's queue."
msgstr ""

#: ../../stdlib/base.rst:6321
msgid ""
"Wrap an expression in a Task executing it, and return the Task. This only "
"creates a task, and does not run it."
msgstr ""

#: ../../stdlib/base.rst:6326
msgid ""
"Block the current task for a specified number of seconds. The minimum sleep "
"time is 1 millisecond or input of ``0.001``."
msgstr ""

#: ../../stdlib/base.rst:6330
msgid "Events"
msgstr ""

#: ../../stdlib/base.rst:6334
msgid ""
"Create a timer to call the given callback function. The callback is passed "
"one argument, the timer object itself. The timer can be started and stopped "
"with ``start_timer`` and ``stop_timer``."
msgstr ""

#: ../../stdlib/base.rst:6340
msgid ""
"Start invoking the callback for a ``Timer`` after the specified initial "
"delay, and then repeating with the given interval. Times are in seconds. If "
"``repeat`` is ``0``, the timer is only triggered once."
msgstr ""

#: ../../stdlib/base.rst:6346
msgid "Stop invoking the callback for a timer."
msgstr ""

#: ../../stdlib/base.rst:6349
msgid "Reflection"
msgstr ""

#: ../../stdlib/base.rst:6353
msgid "Get the name of a module as a symbol."
msgstr ""

#: ../../stdlib/base.rst:6357
msgid "Get a module's enclosing module. ``Main`` is its own parent."
msgstr ""

#: ../../stdlib/base.rst:6361
msgid ""
"Get the *dynamically* current module, which is the module code is currently "
"being read from. In general, this is not the same as the module containing "
"the call to this function."
msgstr ""

#: ../../stdlib/base.rst:6367
msgid ""
"Get the fully-qualified name of a module as a tuple of symbols. For example,"
" ``fullname(Base.Pkg)`` gives ``(:Base,:Pkg)``, and ``fullname(Main)`` gives"
" ``()``."
msgstr ""

#: ../../stdlib/base.rst:6372
msgid ""
"Get an array of the names exported by a module, with optionally more module "
"globals according to the additional parameters."
msgstr ""

#: ../../stdlib/base.rst:6377
msgid "Get an array of the fields of a data type."
msgstr ""

#: ../../stdlib/base.rst:6381
msgid ""
"Determine whether a global is declared ``const`` in a given module. The "
"default module argument is ``current_module()``."
msgstr ""

#: ../../stdlib/base.rst:6386
msgid "Determine whether a function is generic."
msgstr ""

#: ../../stdlib/base.rst:6390
msgid "Get the name of a generic function as a symbol, or ``:anonymous``."
msgstr ""

#: ../../stdlib/base.rst:6394
msgid ""
"Determine the module containing a given definition of a generic function."
msgstr ""

#: ../../stdlib/base.rst:6398
msgid ""
"Returns a tuple ``(filename,line)`` giving the location of a method "
"definition."
msgstr ""

#: ../../stdlib/base.rst:6402
msgid ""
"Returns an array of the results of ``functionloc`` for all matching "
"definitions."
msgstr ""

#: ../../stdlib/base.rst:6405
msgid "Internals"
msgstr ""

#: ../../stdlib/base.rst:6409
msgid "Perform garbage collection. This should not generally be used."
msgstr ""

#: ../../stdlib/base.rst:6413
msgid ""
"Disable garbage collection. This should be used only with extreme caution, "
"as it can cause memory use to grow without bound."
msgstr ""

#: ../../stdlib/base.rst:6418
msgid "Re-enable garbage collection after calling ``gc_disable``."
msgstr ""

#: ../../stdlib/base.rst:6422
msgid ""
"Takes the expression x and returns an equivalent expression with all macros "
"removed (expanded)."
msgstr ""

#: ../../stdlib/base.rst:6426
msgid ""
"Takes the expression x and returns an equivalent expression in lowered form"
msgstr ""

#: ../../stdlib/base.rst:6430
msgid ""
"Returns an array of lowered ASTs for the methods matching the given generic "
"function and type signature."
msgstr ""

#: ../../stdlib/base.rst:6434
msgid ""
"Evaluates the arguments to the function call, determines their types, and "
"calls the ``code_lowered`` function on the resulting expression"
msgstr ""

#: ../../stdlib/base.rst:6438
msgid ""
"Returns an array of lowered and type-inferred ASTs for the methods matching "
"the given generic function and type signature."
msgstr ""

#: ../../stdlib/base.rst:6442
msgid ""
"Evaluates the arguments to the function call, determines their types, and "
"calls the ``code_typed`` function on the resulting expression"
msgstr ""

#: ../../stdlib/base.rst:6446
msgid ""
"Prints the LLVM bitcodes generated for running the method matching the given"
" generic function and type signature to STDOUT."
msgstr ""

#: ../../stdlib/base.rst:6450
msgid ""
"Evaluates the arguments to the function call, determines their types, and "
"calls the ``code_llvm`` function on the resulting expression"
msgstr ""

#: ../../stdlib/base.rst:6454
msgid ""
"Prints the native assembly instructions generated for running the method "
"matching the given generic function and type signature to STDOUT."
msgstr ""

#: ../../stdlib/base.rst:6458
msgid ""
"Evaluates the arguments to the function call, determines their types, and "
"calls the ``code_native`` function on the resulting expression"
msgstr ""

#: ../../stdlib/base.rst:6462
msgid ""
"Compile the given function ``f`` for the argument tuple (of types) ``args``,"
" but do not execute it."
msgstr ""

#: ../../stdlib/collections.rst:4
msgid "Collections and Data Structures"
msgstr ""

#: ../../stdlib/collections.rst:6
msgid ""
"The ``Collections`` module contains implementations of some common data "
"structures."
msgstr ""

#: ../../stdlib/collections.rst:11
msgid "PriorityQueue"
msgstr ""

#: ../../stdlib/collections.rst:13
msgid ""
"The ``PriorityQueue`` type is a basic priority queue implementation allowing"
" for arbitrary key and priority types. Multiple identical keys are not "
"permitted, but the priority of existing keys can be changed efficiently."
msgstr ""

#: ../../stdlib/collections.rst:19
msgid ""
"Construct a new PriorityQueue, with keys of type ``K`` and values/priorites "
"of type ``V``. If an order is not given, the priority queue is min-ordered "
"using the default comparison for ``V``."
msgstr ""

#: ../../stdlib/collections.rst:25
msgid ""
"Insert the a key ``k`` into a priority queue ``pq`` with priority ``v``."
msgstr ""

#: ../../stdlib/collections.rst:29
msgid "Remove and return the lowest priority key from a priority queue."
msgstr ""

#: ../../stdlib/collections.rst:33
msgid ""
"Return the lowest priority key from a priority queue without removing that "
"key from the queue."
msgstr ""

#: ../../stdlib/collections.rst:35
msgid ""
"``PriorityQueue`` also behaves similarly to a ``Dict`` so that keys can be "
"inserted and priorities accessed or changed using indexing notation::"
msgstr ""

#: ../../stdlib/collections.rst:51
msgid "Heap Functions"
msgstr ""

#: ../../stdlib/collections.rst:53
msgid ""
"Along with the ``PriorityQueue`` type are lower level functions for "
"performing binary heap operations on arrays. Each function takes an optional"
" ordering argument. If not given, default ordering is used, so that elements"
" popped from the heap are given in ascending order."
msgstr ""

#: ../../stdlib/collections.rst:60
msgid ""
"Return a new vector in binary heap order, optionally using the given "
"ordering."
msgstr ""

#: ../../stdlib/collections.rst:65
msgid "In-place heapify."
msgstr ""

#: ../../stdlib/collections.rst:69
msgid "Return true iff an array is heap-ordered according to the given order."
msgstr ""

#: ../../stdlib/collections.rst:73
msgid ""
"Given a binary heap-ordered array, push a new element ``x``, preserving the "
"heap property. For efficiency, this function does not check that the array "
"is indeed heap-ordered."
msgstr ""

#: ../../stdlib/collections.rst:79
msgid ""
"Given a binary heap-ordered array, remove and return the lowest ordered "
"element. For efficiency, this function does not check that the array is "
"indeed heap-ordered."
msgstr ""

#: ../../stdlib/constants.rst:5 ../../stdlib/dates.rst:378
msgid "Constants"
msgstr ""

#: ../../stdlib/constants.rst:9
msgid ""
"A symbol representing the name of the operating system. Possible values are "
"``:Linux``, ``:Darwin`` (OS X), or ``:Windows``."
msgstr ""

#: ../../stdlib/constants.rst:14
msgid "An array of the command line arguments passed to Julia, as strings."
msgstr ""

#: ../../stdlib/constants.rst:18
msgid ""
"The C null pointer constant, sometimes used when calling external code."
msgstr ""

#: ../../stdlib/constants.rst:22
msgid "The number of CPU cores in the system."
msgstr ""

#: ../../stdlib/constants.rst:26
msgid "Standard word size on the current machine, in bits."
msgstr ""

#: ../../stdlib/constants.rst:30
msgid "An object describing which version of Julia is in use."
msgstr ""

#: ../../stdlib/constants.rst:34
msgid ""
"An array of paths (as strings) where the ``require`` function looks for "
"code."
msgstr ""

#: ../../stdlib/constants.rst:38
msgid ""
"A string containing the full path to the directory containing the ``julia`` "
"executable."
msgstr ""

#: ../../stdlib/constants.rst:42
msgid ""
"Equivalent to ``Any`` for dispatch purposes, but signals the compiler to "
"skip code generation specialization for that field"
msgstr ""

#: ../../stdlib/constants.rst:44
msgid "See also:"
msgstr ""

#: ../../stdlib/constants.rst:46
msgid ""
":data:`STDIN` :data:`STDOUT` :data:`STDERR` :data:`ENV` :data:`ENDIAN_BOM` "
":data:`MS_ASYNC` :data:`MS_INVALIDATE` :data:`MS_SYNC` :data:`DL_LOAD_PATH` "
":data:`RTLD_DEEPBIND` :data:`RTLD_LOCAL` :data:`RTLD_NOLOAD` "
":data:`RTLD_LAZY` :data:`RTLD_NOW` :data:`RTLD_GLOBAL` :data:`RTLD_NODELETE`"
" :data:`RTLD_FIRST`"
msgstr ""

#: ../../stdlib/dates.rst:4
msgid "Dates Types"
msgstr ""

#: ../../stdlib/dates.rst:16
msgid "``Period`` types represent discrete, human representations of time."
msgstr ""

#: ../../stdlib/dates.rst:20
msgid ""
"``Instant`` types represent integer-based, machine representations of time "
"as continuous timelines starting from an epoch."
msgstr ""

#: ../../stdlib/dates.rst:24
msgid ""
"The ``UTInstant`` represents a machine timeline based on `UT` time (1 day = "
"one revolution of the earth). The ``{T}`` is a ``Period`` parameter that "
"indicates the resolution or precision of the instant."
msgstr ""

#: ../../stdlib/dates.rst:28
msgid ""
"``TimeType`` types wrap ``Instant`` machine instances to provide human "
"representations of the machine instant."
msgstr ""

#: ../../stdlib/dates.rst:32
msgid ""
"``DateTime`` wraps a ``UTInstant{Millisecond}`` and interprets it according "
"to the proleptic Gregorian calendar."
msgstr ""

#: ../../stdlib/dates.rst:36
msgid ""
"``Date`` wraps a ``UTInstant{Day}`` and interprets it according to the "
"proleptic Gregorian calendar."
msgstr ""

#: ../../stdlib/dates.rst:39
msgid "Dates Functions"
msgstr ""

#: ../../stdlib/dates.rst:41
msgid ""
"All Dates functions are defined in the ``Dates`` module; note that only the "
"``Date``, ``DateTime``, and ``now`` functions are exported; to use all other"
" ``Dates`` functions, you'll need to prefix each function call with an "
"explicit ``Dates.``, e.g. ``Dates.dayofweek(dt)``; alternatively, you could "
"call ``using Dates`` to bring all exported functions into ``Main`` to be "
"used without the ``Dates.`` prefix."
msgstr ""

#: ../../stdlib/dates.rst:48
msgid ""
"Construct a DateTime type by parts. Arguments must be convertible to "
"``Int64``."
msgstr ""

#: ../../stdlib/dates.rst:53
msgid ""
"Constuct a DateTime type by ``Period`` type parts. Arguments may be in any "
"order. DateTime parts not provided will default to the value of "
"``Dates.default(period)``."
msgstr ""

#: ../../stdlib/dates.rst:58
msgid ""
"Create a DateTime through the adjuster API. The starting point will be "
"constructed from the provided ``y, m, d...`` arguments, and will be adjusted"
" until ``f::Function`` returns true. The step size in adjusting can be "
"provided manually through the ``step`` keyword. If ``negate=true``, then the"
" adjusting will stop when ``f::Function`` returns false instead of true. "
"``limit`` provides a limit to the max number of iterations the adjustment "
"API will pursue before throwing an error (in the case that ``f::Function`` "
"is never satisfied)."
msgstr ""

#: ../../stdlib/dates.rst:67
msgid ""
"Converts a ``Date`` type to a ``DateTime``. The hour, minute, second, and "
"millisecond parts of the new ``DateTime`` are assumed to be zero."
msgstr ""

#: ../../stdlib/dates.rst:72
msgid ""
"Construct a DateTime type by parsing the ``dt`` date string following the "
"pattern given in the ``format`` string. The following codes can be used for "
"constructing format strings:"
msgstr ""

#: ../../stdlib/dates.rst:76
msgid "Code"
msgstr ""

#: ../../stdlib/dates.rst:76
msgid "Matches"
msgstr ""

#: ../../stdlib/dates.rst:76
msgid "Comment"
msgstr ""

#: ../../stdlib/dates.rst:78
msgid "``y``"
msgstr ""

#: ../../stdlib/dates.rst:78
msgid "1996, 96"
msgstr ""

#: ../../stdlib/dates.rst:78
msgid "Returns year of 1996, 0096"
msgstr ""

#: ../../stdlib/dates.rst:79
msgid "``m``"
msgstr ""

#: ../../stdlib/dates.rst:79 ../../stdlib/dates.rst:82
msgid "1, 01"
msgstr ""

#: ../../stdlib/dates.rst:79
msgid "Matches 1 or 2-digit months"
msgstr ""

#: ../../stdlib/dates.rst:80
msgid "``u``"
msgstr ""

#: ../../stdlib/dates.rst:80
msgid "Jan"
msgstr ""

#: ../../stdlib/dates.rst:80
msgid "Matches abbreviated months according to the ``locale`` keyword"
msgstr ""

#: ../../stdlib/dates.rst:81
msgid "``U``"
msgstr ""

#: ../../stdlib/dates.rst:81
msgid "January"
msgstr ""

#: ../../stdlib/dates.rst:81
msgid "Matches full month names according to the ``locale`` keyword"
msgstr ""

#: ../../stdlib/dates.rst:82
msgid "``d``"
msgstr ""

#: ../../stdlib/dates.rst:82
msgid "Matches 1 or 2-digit days"
msgstr ""

#: ../../stdlib/dates.rst:83
msgid "``H``"
msgstr ""

#: ../../stdlib/dates.rst:83 ../../stdlib/dates.rst:84
#: ../../stdlib/dates.rst:85
msgid "00"
msgstr ""

#: ../../stdlib/dates.rst:83
msgid "Matches hours"
msgstr ""

#: ../../stdlib/dates.rst:84
msgid "``M``"
msgstr ""

#: ../../stdlib/dates.rst:84
msgid "Matches minutes"
msgstr ""

#: ../../stdlib/dates.rst:85
msgid "``S``"
msgstr ""

#: ../../stdlib/dates.rst:85
msgid "Matches seconds"
msgstr ""

#: ../../stdlib/dates.rst:86
msgid "``s``"
msgstr ""

#: ../../stdlib/dates.rst:86
msgid ".500"
msgstr ""

#: ../../stdlib/dates.rst:86
msgid "Matches milliseconds"
msgstr ""

#: ../../stdlib/dates.rst:87
msgid "``e``"
msgstr ""

#: ../../stdlib/dates.rst:87
msgid "Mon, Tues"
msgstr ""

#: ../../stdlib/dates.rst:87
msgid "Matches abbreviated days of the week"
msgstr ""

#: ../../stdlib/dates.rst:88
msgid "``E``"
msgstr ""

#: ../../stdlib/dates.rst:88
msgid "Monday"
msgstr ""

#: ../../stdlib/dates.rst:88
msgid "Matches full name days of the week"
msgstr ""

#: ../../stdlib/dates.rst:89
msgid "``yyyymmdd``"
msgstr ""

#: ../../stdlib/dates.rst:89
msgid "19960101"
msgstr ""

#: ../../stdlib/dates.rst:89
msgid "Matches fixed-width year, month, and day"
msgstr ""

#: ../../stdlib/dates.rst:92
msgid ""
"All characters not listed above are treated as delimiters between date and "
"time slots. So a ``dt`` string of \"1996-01-15T00:00:00.0\" would have a "
"``format`` string like \"y-m-dTH:M:S.s\"."
msgstr ""

#: ../../stdlib/dates.rst:98
msgid ""
"Construct a ``Date`` type by parts. Arguments must be convertible to "
"``Int64``."
msgstr ""

#: ../../stdlib/dates.rst:103
msgid ""
"Constuct a Date type by ``Period`` type parts. Arguments may be in any "
"order. Date parts not provided will default to the value of "
"``Dates.default(period)``."
msgstr ""

#: ../../stdlib/dates.rst:108
msgid ""
"Create a Date through the adjuster API. The starting point will be "
"constructed from the provided ``y, m`` arguments, and will be adjusted until"
" ``f::Function`` returns true. The step size in adjusting can be provided "
"manually through the ``step`` keyword. If ``negate=true``, then the "
"adjusting will stop when ``f::Function`` returns false instead of true. "
"``limit`` provides a limit to the max number of iterations the adjustment "
"API will pursue before throwing an error (given that ``f::Function`` is "
"never satisfied)."
msgstr ""

#: ../../stdlib/dates.rst:117
msgid ""
"Converts a ``DateTime`` type to a ``Date``. The hour, minute, second, and "
"millisecond parts of the ``DateTime`` are truncated, so only the year, month"
" and day parts are used in construction."
msgstr ""

#: ../../stdlib/dates.rst:122
msgid ""
"Construct a Date type by parsing a ``dt`` date string following the pattern "
"given in the ``format`` string. Follows the same conventions as ``DateTime``"
" above."
msgstr ""

#: ../../stdlib/dates.rst:127
msgid ""
"Returns a DateTime corresponding to the user's system time including the "
"system timezone locale."
msgstr ""

#: ../../stdlib/dates.rst:132
msgid "Returns a DateTime corresponding to the user's system time as UTC/GMT."
msgstr ""

#: ../../stdlib/dates.rst:136
msgid "Accessor Functions"
msgstr ""

#: ../../stdlib/dates.rst:147
msgid "Return the field part of a Date or DateTime as an ``Int64``."
msgstr ""

#: ../../stdlib/dates.rst:158
msgid "Return the field part of a Date or DateTime as a ``Period`` type."
msgstr ""

#: ../../stdlib/dates.rst:162
msgid "Simultaneously return the year and month parts of a Date or DateTime."
msgstr ""

#: ../../stdlib/dates.rst:166
msgid "Simultaneously return the month and day parts of a Date or DateTime."
msgstr ""

#: ../../stdlib/dates.rst:170
msgid ""
"Simultaneously return the year, month, and day parts of a Date or DateTime."
msgstr ""

#: ../../stdlib/dates.rst:173
msgid "Query Functions"
msgstr ""

#: ../../stdlib/dates.rst:177
msgid ""
"Return the full day name corresponding to the day of the week of the Date or"
" DateTime in the given ``locale``."
msgstr ""

#: ../../stdlib/dates.rst:182
msgid ""
"Return the abbreviated name corresponding to the day of the week of the Date"
" or DateTime in the given ``locale``."
msgstr ""

#: ../../stdlib/dates.rst:187
msgid ""
"Returns the day of the week as an ``Int64`` with ``1 = Monday, 2 = Tuesday, "
"etc.``."
msgstr ""

#: ../../stdlib/dates.rst:191
msgid ""
"For the day of week of ``dt``, returns which number it is in ``dt``'s month."
" So if the day of the week of ``dt`` is Monday, then ``1 = First Monday of "
"the month, 2 = Second Monday of the month, etc.`` In the range 1:5."
msgstr ""

#: ../../stdlib/dates.rst:197
msgid ""
"For the day of week of ``dt``, returns the total number of that day of the "
"week in ``dt``'s month. Returns 4 or 5. Useful in temporal expressions for "
"specifying the last day of a week in a month by including "
"``dayofweekofmonth(dt) == daysofweekinmonth(dt)`` in the adjuster function."
msgstr ""

#: ../../stdlib/dates.rst:204
msgid ""
"Return the full name of the month of the Date or DateTime in the given "
"``locale``."
msgstr ""

#: ../../stdlib/dates.rst:208
msgid ""
"Return the abbreviated month name of the Date or DateTime in the given "
"``locale``."
msgstr ""

#: ../../stdlib/dates.rst:212
msgid ""
"Returns the number of days in the month of ``dt``. Value will be 28, 29, 30,"
" or 31."
msgstr ""

#: ../../stdlib/dates.rst:216
msgid "Returns true if the year of ``dt`` is a leap year."
msgstr ""

#: ../../stdlib/dates.rst:220
msgid "Returns the day of the year for ``dt`` with January 1st being day 1."
msgstr ""

#: ../../stdlib/dates.rst:224
msgid ""
"Returns 366 if the year of ``dt`` is a leap year, otherwise returns 365."
msgstr ""

#: ../../stdlib/dates.rst:228
msgid "Returns the quarter that ``dt`` resides in. Range of value is 1:4."
msgstr ""

#: ../../stdlib/dates.rst:232
msgid ""
"Returns the day of the current quarter of ``dt``. Range of value is 1:92."
msgstr ""

#: ../../stdlib/dates.rst:235
msgid "Adjuster Functions"
msgstr ""

#: ../../stdlib/dates.rst:239
msgid ""
"Truncates the value of ``dt`` according to the provided ``Period`` type. "
"E.g. if ``dt`` is ``1996-01-01T12:30:00``, then ``trunc(dt,Day) == "
"1996-01-01T00:00:00``."
msgstr ""

#: ../../stdlib/dates.rst:244
msgid "Adjusts ``dt`` to the Monday of its week."
msgstr ""

#: ../../stdlib/dates.rst:248
msgid "Adjusts ``dt`` to the Sunday of its week."
msgstr ""

#: ../../stdlib/dates.rst:252
msgid "Adjusts ``dt`` to the first day of its month."
msgstr ""

#: ../../stdlib/dates.rst:256
msgid "Adjusts ``dt`` to the last day of its month."
msgstr ""

#: ../../stdlib/dates.rst:260
msgid "Adjusts ``dt`` to the first day of its year."
msgstr ""

#: ../../stdlib/dates.rst:264
msgid "Adjusts ``dt`` to the last day of its year."
msgstr ""

#: ../../stdlib/dates.rst:268
msgid "Adjusts ``dt`` to the first day of its quarter."
msgstr ""

#: ../../stdlib/dates.rst:272
msgid "Adjusts ``dt`` to the last day of its quarter."
msgstr ""

#: ../../stdlib/dates.rst:276
msgid ""
"Adjusts ``dt`` to the next day of week corresponding to ``dow`` with ``1 = "
"Monday, 2 = Tuesday, etc``. Setting ``same=true`` allows the current ``dt`` "
"to be considered as the next ``dow``, allowing for no adjustment to occur."
msgstr ""

#: ../../stdlib/dates.rst:282
msgid ""
"Adjusts ``dt`` to the previous day of week corresponding to ``dow`` with ``1"
" = Monday, 2 = Tuesday, etc``. Setting ``same=true`` allows the current "
"``dt`` to be considered as the previous ``dow``, allowing for no adjustment "
"to occur."
msgstr ""

#: ../../stdlib/dates.rst:288
msgid ""
"Adjusts ``dt`` to the first ``dow`` of its month. Alternatively, ``of=Year``"
" will adjust to the first ``dow`` of the year."
msgstr ""

#: ../../stdlib/dates.rst:293
msgid ""
"Adjusts ``dt`` to the last ``dow`` of its month. Alternatively, ``of=Year`` "
"will adjust to the last ``dow`` of the year."
msgstr ""

#: ../../stdlib/dates.rst:298 ../../stdlib/dates.rst:305
msgid ""
"Adjusts ``dt`` by iterating at most ``limit`` iterations by ``step`` "
"increments until ``func`` returns true. ``func`` must take a single "
"``TimeType`` argument and return a ``Bool``. ``same`` allows ``dt`` to be "
"considered in satisfying ``func``. ``negate`` will make the adjustment "
"process terminate when ``func`` returns false instead of true."
msgstr ""

#: ../../stdlib/dates.rst:312
msgid ""
"``func`` takes a single TimeType argument and returns a ``Bool`` indicating "
"whether the input should be \"included\" in the final set. ``recur`` applies"
" ``func`` over each element in the range of ``dr``, including those elements"
" for which ``func`` returns ``true`` in the resulting Array, unless "
"``negate=true``, then only elements where ``func`` returns ``false`` are "
"included."
msgstr ""

#: ../../stdlib/dates.rst:319
msgid "Periods"
msgstr ""

#: ../../stdlib/dates.rst:330
msgid ""
"Construct a ``Period`` type with the given ``v`` value. Input must be "
"losslessly convertible to an ``Int64``."
msgstr ""

#: ../../stdlib/dates.rst:335
msgid ""
"Returns a sensible \"default\" value for the input Period by returning "
"``one(p)`` for Year, Month, and Day, and ``zero(p)`` for Hour, Minute, "
"Second, and Millisecond."
msgstr ""

#: ../../stdlib/dates.rst:340
msgid "Conversion Functions"
msgstr ""

#: ../../stdlib/dates.rst:344
msgid "Returns the date portion of ``now()``."
msgstr ""

#: ../../stdlib/dates.rst:348
msgid ""
"Takes the number of seconds since unix epoch ``1970-01-01T00:00:00`` and "
"converts to the corresponding DateTime."
msgstr ""

#: ../../stdlib/dates.rst:353
msgid ""
"Takes the given DateTime and returns the number of seconds since the unix "
"epoch as a ``Float64``."
msgstr ""

#: ../../stdlib/dates.rst:358
msgid ""
"Takes the number of Julian calendar days since epoch "
"``-4713-11-24T12:00:00`` and returns the corresponding DateTime."
msgstr ""

#: ../../stdlib/dates.rst:363
msgid ""
"Takes the given DateTime and returns the number of Julian calendar days "
"since the julian epoch as a ``Float64``."
msgstr ""

#: ../../stdlib/dates.rst:368
msgid ""
"Takes the number of Rata Die days since epoch ``0000-12-31T00:00:00`` and "
"returns the corresponding DateTime."
msgstr ""

#: ../../stdlib/dates.rst:373
msgid ""
"Returns the number of Rata Die days since epoch from the given Date or "
"DateTime."
msgstr ""

#: ../../stdlib/dates.rst:380
msgid "Days of the Week:"
msgstr ""

#: ../../stdlib/dates.rst:383 ../../stdlib/dates.rst:397
msgid "Variable"
msgstr ""

#: ../../stdlib/dates.rst:383 ../../stdlib/dates.rst:397
msgid "Abbr."
msgstr ""

#: ../../stdlib/dates.rst:383 ../../stdlib/dates.rst:397
msgid "Value (Int64)"
msgstr ""

#: ../../stdlib/dates.rst:385
msgid "``Monday``"
msgstr ""

#: ../../stdlib/dates.rst:385
msgid "``Mon``"
msgstr ""

#: ../../stdlib/dates.rst:385 ../../stdlib/dates.rst:399
msgid "1"
msgstr ""

#: ../../stdlib/dates.rst:386
msgid "``Tuesday``"
msgstr ""

#: ../../stdlib/dates.rst:386
msgid "``Tue``"
msgstr ""

#: ../../stdlib/dates.rst:386 ../../stdlib/dates.rst:400
msgid "2"
msgstr ""

#: ../../stdlib/dates.rst:387
msgid "``Wednesday``"
msgstr ""

#: ../../stdlib/dates.rst:387
msgid "``Wed``"
msgstr ""

#: ../../stdlib/dates.rst:387 ../../stdlib/dates.rst:401
msgid "3"
msgstr ""

#: ../../stdlib/dates.rst:388
msgid "``Thursday``"
msgstr ""

#: ../../stdlib/dates.rst:388
msgid "``Thu``"
msgstr ""

#: ../../stdlib/dates.rst:388 ../../stdlib/dates.rst:402
msgid "4"
msgstr ""

#: ../../stdlib/dates.rst:389
msgid "``Friday``"
msgstr ""

#: ../../stdlib/dates.rst:389
msgid "``Fri``"
msgstr ""

#: ../../stdlib/dates.rst:389 ../../stdlib/dates.rst:403
msgid "5"
msgstr ""

#: ../../stdlib/dates.rst:390
msgid "``Saturday``"
msgstr ""

#: ../../stdlib/dates.rst:390
msgid "``Sat``"
msgstr ""

#: ../../stdlib/dates.rst:390 ../../stdlib/dates.rst:404
msgid "6"
msgstr ""

#: ../../stdlib/dates.rst:391
msgid "``Sunday``"
msgstr ""

#: ../../stdlib/dates.rst:391
msgid "``Sun``"
msgstr ""

#: ../../stdlib/dates.rst:391 ../../stdlib/dates.rst:405
msgid "7"
msgstr ""

#: ../../stdlib/dates.rst:394
msgid "Months of the Year:"
msgstr ""

#: ../../stdlib/dates.rst:399
msgid "``January``"
msgstr ""

#: ../../stdlib/dates.rst:399
msgid "``Jan``"
msgstr ""

#: ../../stdlib/dates.rst:400
msgid "``February``"
msgstr ""

#: ../../stdlib/dates.rst:400
msgid "``Feb``"
msgstr ""

#: ../../stdlib/dates.rst:401
msgid "``March``"
msgstr ""

#: ../../stdlib/dates.rst:401
msgid "``Mar``"
msgstr ""

#: ../../stdlib/dates.rst:402
msgid "``April``"
msgstr ""

#: ../../stdlib/dates.rst:402
msgid "``Apr``"
msgstr ""

#: ../../stdlib/dates.rst:403 ../../stdlib/dates.rst:403
msgid "``May``"
msgstr ""

#: ../../stdlib/dates.rst:404
msgid "``June``"
msgstr ""

#: ../../stdlib/dates.rst:404
msgid "``Jun``"
msgstr ""

#: ../../stdlib/dates.rst:405
msgid "``July``"
msgstr ""

#: ../../stdlib/dates.rst:405
msgid "``Jul``"
msgstr ""

#: ../../stdlib/dates.rst:406
msgid "``August``"
msgstr ""

#: ../../stdlib/dates.rst:406
msgid "``Aug``"
msgstr ""

#: ../../stdlib/dates.rst:406
msgid "8"
msgstr ""

#: ../../stdlib/dates.rst:407
msgid "``September``"
msgstr ""

#: ../../stdlib/dates.rst:407
msgid "``Sep``"
msgstr ""

#: ../../stdlib/dates.rst:407
msgid "9"
msgstr ""

#: ../../stdlib/dates.rst:408
msgid "``October``"
msgstr ""

#: ../../stdlib/dates.rst:408
msgid "``Oct``"
msgstr ""

#: ../../stdlib/dates.rst:408
msgid "10"
msgstr ""

#: ../../stdlib/dates.rst:409
msgid "``November``"
msgstr ""

#: ../../stdlib/dates.rst:409
msgid "``Nov``"
msgstr ""

#: ../../stdlib/dates.rst:409
msgid "11"
msgstr ""

#: ../../stdlib/dates.rst:410
msgid "``December``"
msgstr ""

#: ../../stdlib/dates.rst:410
msgid "``Dec``"
msgstr ""

#: ../../stdlib/dates.rst:410
msgid "12"
msgstr ""

#: ../../stdlib/file.rst:5
msgid "Filesystem"
msgstr ""

#: ../../stdlib/file.rst:9
msgid "Returns ``true`` if ``path`` is a block device, ``false`` otherwise."
msgstr ""

#: ../../stdlib/file.rst:13
msgid ""
"Returns ``true`` if ``path`` is a character device, ``false`` otherwise."
msgstr ""

#: ../../stdlib/file.rst:17
msgid "Returns ``true`` if ``path`` is a directory, ``false`` otherwise."
msgstr ""

#: ../../stdlib/file.rst:21
msgid ""
"Returns ``true`` if the current user has permission to execute ``path``, "
"``false`` otherwise."
msgstr ""

#: ../../stdlib/file.rst:26
msgid "Returns ``true`` if ``path`` is a FIFO, ``false`` otherwise."
msgstr ""

#: ../../stdlib/file.rst:30
msgid "Returns ``true`` if ``path`` is a regular file, ``false`` otherwise."
msgstr ""

#: ../../stdlib/file.rst:34
msgid "Returns ``true`` if ``path`` is a symbolic link, ``false`` otherwise."
msgstr ""

#: ../../stdlib/file.rst:38
msgid ""
"Returns ``true`` if ``path`` is a valid filesystem path, ``false`` "
"otherwise."
msgstr ""

#: ../../stdlib/file.rst:42
msgid ""
"Returns ``true`` if the current user has permission to read ``path``, "
"``false`` otherwise."
msgstr ""

#: ../../stdlib/file.rst:47
msgid ""
"Returns ``true`` if ``path`` has the setgid flag set, ``false`` otherwise."
msgstr ""

#: ../../stdlib/file.rst:51
msgid ""
"Returns ``true`` if ``path`` has the setuid flag set, ``false`` otherwise."
msgstr ""

#: ../../stdlib/file.rst:55
msgid "Returns ``true`` if ``path`` is a socket, ``false`` otherwise."
msgstr ""

#: ../../stdlib/file.rst:59
msgid ""
"Returns ``true`` if ``path`` has the sticky bit set, ``false`` otherwise."
msgstr ""

#: ../../stdlib/file.rst:63
msgid ""
"Returns ``true`` if the current user has permission to write to ``path``, "
"``false`` otherwise."
msgstr ""

#: ../../stdlib/file.rst:68
msgid "Return the current user's home directory."
msgstr ""

#: ../../stdlib/file.rst:72
msgid "Get the directory part of a path."
msgstr ""

#: ../../stdlib/file.rst:76
msgid "Get the file name part of a path."
msgstr ""

#: ../../stdlib/file.rst:80
msgid ""
"``@__FILE__`` expands to a string with the absolute path and file name of "
"the script being run. Returns ``nothing`` if run from a REPL or an empty "
"string if evaluated by ``julia -e <expr>``."
msgstr ""

#: ../../stdlib/file.rst:85
msgid "Determines whether a path is absolute (begins at the root directory)."
msgstr ""

#: ../../stdlib/file.rst:89
msgid ""
"Determines whether a path refers to a directory (for example, ends with a "
"path separator)."
msgstr ""

#: ../../stdlib/file.rst:93
msgid ""
"Join path components into a full path. If some argument is an absolute path,"
" then prior components are dropped."
msgstr ""

#: ../../stdlib/file.rst:98
msgid ""
"Convert a path to an absolute path by adding the current directory if "
"necessary."
msgstr ""

#: ../../stdlib/file.rst:103
msgid "Normalize a path, removing \".\" and \"..\" entries."
msgstr ""

#: ../../stdlib/file.rst:107
msgid ""
"Canonicalize a path by expanding symbolic links and removing \".\" and "
"\"..\" entries."
msgstr ""

#: ../../stdlib/file.rst:111
msgid ""
"On Unix systems, replace a tilde character at the start of a path with the "
"current user's home directory."
msgstr ""

#: ../../stdlib/file.rst:116
msgid "Split a path into a tuple of the directory name and file name."
msgstr ""

#: ../../stdlib/file.rst:120
msgid ""
"On Windows, split a path into the drive letter part and the path part. On "
"Unix systems, the first component is always the empty string."
msgstr ""

#: ../../stdlib/file.rst:125
msgid ""
"If the last component of a path contains a dot, split the path into "
"everything before the dot and everything including and after the dot. "
"Otherwise, return a tuple of the argument unmodified and the empty string."
msgstr ""

#: ../../stdlib/file.rst:131
msgid "Generate a unique temporary file path."
msgstr ""

#: ../../stdlib/file.rst:135
msgid ""
"Obtain the path of a temporary directory (possibly shared with other "
"processes)."
msgstr ""

#: ../../stdlib/file.rst:139
msgid ""
"Returns ``(path, io)``, where ``path`` is the path of a new temporary file "
"and ``io`` is an open file object for this path."
msgstr ""

#: ../../stdlib/file.rst:144
msgid "Create a temporary directory and return its path."
msgstr ""

#: ../../stdlib/graphics.rst:6
msgid "Graphics"
msgstr ""

#: ../../stdlib/graphics.rst:8
msgid ""
"The ``Base.Graphics`` interface is an abstract wrapper; specific packages "
"(e.g., Cairo and Tk/Gtk) implement much of the functionality."
msgstr ""

#: ../../stdlib/graphics.rst:11
msgid "Geometry"
msgstr ""

#: ../../stdlib/graphics.rst:15
msgid "Creates a point in two dimensions"
msgstr ""

#: ../../stdlib/graphics.rst:19
msgid "Creates a box in two dimensions with the given edges"
msgstr ""

#: ../../stdlib/graphics.rst:23
msgid "Creates a box in two dimensions that encloses all objects"
msgstr ""

#: ../../stdlib/graphics.rst:27
msgid "Computes the width of an object"
msgstr ""

#: ../../stdlib/graphics.rst:31
msgid "Computes the height of an object"
msgstr ""

#: ../../stdlib/graphics.rst:35
msgid "Computes the minimum x-coordinate contained in an object"
msgstr ""

#: ../../stdlib/graphics.rst:39
msgid "Computes the maximum x-coordinate contained in an object"
msgstr ""

#: ../../stdlib/graphics.rst:43
msgid "Computes the minimum y-coordinate contained in an object"
msgstr ""

#: ../../stdlib/graphics.rst:47
msgid "Computes the maximum y-coordinate contained in an object"
msgstr ""

#: ../../stdlib/graphics.rst:51
msgid "Return the length of the diagonal of an object"
msgstr ""

#: ../../stdlib/graphics.rst:55
msgid "Compute the height/width of an object"
msgstr ""

#: ../../stdlib/graphics.rst:59
msgid "Return the point in the center of an object"
msgstr ""

#: ../../stdlib/graphics.rst:63
msgid "Returns a tuple ``(xmin(obj), xmax(obj))``"
msgstr ""

#: ../../stdlib/graphics.rst:67
msgid "Returns a tuple ``(ymin(obj), ymax(obj))``"
msgstr ""

#: ../../stdlib/graphics.rst:71
msgid ""
"Rotates an object around origin by the specified angle (radians), returning "
"a new object of the same type.  Because of type-constancy, this new object "
"may not always be a strict geometric rotation of the input; for example, if "
"``obj`` is a ``BoundingBox`` the return is the smallest ``BoundingBox`` that"
" encloses the rotated input."
msgstr ""

#: ../../stdlib/graphics.rst:80
msgid ""
"Returns an object shifted horizontally and vertically by the indicated "
"amounts"
msgstr ""

#: ../../stdlib/graphics.rst:85
msgid ""
"Scale the width and height of a graphics object, keeping the center fixed"
msgstr ""

#: ../../stdlib/graphics.rst:90
msgid "Returns the smallest box containing both boxes"
msgstr ""

#: ../../stdlib/graphics.rst:95
msgid "Returns the intersection, the largest box contained in both boxes"
msgstr ""

#: ../../stdlib/graphics.rst:99
msgid "Returns a bounding box with all edges shifted by the indicated amounts"
msgstr ""

#: ../../stdlib/graphics.rst:103 ../../stdlib/graphics.rst:107
msgid "True if the given point is inside the box"
msgstr ""

#: ../../stdlib/index.rst:6
msgid "The Julia Standard Library"
msgstr ""

#: ../../stdlib/linalg.rst:4
msgid "Linear Algebra"
msgstr ""

#: ../../stdlib/linalg.rst:10
msgid ""
"Linear algebra functions in Julia are largely implemented by calling "
"functions from `LAPACK <http://www.netlib.org/lapack/>`_.  Sparse "
"factorizations call functions from `SuiteSparse "
"<http://faculty.cse.tamu.edu/davis/suitesparse.html>`_."
msgstr ""

#: ../../stdlib/linalg.rst:15
msgid "Matrix multiplication"
msgstr ""

#: ../../stdlib/linalg.rst:20
msgid ""
"Matrix division using a polyalgorithm. For input matrices ``A`` and ``B``, "
"the result ``X`` is such that ``A*X == B`` when ``A`` is square.  The solver"
" that is used depends upon the structure of ``A``.  A direct solver is used "
"for upper- or lower triangular ``A``.  For Hermitian ``A`` (equivalent to "
"symmetric ``A`` for non-complex ``A``) the ``BunchKaufman`` factorization is"
" used.  Otherwise an LU factorization is used. For rectangular ``A`` the "
"result is the minimum-norm least squares solution computed by a pivoted QR "
"factorization of ``A`` and a rank estimate of A based on the R factor. For "
"sparse, square ``A`` the LU factorization (from UMFPACK) is used."
msgstr ""

#: ../../stdlib/linalg.rst:25
msgid ""
"Compute the dot product. For complex vectors, the first vector is "
"conjugated."
msgstr ""

#: ../../stdlib/linalg.rst:30
msgid "Compute the cross product of two 3-vectors."
msgstr ""

#: ../../stdlib/linalg.rst:34
msgid "Compute the reduced row echelon form of the matrix A."
msgstr ""

#: ../../stdlib/linalg.rst:38
msgid ""
"Compute a convenient factorization (including LU, Cholesky, Bunch-Kaufman, "
"Triangular) of A, based upon the type of the input matrix. The return value "
"can then be reused for efficient solving of multiple systems. For example: "
"``A=factorize(A); x=A\\\\b; y=A\\\\C``."
msgstr ""

#: ../../stdlib/linalg.rst:42
msgid ""
"``factorize!`` is the same as :func:`factorize`, but saves space by "
"overwriting the input ``A``, instead of creating a copy."
msgstr ""

#: ../../stdlib/linalg.rst:46
msgid "Compute the LU factorization of ``A``, such that ``A[p,:] = L*U``."
msgstr ""

#: ../../stdlib/linalg.rst:50
msgid ""
"Compute the LU factorization of ``A``. The return type of ``F`` depends on "
"the type of ``A``. In most cases, if ``A`` is a subtype ``S`` of "
"AbstractMatrix with an element type ``T``` supporting ``+``, ``-``, ``*`` "
"and ``/`` the return type is ``LU{T,S{T}}``. If pivoting is chosen (default)"
" the element type should also support ``abs`` and ``<``. When ``A`` is "
"sparse and have element of type ``Float32``, ``Float64``, "
"``Complex{Float32}``, or ``Complex{Float64}`` the return type is "
"``UmfpackLU``. Some examples are shown in the table below."
msgstr ""

#: ../../stdlib/linalg.rst:53
msgid "Type of input ``A``"
msgstr ""

#: ../../stdlib/linalg.rst:53
msgid "Type of output ``F``"
msgstr ""

#: ../../stdlib/linalg.rst:53 ../../stdlib/linalg.rst:117
msgid "Relationship between ``F`` and ``A``"
msgstr ""

#: ../../stdlib/linalg.rst:55
msgid ":func:`Matrix`"
msgstr ""

#: ../../stdlib/linalg.rst:55 ../../stdlib/linalg.rst:63
#: ../../stdlib/linalg.rst:75
msgid "``LU``"
msgstr ""

#: ../../stdlib/linalg.rst:55
msgid "``F[:L]*F[:U] == A[F[:p], :]``"
msgstr ""

#: ../../stdlib/linalg.rst:56
msgid ":func:`Tridiagonal`"
msgstr ""

#: ../../stdlib/linalg.rst:56 ../../stdlib/linalg.rst:63
#: ../../stdlib/linalg.rst:75
msgid "``LU{T,Tridiagonal{T}}``"
msgstr ""

#: ../../stdlib/linalg.rst:56
msgid "N/A"
msgstr ""

#: ../../stdlib/linalg.rst:57
msgid ":func:`SparseMatrixCSC`"
msgstr ""

#: ../../stdlib/linalg.rst:57 ../../stdlib/linalg.rst:63
#: ../../stdlib/linalg.rst:75
msgid "``UmfpackLU``"
msgstr ""

#: ../../stdlib/linalg.rst:57
msgid "``F[:L]*F[:U] == F[:Rs] .* A[F[:p], F[:q]]``"
msgstr ""

#: ../../stdlib/linalg.rst:60 ../../stdlib/linalg.rst:126
msgid ""
"The individual components of the factorization ``F`` can be accessed by "
"indexing:"
msgstr ""

#: ../../stdlib/linalg.rst:63 ../../stdlib/linalg.rst:129
msgid "Component"
msgstr ""

#: ../../stdlib/linalg.rst:63 ../../stdlib/linalg.rst:129
msgid "Description"
msgstr ""

#: ../../stdlib/linalg.rst:65
msgid "``F[:L]``"
msgstr ""

#: ../../stdlib/linalg.rst:65
msgid "``L`` (lower triangular) part of ``LU``"
msgstr ""

#: ../../stdlib/linalg.rst:65 ../../stdlib/linalg.rst:65
#: ../../stdlib/linalg.rst:66 ../../stdlib/linalg.rst:66
#: ../../stdlib/linalg.rst:67 ../../stdlib/linalg.rst:67
#: ../../stdlib/linalg.rst:68 ../../stdlib/linalg.rst:69
#: ../../stdlib/linalg.rst:70 ../../stdlib/linalg.rst:71
#: ../../stdlib/linalg.rst:77 ../../stdlib/linalg.rst:78
#: ../../stdlib/linalg.rst:78 ../../stdlib/linalg.rst:78
#: ../../stdlib/linalg.rst:79 ../../stdlib/linalg.rst:79
#: ../../stdlib/linalg.rst:80 ../../stdlib/linalg.rst:80
#: ../../stdlib/linalg.rst:80 ../../stdlib/linalg.rst:81
#: ../../stdlib/linalg.rst:81 ../../stdlib/linalg.rst:132
#: ../../stdlib/linalg.rst:132 ../../stdlib/linalg.rst:132
#: ../../stdlib/linalg.rst:133 ../../stdlib/linalg.rst:134
msgid "✓"
msgstr ""

#: ../../stdlib/linalg.rst:66
msgid "``F[:U]``"
msgstr ""

#: ../../stdlib/linalg.rst:66
msgid "``U`` (upper triangular) part of ``LU``"
msgstr ""

#: ../../stdlib/linalg.rst:67 ../../stdlib/linalg.rst:133
msgid "``F[:p]``"
msgstr ""

#: ../../stdlib/linalg.rst:67
msgid "(right) permutation ``Vector``"
msgstr ""

#: ../../stdlib/linalg.rst:68 ../../stdlib/linalg.rst:134
msgid "``F[:P]``"
msgstr ""

#: ../../stdlib/linalg.rst:68
msgid "(right) permutation ``Matrix``"
msgstr ""

#: ../../stdlib/linalg.rst:69
msgid "``F[:q]``"
msgstr ""

#: ../../stdlib/linalg.rst:69
msgid "left permutation ``Vector``"
msgstr ""

#: ../../stdlib/linalg.rst:70
msgid "``F[:Rs]``"
msgstr ""

#: ../../stdlib/linalg.rst:70
msgid "``Vector`` of scaling factors"
msgstr ""

#: ../../stdlib/linalg.rst:71
msgid "``F[:(:)]``"
msgstr ""

#: ../../stdlib/linalg.rst:71
msgid "``(L,U,p,q,Rs)`` components"
msgstr ""

#: ../../stdlib/linalg.rst:75
msgid "Supported function"
msgstr ""

#: ../../stdlib/linalg.rst:77
msgid "``/``"
msgstr ""

#: ../../stdlib/linalg.rst:78 ../../stdlib/punctuation.rst:22
msgid "``\\``"
msgstr ""

#: ../../stdlib/linalg.rst:79
msgid "``cond``"
msgstr ""

#: ../../stdlib/linalg.rst:80
msgid "``det``"
msgstr ""

#: ../../stdlib/linalg.rst:81
msgid "``size``"
msgstr ""

#: ../../stdlib/linalg.rst:86
msgid ""
"``lufact!`` is the same as :func:`lufact`, but saves space by overwriting "
"the input A, instead of creating a copy.  For sparse ``A`` the ``nzval`` "
"field is not overwritten but the index fields, ``colptr`` and ``rowval`` are"
" decremented in place, converting from 1-based indices to 0-based indices."
msgstr ""

#: ../../stdlib/linalg.rst:90
msgid ""
"Compute the Cholesky factorization of a symmetric positive definite matrix "
"``A`` and return the matrix ``F``. If ``LU`` is ``:L`` (Lower), ``A = "
"L*L'``. If ``LU`` is ``:U`` (Upper), ``A = R'*R``."
msgstr ""

#: ../../stdlib/linalg.rst:94
msgid ""
"Compute the Cholesky factorization of a dense symmetric positive "
"(semi)definite matrix ``A`` and return either a ``Cholesky`` if "
"``pivot=false`` or ``CholeskyPivoted`` if ``pivot=true``. ``LU`` may be "
"``:L`` for using the lower part or ``:U`` for the upper part. The default is"
" to use ``:U``. The triangular matrix can be obtained from the factorization"
" ``F`` with: ``F[:L]`` and ``F[:U]``. The following functions are available "
"for ``Cholesky`` objects: ``size``, ``\\``, ``inv``, ``det``. For "
"``CholeskyPivoted`` there is also defined a ``rank``. If ``pivot=false`` a "
"``PosDefException`` exception is thrown in case the matrix is not positive "
"definite. The argument ``tol`` determines the tolerance for determining the "
"rank. For negative values, the tolerance is the machine precision."
msgstr ""

#: ../../stdlib/linalg.rst:98
msgid ""
"Compute the sparse Cholesky factorization of a sparse matrix ``A``.  If "
"``A`` is Hermitian its Cholesky factor is determined.  If ``A`` is not "
"Hermitian the Cholesky factor of ``A*A'`` is determined. A fill-reducing "
"permutation is used.  Methods for ``size``, ``solve``, ``\\``, "
"``findn_nzs``, ``diag``, ``det`` and ``logdet`` are available for "
"``CholmodFactor`` objects.  One of the solve methods includes an integer "
"argument that can be used to solve systems involving parts of the "
"factorization only.  The optional boolean argument, ``ll`` determines "
"whether the factorization returned is of the ``A[p,p] = L*L'`` form, where "
"``L`` is lower triangular or ``A[p,p] = L*Diagonal(D)*L'`` form where ``L`` "
"is unit lower triangular and ``D`` is a non-negative vector.  The default is"
" LDL. The symbolic factorization can also be reused for other matrices with "
"the same structure as ``A`` by calling ``cholfact!``."
msgstr ""

#: ../../stdlib/linalg.rst:102
msgid ""
"``cholfact!`` is the same as :func:`cholfact`, but saves space by "
"overwriting the input ``A``, instead of creating a copy. ``cholfact!`` can "
"also reuse the symbolic factorization from a different matrix ``F`` with the"
" same structure when used as: ``cholfact!(F::CholmodFactor, A)``."
msgstr ""

#: ../../stdlib/linalg.rst:106
msgid ""
"Compute a factorization of a positive definite matrix ``A`` such that "
"``A=L*Diagonal(d)*L'`` where ``L`` is a unit lower triangular matrix and "
"``d`` is a vector with non-negative elements."
msgstr ""

#: ../../stdlib/linalg.rst:110
msgid ""
"Compute the (pivoted) QR factorization of ``A`` such that either ``A = Q*R``"
" or ``A[:,p] = Q*R``. Also see ``qrfact``. The default is to compute a thin "
"factorization. Note that ``R`` is not extended with zeros when the full "
"``Q`` is requested."
msgstr ""

#: ../../stdlib/linalg.rst:114
msgid ""
"Computes the QR factorization of ``A``. The return type of ``F`` depends on "
"the element type of ``A`` and whether pivoting is specified (with "
"``pivot=true``)."
msgstr ""

#: ../../stdlib/linalg.rst:117
msgid "Return type"
msgstr ""

#: ../../stdlib/linalg.rst:117
msgid "``eltype(A)``"
msgstr ""

#: ../../stdlib/linalg.rst:117
msgid "``pivot``"
msgstr ""

#: ../../stdlib/linalg.rst:119 ../../stdlib/linalg.rst:129
msgid "``QR``"
msgstr ""

#: ../../stdlib/linalg.rst:119
msgid "not ``BlasFloat``"
msgstr ""

#: ../../stdlib/linalg.rst:119
msgid "either"
msgstr ""

#: ../../stdlib/linalg.rst:119 ../../stdlib/linalg.rst:120
msgid "``A==F[:Q]*F[:R]``"
msgstr ""

#: ../../stdlib/linalg.rst:120 ../../stdlib/linalg.rst:129
msgid "``QRCompactWY``"
msgstr ""

#: ../../stdlib/linalg.rst:120 ../../stdlib/linalg.rst:121
msgid "``BlasFloat``"
msgstr ""

#: ../../stdlib/linalg.rst:120
msgid "``false``"
msgstr ""

#: ../../stdlib/linalg.rst:121 ../../stdlib/linalg.rst:129
msgid "``QRPivoted``"
msgstr ""

#: ../../stdlib/linalg.rst:121
msgid "``true``"
msgstr ""

#: ../../stdlib/linalg.rst:121
msgid "``A[:,F[:p]]==F[:Q]*F[:R]``"
msgstr ""

#: ../../stdlib/linalg.rst:124
msgid ""
"``BlasFloat`` refers to any of: ``Float32``, ``Float64``, ``Complex64`` or "
"``Complex128``."
msgstr ""

#: ../../stdlib/linalg.rst:131
msgid "``F[:Q]``"
msgstr ""

#: ../../stdlib/linalg.rst:131
msgid "``Q`` (orthogonal/unitary) part of ``QR``"
msgstr ""

#: ../../stdlib/linalg.rst:131 ../../stdlib/linalg.rst:131
msgid "✓ (``QRPackedQ``)"
msgstr ""

#: ../../stdlib/linalg.rst:131
msgid "✓ (``QRCompactWYQ``)"
msgstr ""

#: ../../stdlib/linalg.rst:132
msgid "``F[:R]``"
msgstr ""

#: ../../stdlib/linalg.rst:132
msgid "``R`` (upper right triangular) part of ``QR``"
msgstr ""

#: ../../stdlib/linalg.rst:133
msgid "pivot ``Vector``"
msgstr ""

#: ../../stdlib/linalg.rst:134
msgid "(pivot) permutation ``Matrix``"
msgstr ""

#: ../../stdlib/linalg.rst:137
msgid ""
"The following functions are available for the ``QR`` objects: ``size``, "
"``\\``. When ``A`` is rectangular, ``\\`` will return a least squares "
"solution and if the solution is not unique, the one with smallest norm is "
"returned."
msgstr ""

#: ../../stdlib/linalg.rst:139
msgid ""
"Multiplication with respect to either thin or full ``Q`` is allowed, i.e. "
"both ``F[:Q]*F[:R]`` and ``F[:Q]*A`` are supported. A ``Q`` matrix can be "
"converted into a regular matrix with :func:`full` which has a named argument"
" ``thin``."
msgstr ""

#: ../../stdlib/linalg.rst:143
msgid ""
"``qrfact`` returns multiple types because LAPACK uses several "
"representations that minimize the memory storage requirements of products of"
" Householder elementary reflectors, so that the ``Q`` and ``R`` matrices can"
" be stored compactly rather as two separate dense matrices."
msgstr ""

#: ../../stdlib/linalg.rst:145
msgid ""
"The data contained in ``QR`` or ``QRPivoted`` can be used to construct the "
"``QRPackedQ`` type, which is a compact representation of the rotation "
"matrix:"
msgstr ""

#: ../../stdlib/linalg.rst:151
msgid ""
"where :math:`\\tau_i` is the scale factor and :math:`v_i` is the projection "
"vector associated with the :math:`i^{th}` Householder elementary reflector."
msgstr ""

#: ../../stdlib/linalg.rst:153
msgid ""
"The data contained in ``QRCompactWY`` can be used to construct the "
"``QRCompactWYQ`` type, which is a compact representation of the rotation "
"matrix"
msgstr ""

#: ../../stdlib/linalg.rst:159
msgid ""
"where ``Y`` is :math:`m \\times r` lower trapezoidal and ``T`` is :math:`r "
"\\times r` upper triangular. The *compact WY* representation "
"[Schreiber1989]_ is not to be confused with the older, *WY* representation "
"[Bischof1987]_. (The LAPACK documentation uses ``V`` in lieu of ``Y``.)"
msgstr ""

#: ../../stdlib/linalg.rst:161
msgid ""
"C Bischof and C Van Loan, The WY representation for products of Householder "
"matrices, SIAM J Sci Stat Comput 8 (1987), s2-s13. doi:10.1137/0908009"
msgstr ""

#: ../../stdlib/linalg.rst:162
msgid ""
"R Schreiber and C Van Loan, A storage-efficient WY representation for "
"products of Householder transformations, SIAM J Sci Stat Comput 10 (1989), "
"53-57. doi:10.1137/0910005"
msgstr ""

#: ../../stdlib/linalg.rst:166
msgid ""
"``qrfact!`` is the same as :func:`qrfact`, but saves space by overwriting "
"the input ``A``, instead of creating a copy."
msgstr ""

#: ../../stdlib/linalg.rst:170
msgid ""
"Compute the Bunch-Kaufman [Bunch1977]_ factorization of a real symmetric or "
"complex Hermitian matrix ``A`` and return a ``BunchKaufman`` object. The "
"following functions are available for ``BunchKaufman`` objects: ``size``, "
"``\\``, ``inv``, ``issym``, ``ishermitian``."
msgstr ""

#: ../../stdlib/linalg.rst:172
msgid ""
"J R Bunch and L Kaufman, Some stable methods for calculating inertia and "
"solving symmetric linear systems, Mathematics of Computation 31:137 (1977), "
"163-179. `url "
"<http://www.ams.org/journals/mcom/1977-31-137/S0025-5718-1977-0428694-0>`_."
msgstr ""

#: ../../stdlib/linalg.rst:176
msgid ""
"``bkfact!`` is the same as :func:`bkfact`, but saves space by overwriting "
"the input ``A``, instead of creating a copy."
msgstr ""

#: ../../stdlib/linalg.rst:180
msgid ""
"Compute the matrix square root of ``A``. If ``B = sqrtm(A)``, then ``B*B == "
"A`` within roundoff error."
msgstr ""

#: ../../stdlib/linalg.rst:182
msgid ""
"``sqrtm`` uses a polyalgorithm, computing the matrix square root using Schur"
" factorizations (:func:`schurfact`) unless it detects the matrix to be "
"Hermitian or real symmetric, in which case it computes the matrix square "
"root from an eigendecomposition (:func:`eigfact`). In the latter situation "
"for positive definite matrices, the matrix square root has ``Real`` "
"elements, otherwise it has ``Complex`` elements."
msgstr ""

#: ../../stdlib/linalg.rst:186
msgid ""
"Computes eigenvalues and eigenvectors of ``A``. See :func:`eigfact` for "
"details on the ``balance`` keyword argument."
msgstr ""

#: ../../stdlib/linalg.rst:198 ../../stdlib/linalg.rst:206
msgid ""
"``eig`` is a wrapper around :func:`eigfact`, extracting all parts of the "
"factorization to a tuple; where possible, using :func:`eigfact` is "
"recommended."
msgstr ""

#: ../../stdlib/linalg.rst:204
msgid ""
"Computes generalized eigenvalues and vectors of ``A`` with respect to ``B``."
msgstr ""

#: ../../stdlib/linalg.rst:212
msgid ""
"Returns the eigenvalues of ``A``. If ``A`` is :func:`Symmetric`, "
":func:`Hermitian` or :func:`SymTridiagonal`, it is possible to calculate "
"only a subset of the eigenvalues by specifying either a :func:`UnitRange` "
"``irange`` covering indices of the sorted eigenvalues, or a pair ``vl`` and "
"``vu`` for the lower and upper boundaries of the eigenvalues."
msgstr ""

#: ../../stdlib/linalg.rst:218
msgid ""
"For general non-symmetric matrices it is possible to specify how the matrix "
"is balanced before the eigenvector calculation. The option ``permute=true`` "
"permutes the matrix to become closer to upper triangular, and ``scale=true``"
" scales the matrix by its diagonal elements to make rows and columns more "
"equal in norm. The default is ``true`` for both options."
msgstr ""

#: ../../stdlib/linalg.rst:226
msgid "Returns the largest eigenvalue of ``A``."
msgstr ""

#: ../../stdlib/linalg.rst:230
msgid "Returns the smallest eigenvalue of ``A``."
msgstr ""

#: ../../stdlib/linalg.rst:234
msgid ""
"Returns a matrix ``M`` whose columns are the eigenvectors of ``A``. (The "
"``k``th eigenvector can be obtained from the slice ``M[:, k]``.) The "
"``permute`` and ``scale`` keywords are the same as for :func:`eigfact`."
msgstr ""

#: ../../stdlib/linalg.rst:238
msgid ""
"For :func:`SymTridiagonal` matrices, if the optional vector of eigenvalues "
"``eigvals`` is specified, returns the specific corresponding eigenvectors."
msgstr ""

#: ../../stdlib/linalg.rst:243
msgid ""
"Computes the eigenvalue decomposition of ``A``, returning an ``Eigen`` "
"factorization object ``F`` which contains the eigenvalues in ``F[:values]`` "
"and the eigenvectors in the columns of the matrix ``F[:vectors]``. (The "
"``k``th eigenvector can be obtained from the slice ``F[:vectors][:, k]``.)"
msgstr ""

#: ../../stdlib/linalg.rst:248
msgid ""
"The following functions are available for ``Eigen`` objects: ``inv``, "
"``det``."
msgstr ""

#: ../../stdlib/linalg.rst:251
msgid ""
"If ``A`` is :func:`Symmetric`, :func:`Hermitian` or :func:`SymTridiagonal`, "
"it is possible to calculate only a subset of the eigenvalues by specifying "
"either a :func:`UnitRange` ``irange`` covering indices of the sorted "
"eigenvalues or a pair ``vl`` and ``vu`` for the lower and upper boundaries "
"of the eigenvalues."
msgstr ""

#: ../../stdlib/linalg.rst:257
msgid ""
"For general nonsymmetric matrices it is possible to specify how the matrix "
"is balanced before the eigenvector calculation. The option ``permute=true`` "
"permutes the matrix to become closer to upper triangular, and ``scale=true``"
" scales the matrix by its diagonal elements to make rows and columns more "
"equal in norm. The default is ``true`` for both options."
msgstr ""

#: ../../stdlib/linalg.rst:265
msgid ""
"Computes the generalized eigenvalue decomposition of ``A`` and ``B``, "
"returning a ``GeneralizedEigen`` factorization object ``F`` which contains "
"the generalized eigenvalues in ``F[:values]`` and the generalized "
"eigenvectors in the columns of the matrix ``F[:vectors]``. (The ``k``th "
"generalized eigenvector can be obtained from the slice ``F[:vectors][:, "
"k]``.)"
msgstr ""

#: ../../stdlib/linalg.rst:274
msgid ""
"Same as :func:`eigfact`, but saves space by overwriting the input ``A`` (and"
" ``B``), instead of creating a copy."
msgstr ""

#: ../../stdlib/linalg.rst:279
msgid ""
"Compute the Hessenberg decomposition of ``A`` and return a ``Hessenberg`` "
"object. If ``F`` is the factorization object, the unitary matrix can be "
"accessed with ``F[:Q]`` and the Hessenberg matrix with ``F[:H]``. When ``Q``"
" is extracted, the resulting type is the ``HessenbergQ`` object, and may be "
"converted to a regular matrix with :func:`full`."
msgstr ""

#: ../../stdlib/linalg.rst:283
msgid ""
"``hessfact!`` is the same as :func:`hessfact`, but saves space by "
"overwriting the input A, instead of creating a copy."
msgstr ""

#: ../../stdlib/linalg.rst:287
msgid ""
"Computes the Schur factorization of the matrix ``A``. The (quasi) triangular"
" Schur factor can be obtained from the ``Schur`` object ``F`` with either "
"``F[:Schur]`` or ``F[:T]`` and the unitary/orthogonal Schur vectors can be "
"obtained with ``F[:vectors]`` or ``F[:Z]`` such that "
"``A=F[:vectors]*F[:Schur]*F[:vectors]'``. The eigenvalues of ``A`` can be "
"obtained with ``F[:values]``."
msgstr ""

#: ../../stdlib/linalg.rst:291
msgid ""
"Computes the Schur factorization of ``A``, overwriting ``A`` in the process."
" See :func:`schurfact`"
msgstr ""

#: ../../stdlib/linalg.rst:295 ../../stdlib/linalg.rst:319
msgid "See :func:`schurfact`"
msgstr ""

#: ../../stdlib/linalg.rst:299
msgid ""
"Reorders the Schur factorization of a real matrix ``A=Q*T*Q'`` according to "
"the logical array ``select`` returning a Schur object ``F``. The selected "
"eigenvalues appear in the leading diagonal of ``F[:Schur]`` and the the "
"corresponding leading columns of ``F[:vectors]`` form an orthonormal basis "
"of the corresponding right invariant subspace. A complex conjugate pair of "
"eigenvalues must be either both included or excluded via ``select``."
msgstr ""

#: ../../stdlib/linalg.rst:303
msgid ""
"Reorders the Schur factorization of a real matrix ``A=Q*T*Q'``, overwriting "
"``Q`` and ``T`` in the process. See :func:`ordschur`"
msgstr ""

#: ../../stdlib/linalg.rst:307
msgid "Reorders the Schur factorization ``S`` of type ``Schur``."
msgstr ""

#: ../../stdlib/linalg.rst:311
msgid ""
"Reorders the Schur factorization ``S`` of type ``Schur``, overwriting ``S`` "
"in the process. See :func:`ordschur`"
msgstr ""

#: ../../stdlib/linalg.rst:315
msgid ""
"Computes the Generalized Schur (or QZ) factorization of the matrices ``A`` "
"and ``B``. The (quasi) triangular Schur factors can be obtained from the "
"``Schur`` object ``F`` with ``F[:S]`` and ``F[:T]``, the left "
"unitary/orthogonal Schur vectors can be obtained with ``F[:left]`` or "
"``F[:Q]`` and the right unitary/orthogonal Schur vectors can be obtained "
"with ``F[:right]`` or ``F[:Z]`` such that ``A=F[:left]*F[:S]*F[:right]'`` "
"and ``B=F[:left]*F[:T]*F[:right]'``. The generalized eigenvalues of ``A`` "
"and ``B`` can be obtained with ``F[:alpha]./F[:beta]``."
msgstr ""

#: ../../stdlib/linalg.rst:323
msgid ""
"Compute the Singular Value Decomposition (SVD) of ``A`` and return an "
"``SVD`` object. ``U``, ``S``, ``V`` and ``Vt`` can be obtained from the "
"factorization ``F`` with ``F[:U]``, ``F[:S]``, ``F[:V]`` and ``F[:Vt]``, "
"such that ``A = U*diagm(S)*Vt``. If ``thin`` is ``true``, an economy mode "
"decomposition is returned. The algorithm produces ``Vt`` and hence ``Vt`` is"
" more efficient to extract than ``V``. The default is to produce a thin "
"decomposition."
msgstr ""

#: ../../stdlib/linalg.rst:327
msgid ""
"``svdfact!`` is the same as :func:`svdfact`, but saves space by overwriting "
"the input A, instead of creating a copy. If ``thin`` is ``true``, an economy"
" mode decomposition is returned. The default is to produce a thin "
"decomposition."
msgstr ""

#: ../../stdlib/linalg.rst:331
msgid ""
"Wrapper around ``svdfact`` extracting all parts the factorization to a "
"tuple. Direct use of ``svdfact`` is therefore generally more efficient. "
"Computes the SVD of A, returning ``U``, vector ``S``, and ``V`` such that "
"``A == U*diagm(S)*V'``. If ``thin`` is ``true``, an economy mode "
"decomposition is returned. The default is to produce a thin decomposition."
msgstr ""

#: ../../stdlib/linalg.rst:335
msgid "Returns the singular values of ``A``."
msgstr ""

#: ../../stdlib/linalg.rst:339
msgid ""
"Returns the singular values of ``A``, while saving space by overwriting the "
"input."
msgstr ""

#: ../../stdlib/linalg.rst:343
msgid ""
"Compute the generalized SVD of ``A`` and ``B``, returning a "
"``GeneralizedSVD`` Factorization object ``F``, such that ``A = "
"F[:U]*F[:D1]*F[:R0]*F[:Q]'`` and ``B = F[:V]*F[:D2]*F[:R0]*F[:Q]'``."
msgstr ""

#: ../../stdlib/linalg.rst:347
msgid ""
"Wrapper around ``svdfact`` extracting all parts the factorization to a "
"tuple. Direct use of ``svdfact`` is therefore generally more efficient. The "
"function returns the generalized SVD of ``A`` and ``B``, returning ``U``, "
"``V``, ``Q``, ``D1``, ``D2``, and ``R0`` such that ``A = U*D1*R0*Q'`` and "
"``B = V*D2*R0*Q'``."
msgstr ""

#: ../../stdlib/linalg.rst:351
msgid ""
"Return only the singular values from the generalized singular value "
"decomposition of ``A`` and ``B``."
msgstr ""

#: ../../stdlib/linalg.rst:355
msgid "Upper triangle of a matrix."
msgstr ""

#: ../../stdlib/linalg.rst:359
msgid "Upper triangle of a matrix, overwriting ``M`` in the process."
msgstr ""

#: ../../stdlib/linalg.rst:363
msgid "Lower triangle of a matrix."
msgstr ""

#: ../../stdlib/linalg.rst:367
msgid "Lower triangle of a matrix, overwriting ``M`` in the process."
msgstr ""

#: ../../stdlib/linalg.rst:371
msgid ""
"A ``Range`` giving the indices of the ``k``-th diagonal of the matrix ``M``."
msgstr ""

#: ../../stdlib/linalg.rst:375
msgid ""
"The ``k``-th diagonal of a matrix, as a vector. Use ``diagm`` to construct a"
" diagonal matrix."
msgstr ""

#: ../../stdlib/linalg.rst:379
msgid "Construct a diagonal matrix and place ``v`` on the ``k``-th diagonal."
msgstr ""

#: ../../stdlib/linalg.rst:384
msgid "Scale an array ``A`` by a scalar ``b``, returning a new array."
msgstr ""

#: ../../stdlib/linalg.rst:386
msgid ""
"If ``A`` is a matrix and ``b`` is a vector, then ``scale(A,b)`` scales each "
"column ``i`` of ``A`` by ``b[i]`` (similar to ``A*diagm(b)``), while "
"``scale(b,A)`` scales each row ``i`` of ``A`` by ``b[i]`` (similar to "
"``diagm(b)*A``), returning a new array."
msgstr ""

#: ../../stdlib/linalg.rst:391
msgid ""
"Note: for large ``A``, ``scale`` can be much faster than ``A .* b`` or ``b "
".* A``, due to the use of BLAS."
msgstr ""

#: ../../stdlib/linalg.rst:397
msgid ""
"Scale an array ``A`` by a scalar ``b``, similar to :func:`scale` but "
"overwriting ``A`` in-place."
msgstr ""

#: ../../stdlib/linalg.rst:400
msgid ""
"If ``A`` is a matrix and ``b`` is a vector, then ``scale!(A,b)`` scales each"
" column ``i`` of ``A`` by ``b[i]`` (similar to ``A*diagm(b)``), while "
"``scale!(b,A)`` scales each row ``i`` of ``A`` by ``b[i]`` (similar to "
"``diagm(b)*A``), again operating in-place on ``A``."
msgstr ""

#: ../../stdlib/linalg.rst:408
msgid ""
"Construct a tridiagonal matrix from the lower diagonal, diagonal, and upper "
"diagonal, respectively.  The result is of type ``Tridiagonal`` and provides "
"efficient specialized linear solvers, but may be converted into a regular "
"matrix with :func:`full`."
msgstr ""

#: ../../stdlib/linalg.rst:412
msgid ""
"Constructs an upper (``isupper=true``) or lower (``isupper=false``) "
"bidiagonal matrix using the given diagonal (``dv``) and off-diagonal "
"(``ev``) vectors.  The result is of type ``Bidiagonal`` and provides "
"efficient specialized linear solvers, but may be converted into a regular "
"matrix with :func:`full`."
msgstr ""

#: ../../stdlib/linalg.rst:417
msgid ""
"Construct a real symmetric tridiagonal matrix from the diagonal and upper "
"diagonal, respectively. The result is of type ``SymTridiagonal`` and "
"provides efficient specialized eigensolvers, but may be converted into a "
"regular matrix with :func:`full`."
msgstr ""

#: ../../stdlib/linalg.rst:421
msgid ""
"Construct a matrix in a form suitable for applying the Woodbury matrix "
"identity."
msgstr ""

#: ../../stdlib/linalg.rst:425
msgid "Compute the rank of a matrix."
msgstr ""

#: ../../stdlib/linalg.rst:429
msgid ""
"Compute the ``p``-norm of a vector or the operator norm of a matrix ``A``, "
"defaulting to the ``p=2``-norm."
msgstr ""

#: ../../stdlib/linalg.rst:431
msgid ""
"For vectors, ``p`` can assume any numeric value (even though not all values "
"produce a mathematically valid vector norm). In particular, ``norm(A, Inf)``"
" returns the largest value in ``abs(A)``, whereas ``norm(A, -Inf)`` returns "
"the smallest."
msgstr ""

#: ../../stdlib/linalg.rst:433
msgid ""
"For matrices, valid values of ``p`` are ``1``, ``2``, or ``Inf``. (Note that"
" for sparse matrices, ``p=2`` is currently not implemented.) Use "
":func:`vecnorm` to compute the Frobenius norm."
msgstr ""

#: ../../stdlib/linalg.rst:437
msgid ""
"For any iterable container ``A`` (including arrays of any dimension) of "
"numbers, compute the ``p``-norm (defaulting to ``p=2``) as if ``A`` were a "
"vector of the corresponding length."
msgstr ""

#: ../../stdlib/linalg.rst:441
msgid ""
"For example, if ``A`` is a matrix and ``p=2``, then this is equivalent to "
"the Frobenius norm."
msgstr ""

#: ../../stdlib/linalg.rst:446
msgid ""
"Condition number of the matrix ``M``, computed using the operator "
"``p``-norm. Valid values for ``p`` are ``1``, ``2`` (default), or ``Inf``."
msgstr ""

#: ../../stdlib/linalg.rst:454
msgid ""
"Skeel condition number :math:`\\kappa_S` of the matrix ``M``, optionally "
"with respect to the vector ``x``, as computed using the operator ``p``-norm."
" ``p`` is ``Inf`` by default, if not provided. Valid values for ``p`` are "
"``1``, ``2``, or ``Inf``."
msgstr ""

#: ../../stdlib/linalg.rst:456
msgid ""
"This quantity is also known in the literature as the Bauer condition number,"
" relative condition number, or componentwise relative condition number."
msgstr ""

#: ../../stdlib/linalg.rst:460
msgid "Matrix trace"
msgstr ""

#: ../../stdlib/linalg.rst:464
msgid "Matrix determinant"
msgstr ""

#: ../../stdlib/linalg.rst:468
msgid ""
"Log of matrix determinant. Equivalent to ``log(det(M))``, but may provide "
"increased accuracy and/or speed."
msgstr ""

#: ../../stdlib/linalg.rst:472
msgid "Matrix inverse"
msgstr ""

#: ../../stdlib/linalg.rst:476
msgid "Moore-Penrose pseudoinverse"
msgstr ""

#: ../../stdlib/linalg.rst:480
msgid "Basis for nullspace of ``M``."
msgstr ""

#: ../../stdlib/linalg.rst:484
msgid ""
"Construct a matrix by repeating the given matrix ``n`` times in dimension 1 "
"and ``m`` times in dimension 2."
msgstr ""

#: ../../stdlib/linalg.rst:488
msgid ""
"Construct an array by repeating the entries of ``A``. The i-th element of "
"``inner`` specifies the number of times that the individual entries of the "
"i-th dimension of ``A`` should be repeated. The i-th element of ``outer`` "
"specifies the number of times that a slice along the i-th dimension of ``A``"
" should be repeated."
msgstr ""

#: ../../stdlib/linalg.rst:492
msgid "Kronecker tensor product of two vectors or two matrices."
msgstr ""

#: ../../stdlib/linalg.rst:496
msgid ""
"Concatenate matrices block-diagonally. Currently only implemented for sparse"
" matrices."
msgstr ""

#: ../../stdlib/linalg.rst:500
msgid ""
"Linear Regression. Returns ``a`` and ``b`` such that ``a+b*x`` is the "
"closest line to the given points ``(x,y)``. In other words, this function "
"determines parameters ``[a, b]`` that minimize the squared error between "
"``y`` and ``a+b*x``."
msgstr ""

#: ../../stdlib/linalg.rst:502
msgid "**Example**::"
msgstr ""

#: ../../stdlib/linalg.rst:513
msgid "Weighted least-squares linear regression."
msgstr ""

#: ../../stdlib/linalg.rst:517
msgid "Matrix exponential."
msgstr ""

#: ../../stdlib/linalg.rst:521
msgid ""
"Computes the solution ``X`` to the continuous Lyapunov equation ``AX + XA' +"
" C = 0``, where no eigenvalue of ``A`` has a zero real part and no two "
"eigenvalues are negative complex conjugates of each other."
msgstr ""

#: ../../stdlib/linalg.rst:525
msgid ""
"Computes the solution ``X`` to the Sylvester equation ``AX + XB + C = 0``, "
"where ``A``, ``B`` and ``C`` have compatible dimensions and ``A`` and ``-B``"
" have no eigenvalues with equal real part."
msgstr ""

#: ../../stdlib/linalg.rst:529
msgid "Test whether a matrix is symmetric."
msgstr ""

#: ../../stdlib/linalg.rst:533
msgid "Test whether a matrix is positive definite."
msgstr ""

#: ../../stdlib/linalg.rst:537
msgid ""
"Test whether a matrix is positive definite, overwriting ``A`` in the "
"processes."
msgstr ""

#: ../../stdlib/linalg.rst:541
msgid "Test whether a matrix is lower triangular."
msgstr ""

#: ../../stdlib/linalg.rst:545
msgid "Test whether a matrix is upper triangular."
msgstr ""

#: ../../stdlib/linalg.rst:549
msgid "Test whether a matrix is Hermitian."
msgstr ""

#: ../../stdlib/linalg.rst:553
msgid "The transposition operator (``.'``)."
msgstr ""

#: ../../stdlib/linalg.rst:557
msgid ""
"Transpose array ``src`` and store the result in the preallocated array "
"``dest``, which should have a size corresponding to "
"``(size(src,2),size(src,1))``. No in-place transposition is supported and "
"unexpected results will happen if `src` and `dest` have overlapping memory "
"regions."
msgstr ""

#: ../../stdlib/linalg.rst:561
msgid "The conjugate transposition operator (``'``)."
msgstr ""

#: ../../stdlib/linalg.rst:565
msgid ""
"Conjugate transpose array ``src`` and store the result in the preallocated "
"array ``dest``, which should have a size corresponding to "
"``(size(src,2),size(src,1))``. No in-place transposition is supported and "
"unexpected results will happen if `src` and `dest` have overlapping memory "
"regions."
msgstr ""

#: ../../stdlib/linalg.rst:590
msgid ""
"``eigs`` computes eigenvalues ``d`` of ``A`` using Lanczos or Arnoldi "
"iterations for real symmetric or general nonsymmetric matrices respectively."
" If ``B`` is provided, the generalized eigen-problem is solved.  The "
"following keyword arguments are supported:"
msgstr ""

#: ../../stdlib/linalg.rst:570
msgid "``nev``: Number of eigenvalues"
msgstr ""

#: ../../stdlib/linalg.rst:571
msgid ""
"``ncv``: Number of Krylov vectors used in the computation; should satisfy "
"``nev+1 <= ncv <= n`` for real symmetric problems and ``nev+2 <= ncv <= n`` "
"for other problems; default is ``ncv = max(20,2*nev+1)``."
msgstr ""

#: ../../stdlib/linalg.rst:572
msgid "``which``: type of eigenvalues to compute. See the note below."
msgstr ""

#: ../../stdlib/linalg.rst:575
msgid "``which``"
msgstr ""

#: ../../stdlib/linalg.rst:575
msgid "type of eigenvalues"
msgstr ""

#: ../../stdlib/linalg.rst:577
msgid "``:LM``"
msgstr ""

#: ../../stdlib/linalg.rst:577
msgid "eigenvalues of largest magnitude (default)"
msgstr ""

#: ../../stdlib/linalg.rst:578
msgid "``:SM``"
msgstr ""

#: ../../stdlib/linalg.rst:578
msgid "eigenvalues of smallest magnitude"
msgstr ""

#: ../../stdlib/linalg.rst:579
msgid "``:LR``"
msgstr ""

#: ../../stdlib/linalg.rst:579
msgid "eigenvalues of largest real part"
msgstr ""

#: ../../stdlib/linalg.rst:580
msgid "``:SR``"
msgstr ""

#: ../../stdlib/linalg.rst:580
msgid "eigenvalues of smallest real part"
msgstr ""

#: ../../stdlib/linalg.rst:581
msgid "``:LI``"
msgstr ""

#: ../../stdlib/linalg.rst:581
msgid ""
"eigenvalues of largest imaginary part (nonsymmetric or complex ``A`` only)"
msgstr ""

#: ../../stdlib/linalg.rst:582
msgid "``:SI``"
msgstr ""

#: ../../stdlib/linalg.rst:582
msgid ""
"eigenvalues of smallest imaginary part (nonsymmetric or complex ``A`` only)"
msgstr ""

#: ../../stdlib/linalg.rst:583
msgid "``:BE``"
msgstr ""

#: ../../stdlib/linalg.rst:583
msgid ""
"compute half of the eigenvalues from each end of the spectrum, biased in "
"favor of the high end. (real symmetric ``A`` only)"
msgstr ""

#: ../../stdlib/linalg.rst:586
msgid "``tol``: tolerance (:math:`tol \\le 0.0` defaults to ``DLAMCH('EPS')``)"
msgstr ""

#: ../../stdlib/linalg.rst:587
msgid "``maxiter``: Maximum number of iterations (default = 300)"
msgstr ""

#: ../../stdlib/linalg.rst:588
msgid ""
"``sigma``: Specifies the level shift used in inverse iteration. If "
"``nothing`` (default), defaults to ordinary (forward) iterations. Otherwise,"
" find eigenvalues close to ``sigma`` using shift and invert iterations."
msgstr ""

#: ../../stdlib/linalg.rst:589
msgid "``ritzvec``: Returns the Ritz vectors ``v`` (eigenvectors) if ``true``"
msgstr ""

#: ../../stdlib/linalg.rst:590
msgid "``v0``: starting vector from which to start the iterations"
msgstr ""

#: ../../stdlib/linalg.rst:592
msgid ""
"``eigs`` returns the ``nev`` requested eigenvalues in ``d``, the "
"corresponding Ritz vectors ``v`` (only if ``ritzvec=true``), the number of "
"converged eigenvalues ``nconv``, the number of iterations ``niter`` and the "
"number of matrix vector multiplications ``nmult``, as well as the final "
"residual vector ``resid``."
msgstr ""

#: ../../stdlib/linalg.rst:594
msgid ""
"The ``sigma`` and ``which`` keywords interact: the description of "
"eigenvalues searched for by ``which`` do _not_ necessarily refer to the "
"eigenvalues of ``A``, but rather the linear operator constructed by the "
"specification of the iteration mode implied by ``sigma``."
msgstr ""

#: ../../stdlib/linalg.rst:597
msgid "``sigma``"
msgstr ""

#: ../../stdlib/linalg.rst:597
msgid "iteration mode"
msgstr ""

#: ../../stdlib/linalg.rst:597
msgid "``which`` refers to eigenvalues of"
msgstr ""

#: ../../stdlib/linalg.rst:599
msgid "``nothing``"
msgstr ""

#: ../../stdlib/linalg.rst:599
msgid "ordinary (forward)"
msgstr ""

#: ../../stdlib/linalg.rst:599
msgid ":math:`A`"
msgstr ""

#: ../../stdlib/linalg.rst:600
msgid "real or complex"
msgstr ""

#: ../../stdlib/linalg.rst:600
msgid "inverse with level shift ``sigma``"
msgstr ""

#: ../../stdlib/linalg.rst:600
msgid ":math:`(A - \\sigma I )^{-1}`"
msgstr ""

#: ../../stdlib/linalg.rst:605
msgid ""
"``peakflops`` computes the peak flop rate of the computer by using double "
"precision :func:`Base.LinAlg.BLAS.gemm!`. By default, if no arguments are "
"specified, it multiplies a matrix of size ``n x n``, where ``n = 2000``. If "
"the underlying BLAS is using multiple threads, higher flop rates are "
"realized. The number of BLAS threads can be set with "
"``blas_set_num_threads(n)``."
msgstr ""

#: ../../stdlib/linalg.rst:607
msgid ""
"If the keyword argument ``parallel`` is set to ``true``, ``peakflops`` is "
"run in parallel on all the worker processors. The flop rate of the entire "
"parallel computer is returned. When running in parallel, only 1 BLAS thread "
"is used. The argument ``n`` still refers to the size of the problem that is "
"solved on each processor."
msgstr ""

#: ../../stdlib/linalg.rst:610
msgid "BLAS Functions"
msgstr ""

#: ../../stdlib/linalg.rst:614
msgid ""
"This module provides wrappers for some of the BLAS functions for linear "
"algebra.  Those BLAS functions that overwrite one of the input arrays have "
"names ending in ``'!'``."
msgstr ""

#: ../../stdlib/linalg.rst:618
msgid ""
"Usually a function has 4 methods defined, one each for ``Float64``, "
"``Float32``, ``Complex128`` and ``Complex64`` arrays."
msgstr ""

#: ../../stdlib/linalg.rst:625
msgid ""
"Dot product of two vectors consisting of ``n`` elements of array ``X`` with "
"stride ``incx`` and ``n`` elements of array ``Y`` with stride ``incy``."
msgstr ""

#: ../../stdlib/linalg.rst:631
msgid "Dot function for two complex vectors."
msgstr ""

#: ../../stdlib/linalg.rst:635
msgid "Dot function for two complex vectors conjugating the first vector."
msgstr ""

#: ../../stdlib/linalg.rst:639
msgid ""
"Copy ``n`` elements of array ``X`` with stride ``incx`` to array ``Y`` with "
"stride ``incy``.  Returns ``Y``."
msgstr ""

#: ../../stdlib/linalg.rst:644
msgid ""
"2-norm of a vector consisting of ``n`` elements of array ``X`` with stride "
"``incx``."
msgstr ""

#: ../../stdlib/linalg.rst:649
msgid ""
"sum of the absolute values of the first ``n`` elements of array ``X`` with "
"stride ``incx``."
msgstr ""

#: ../../stdlib/linalg.rst:654
msgid "Overwrite ``Y`` with ``a*X + Y``.  Returns ``Y``."
msgstr ""

#: ../../stdlib/linalg.rst:658
msgid "Overwrite ``X`` with ``a*X``.  Returns ``X``."
msgstr ""

#: ../../stdlib/linalg.rst:662
msgid "Returns ``a*X``."
msgstr ""

#: ../../stdlib/linalg.rst:666
msgid ""
"Rank-k update of the symmetric matrix ``C`` as ``alpha*A*A.' + beta*C`` or "
"``alpha*A.'*A + beta*C`` according to whether ``trans`` is 'N' or 'T'.  When"
" ``uplo`` is 'U' the upper triangle of ``C`` is updated ('L' for lower "
"triangle).  Returns ``C``."
msgstr ""

#: ../../stdlib/linalg.rst:673
msgid ""
"Returns either the upper triangle or the lower triangle, according to "
"``uplo`` ('U' or 'L'), of ``alpha*A*A.'`` or ``alpha*A.'*A``, according to "
"``trans`` ('N' or 'T')."
msgstr ""

#: ../../stdlib/linalg.rst:679
msgid ""
"Methods for complex arrays only.  Rank-k update of the Hermitian matrix "
"``C`` as ``alpha*A*A' + beta*C`` or ``alpha*A'*A + beta*C`` according to "
"whether ``trans`` is 'N' or 'T'.  When ``uplo`` is 'U' the upper triangle of"
" ``C`` is updated ('L' for lower triangle). Returns ``C``."
msgstr ""

#: ../../stdlib/linalg.rst:687
msgid ""
"Methods for complex arrays only.  Returns either the upper triangle or the "
"lower triangle, according to ``uplo`` ('U' or 'L'), of ``alpha*A*A'`` or "
"``alpha*A'*A``, according to ``trans`` ('N' or 'T')."
msgstr ""

#: ../../stdlib/linalg.rst:693
msgid ""
"Update vector ``y`` as ``alpha*A*x + beta*y`` or ``alpha*A'*x + beta*y`` "
"according to ``trans`` ('N' or 'T').  The matrix ``A`` is a general band "
"matrix of dimension ``m`` by ``size(A,2)`` with ``kl`` sub-diagonals and "
"``ku`` super-diagonals. Returns the updated ``y``."
msgstr ""

#: ../../stdlib/linalg.rst:701
msgid ""
"Returns ``alpha*A*x`` or ``alpha*A'*x`` according to ``trans`` ('N' or 'T')."
" The matrix ``A`` is a general band matrix of dimension ``m`` by "
"``size(A,2)`` with ``kl`` sub-diagonals and ``ku`` super-diagonals."
msgstr ""

#: ../../stdlib/linalg.rst:708
msgid ""
"Update vector ``y`` as ``alpha*A*x + beta*y`` where ``A`` is a a symmetric "
"band matrix of order ``size(A,2)`` with ``k`` super-diagonals stored in the "
"argument ``A``.  The storage layout for ``A`` is described the reference "
"BLAS module, level-2 BLAS at http://www.netlib.org/lapack/explore-html/."
msgstr ""

#: ../../stdlib/linalg.rst:714
msgid "Returns the updated ``y``."
msgstr ""

#: ../../stdlib/linalg.rst:718
msgid ""
"Returns ``alpha*A*x`` where ``A`` is a symmetric band matrix of order "
"``size(A,2)`` with ``k`` super-diagonals stored in the argument ``A``."
msgstr ""

#: ../../stdlib/linalg.rst:724
msgid ""
"Returns ``A*x`` where ``A`` is a symmetric band matrix of order "
"``size(A,2)`` with ``k`` super-diagonals stored in the argument ``A``."
msgstr ""

#: ../../stdlib/linalg.rst:730
msgid ""
"Update ``C`` as ``alpha*A*B + beta*C`` or the other three variants according"
" to ``tA`` (transpose ``A``) and ``tB``.  Returns the updated ``C``."
msgstr ""

#: ../../stdlib/linalg.rst:736 ../../stdlib/linalg.rst:778
msgid ""
"Returns ``alpha*A*B`` or the other three variants according to ``tA`` "
"(transpose ``A``) and ``tB``."
msgstr ""

#: ../../stdlib/linalg.rst:741
msgid ""
"Returns ``A*B`` or the other three variants according to ``tA`` (transpose "
"``A``) and ``tB``."
msgstr ""

#: ../../stdlib/linalg.rst:746
msgid ""
"Update the vector ``y`` as ``alpha*A*x + beta*y`` or ``alpha*A'x + beta*y`` "
"according to ``tA`` (transpose ``A``). Returns the updated ``y``."
msgstr ""

#: ../../stdlib/linalg.rst:752
msgid ""
"Returns ``alpha*A*x`` or ``alpha*A'x`` according to ``tA`` (transpose "
"``A``)."
msgstr ""

#: ../../stdlib/linalg.rst:757
msgid "Returns ``A*x`` or ``A'x`` according to ``tA`` (transpose ``A``)."
msgstr ""

#: ../../stdlib/linalg.rst:761
msgid ""
"Update ``C`` as ``alpha*A*B + beta*C`` or ``alpha*B*A + beta*C`` according "
"to ``side``. ``A`` is assumed to be symmetric.  Only the ``ul`` triangle of "
"``A`` is used.  Returns the updated ``C``."
msgstr ""

#: ../../stdlib/linalg.rst:767
msgid ""
"Returns ``alpha*A*B`` or ``alpha*B*A`` according to ``side``. ``A`` is "
"assumed to be symmetric.  Only the ``ul`` triangle of ``A`` is used."
msgstr ""

#: ../../stdlib/linalg.rst:773
msgid ""
"Returns ``A*B`` or ``B*A`` according to ``side``.  ``A`` is assumed to be "
"symmetric.  Only the ``ul`` triangle of ``A`` is used."
msgstr ""

#: ../../stdlib/linalg.rst:783
msgid ""
"Update the vector ``y`` as ``alpha*A*x + beta*y``. ``A`` is assumed to be "
"symmetric.  Only the ``ul`` triangle of ``A`` is used. Returns the updated "
"``y``."
msgstr ""

#: ../../stdlib/linalg.rst:789
msgid ""
"Returns ``alpha*A*x``. ``A`` is assumed to be symmetric.  Only the ``ul`` "
"triangle of ``A`` is used."
msgstr ""

#: ../../stdlib/linalg.rst:794
msgid ""
"Returns ``A*x``.  ``A`` is assumed to be symmetric.  Only the ``ul`` "
"triangle of ``A`` is used."
msgstr ""

#: ../../stdlib/linalg.rst:799
msgid ""
"Update ``B`` as ``alpha*A*B`` or one of the other three variants determined "
"by ``side`` (A on left or right) and ``tA`` (transpose A). Only the ``ul`` "
"triangle of ``A`` is used.  ``dA`` indicates if ``A`` is unit-triangular "
"(the diagonal is assumed to be all ones). Returns the updated ``B``."
msgstr ""

#: ../../stdlib/linalg.rst:807
msgid ""
"Returns ``alpha*A*B`` or one of the other three variants determined by "
"``side`` (A on left or right) and ``tA`` (transpose A). Only the ``ul`` "
"triangle of ``A`` is used.  ``dA`` indicates if ``A`` is unit-triangular "
"(the diagonal is assumed to be all ones)."
msgstr ""

#: ../../stdlib/linalg.rst:814
msgid ""
"Overwrite ``B`` with the solution to ``A*X = alpha*B`` or one of the other "
"three variants determined by ``side`` (A on left or right of ``X``) and "
"``tA`` (transpose A). Only the ``ul`` triangle of ``A`` is used.  ``dA`` "
"indicates if ``A`` is unit-triangular (the diagonal is assumed to be all "
"ones).  Returns the updated ``B``."
msgstr ""

#: ../../stdlib/linalg.rst:822
msgid ""
"Returns the solution to ``A*X = alpha*B`` or one of the other three variants"
" determined by ``side`` (A on left or right of ``X``) and ``tA`` (transpose "
"A). Only the ``ul`` triangle of ``A`` is used.  ``dA`` indicates if ``A`` is"
" unit-triangular (the diagonal is assumed to be all ones)."
msgstr ""

#: ../../stdlib/linalg.rst:830
msgid ""
"Update ``b`` as ``alpha*A*b`` or one of the other three variants determined "
"by ``side`` (A on left or right) and ``tA`` (transpose A). Only the ``ul`` "
"triangle of ``A`` is used.  ``dA`` indicates if ``A`` is unit-triangular "
"(the diagonal is assumed to be all ones). Returns the updated ``b``."
msgstr ""

#: ../../stdlib/linalg.rst:838
msgid ""
"Returns ``alpha*A*b`` or one of the other three variants determined by "
"``side`` (A on left or right) and ``tA`` (transpose A). Only the ``ul`` "
"triangle of ``A`` is used.  ``dA`` indicates if ``A`` is unit-triangular "
"(the diagonal is assumed to be all ones)."
msgstr ""

#: ../../stdlib/linalg.rst:845
msgid ""
"Overwrite ``b`` with the solution to ``A*x = b`` or one of the other two "
"variants determined by ``tA`` (transpose A) and ``ul`` (triangle of ``A`` "
"used).  ``dA`` indicates if ``A`` is unit-triangular (the diagonal is "
"assumed to be all ones).  Returns the updated ``b``."
msgstr ""

#: ../../stdlib/linalg.rst:852
msgid ""
"Returns the solution to ``A*x = b`` or one of the other two variants "
"determined by ``tA`` (transpose A) and ``ul`` (triangle of ``A`` is used.) "
"``dA`` indicates if ``A`` is unit-triangular (the diagonal is assumed to be "
"all ones)."
msgstr ""

#: ../../stdlib/linalg.rst:860
msgid "Set the number of threads the BLAS library should use."
msgstr ""

#: ../../stdlib/pkg.rst:4
msgid "Package Manager Functions"
msgstr ""

#: ../../stdlib/pkg.rst:6
msgid ""
"All package manager functions are defined in the ``Pkg`` module. None of the"
" ``Pkg`` module's functions are exported; to use them, you'll need to prefix"
" each function call with an explicit ``Pkg.``, e.g. ``Pkg.status()`` or "
"``Pkg.dir()``."
msgstr ""

#: ../../stdlib/pkg.rst:11
msgid ""
"Returns the absolute path of the package directory. This defaults to "
"``joinpath(homedir(),\".julia\")`` on all platforms (i.e. ``~/.julia`` in "
"UNIX shell syntax). If the ``JULIA_PKGDIR`` environment variable is set, "
"that path is used instead. If ``JULIA_PKGDIR`` is a relative path, it is "
"interpreted relative to whatever the current working directory is."
msgstr ""

#: ../../stdlib/pkg.rst:18
msgid ""
"Equivalent to ``normpath(Pkg.dir(),names...)`` – i.e. it appends path "
"components to the package directory and normalizes the resulting path. In "
"particular, ``Pkg.dir(pkg)`` returns the path to the package ``pkg``."
msgstr ""

#: ../../stdlib/pkg.rst:23
msgid ""
"Initialize ``Pkg.dir()`` as a package directory. This will be done "
"automatically when the ``JULIA_PKGDIR`` is not set and ``Pkg.dir()`` uses "
"its default value. As part of this process, clones a local METADATA git "
"repository from the site and branch specified by its arguments, which are "
"typically not provided.  Explicit (non-default) arguments can be used to "
"support a custom METADATA setup."
msgstr ""

#: ../../stdlib/pkg.rst:30
msgid ""
"Determines an optimal, consistent set of package versions to install or "
"upgrade to. The optimal set of package versions is based on the contents of "
"``Pkg.dir(\"REQUIRE\")`` and the state of installed packages in "
"``Pkg.dir()``, Packages that are no longer required are moved into "
"``Pkg.dir(\".trash\")``."
msgstr ""

#: ../../stdlib/pkg.rst:36
msgid ""
"Opens ``Pkg.dir(\"REQUIRE\")`` in the editor specified by the ``VISUAL`` or "
"``EDITOR`` environment variables; when the editor command returns, it runs "
"``Pkg.resolve()`` to determine and install a new optimal set of installed "
"package versions."
msgstr ""

#: ../../stdlib/pkg.rst:41
msgid ""
"Add a requirement entry for ``pkg`` to ``Pkg.dir(\"REQUIRE\")`` and call "
"``Pkg.resolve()``. If ``vers`` are given, they must be ``VersionNumber`` "
"objects and they specify acceptable version intervals for ``pkg``."
msgstr ""

#: ../../stdlib/pkg.rst:46
msgid ""
"Remove all requirement entries for ``pkg`` from ``Pkg.dir(\"REQUIRE\")`` and"
" call ``Pkg.resolve()``."
msgstr ""

#: ../../stdlib/pkg.rst:50
msgid ""
"Clone a package directly from the git URL ``url``. The package does not need"
" to be a registered in ``Pkg.dir(\"METADATA\")``. The package repo is cloned"
" by the name ``pkg`` if provided; if not provided, ``pkg`` is determined "
"automatically from ``url``."
msgstr ""

#: ../../stdlib/pkg.rst:57
msgid ""
"If ``pkg`` has a URL registered in ``Pkg.dir(\"METADATA\")``, clone it from "
"that URL on the default branch. The package does not need to have any "
"registered versions."
msgstr ""

#: ../../stdlib/pkg.rst:62
msgid "Returns the names of available packages."
msgstr ""

#: ../../stdlib/pkg.rst:66
msgid "Returns the version numbers available for package ``pkg``."
msgstr ""

#: ../../stdlib/pkg.rst:70
msgid ""
"Returns a dictionary mapping installed package names to the installed "
"version number of each package."
msgstr ""

#: ../../stdlib/pkg.rst:74
msgid ""
"If ``pkg`` is installed, return the installed version number, otherwise "
"return ``nothing``."
msgstr ""

#: ../../stdlib/pkg.rst:78
msgid ""
"Prints out a summary of what packages are installed and what version and "
"state they're in."
msgstr ""

#: ../../stdlib/pkg.rst:82
msgid ""
"Update package the metadata repo – kept in ``Pkg.dir(\"METADATA\")`` – then "
"update any fixed packages that can safely be pulled from their origin; then "
"call ``Pkg.resolve()`` to determine a new optimal set of packages versions."
msgstr ""

#: ../../stdlib/pkg.rst:87
msgid ""
"Checkout the ``Pkg.dir(pkg)`` repo to the branch ``branch``. Defaults to "
"checking out the \"master\" branch. To go back to using the newest "
"compatible released version, use ``Pkg.free(pkg)``"
msgstr ""

#: ../../stdlib/pkg.rst:93
msgid ""
"Pin ``pkg`` at the current version. To go back to using the newest "
"compatible released version, use ``Pkg.free(pkg)``"
msgstr ""

#: ../../stdlib/pkg.rst:98
msgid "Pin ``pkg`` at registered version ``version``."
msgstr ""

#: ../../stdlib/pkg.rst:102
msgid ""
"Free the package ``pkg`` to be managed by the package manager again. It "
"calls ``Pkg.resolve()`` to determine optimal package versions after. This is"
" an inverse for both ``Pkg.checkout`` and ``Pkg.pin``."
msgstr ""

#: ../../stdlib/pkg.rst:108
msgid ""
"Run the build scripts for all installed packages in depth-first recursive "
"order."
msgstr ""

#: ../../stdlib/pkg.rst:112
msgid ""
"Run the build script in \"deps/build.jl\" for each package in ``pkgs`` and "
"all of their dependencies in depth-first recursive order. This is called "
"automatically by ``Pkg.resolve()`` on all installed or updated packages."
msgstr ""

#: ../../stdlib/pkg.rst:117
msgid ""
"Generate a new package named ``pkg`` with one of these license keys: "
"``\"MIT\"`` or ``\"BSD\"``. If you want to make a package with a different "
"license, you can edit it afterwards. Generate creates a git repo at "
"``Pkg.dir(pkg)`` for the package and inside it ``LICENSE.md``, "
"``README.md``, the julia entrypoint ``$pkg/src/$pkg.jl``, and a travis test "
"file, ``.travis.yml``."
msgstr ""

#: ../../stdlib/pkg.rst:123
msgid ""
"Register ``pkg`` at the git URL ``url``, defaulting to the configured origin"
" URL of the git repo ``Pkg.dir(pkg)``."
msgstr ""

#: ../../stdlib/pkg.rst:127
msgid ""
"Tag ``commit`` as version ``ver`` of package ``pkg`` and create a version "
"entry in ``METADATA``. If not provided, ``commit`` defaults to the current "
"commit of the ``pkg`` repo. If ``ver`` is one of the symbols ``:patch``, "
"``:minor``, ``:major`` the next patch, minor or major version is used. If "
"``ver`` is not provided, it defaults to ``:patch``."
msgstr ""

#: ../../stdlib/pkg.rst:134
msgid ""
"For each new package version tagged in ``METADATA`` not already published, "
"make sure that the tagged package commits have been pushed to the repo at "
"the registered URL for the package and if they all have, open a pull request"
" to ``METADATA``."
msgstr ""

#: ../../stdlib/pkg.rst:138
msgid ""
"Run the tests for all installed packages ensuring that each package's test "
"dependencies are installed for the duration of the test. A package is tested"
" by running its ``test/runtests.jl`` file and test dependencies are "
"specified in ``test/REQUIRE``."
msgstr ""

#: ../../stdlib/pkg.rst:142
msgid ""
"Run the tests for each package in ``pkgs`` ensuring that each package's test"
" dependencies are installed for the duration of the test. A package is "
"tested by running its ``test/runtests.jl`` file and test dependencies are "
"specified in ``test/REQUIRE``."
msgstr ""

#: ../../stdlib/profile.rst:6
msgid "Profiling"
msgstr ""

#: ../../stdlib/profile.rst:8
msgid ""
"The ``Profile`` module provides tools to help developers improve the "
"performance of their code. When used, it takes measurements on running code,"
" and produces output that helps you understand how much time is spent on "
"individual line(s).  The most common usage is to identify \"bottlenecks\" as"
" targets for optimization."
msgstr ""

#: ../../stdlib/profile.rst:14
msgid ""
"``Profile`` implements what is known as a \"sampling\" or `statistical "
"profiler <http://en.wikipedia.org/wiki/Profiling_(computer_programming)>`_."
"  It works by periodically taking a backtrace during the execution of any "
"task. Each backtrace captures the currently-running function and line "
"number, plus the complete chain of function calls that led to this line, and"
" hence is a \"snapshot\" of the current state of execution."
msgstr ""

#: ../../stdlib/profile.rst:23
msgid ""
"If much of your run time is spent executing a particular line of code, this "
"line will show up frequently in the set of all backtraces.  In other words, "
"the \"cost\" of a given line---or really, the cost of the sequence of "
"function calls up to and including this line---is proportional to how often "
"it appears in the set of all backtraces."
msgstr ""

#: ../../stdlib/profile.rst:29
msgid ""
"A sampling profiler does not provide complete line-by-line coverage, because"
" the backtraces occur at intervals (by default, 1 ms on Unix systems and 10 "
"ms on Windows, although the actual scheduling is subject to operating system"
" load). Moreover, as discussed further below, because samples are collected "
"at a sparse subset of all execution points, the data collected by a sampling"
" profiler is subject to statistical noise."
msgstr ""

#: ../../stdlib/profile.rst:37
msgid ""
"Despite these limitations, sampling profilers have substantial strengths:"
msgstr ""

#: ../../stdlib/profile.rst:39
msgid ""
"You do not have to make any modifications to your code to take timing "
"measurements (in contrast to the alternative `instrumenting profiler "
"<https://github.com/timholy/IProfile.jl>`_)."
msgstr ""

#: ../../stdlib/profile.rst:42
msgid ""
"It can profile into Julia's core code and even (optionally) into C and "
"Fortran libraries."
msgstr ""

#: ../../stdlib/profile.rst:44
msgid ""
"By running \"infrequently\" there is very little performance overhead; while"
" profiling, your code can run at nearly native speed."
msgstr ""

#: ../../stdlib/profile.rst:47
msgid ""
"For these reasons, it's recommended that you try using the built-in sampling"
" profiler before considering any alternatives."
msgstr ""

#: ../../stdlib/profile.rst:51
msgid "Basic usage"
msgstr ""

#: ../../stdlib/profile.rst:53
msgid "Let's work with a simple test case::"
msgstr ""

#: ../../stdlib/profile.rst:60
msgid ""
"It's a good idea to first run the code you intend to profile at least once "
"(unless you want to profile Julia's JIT-compiler)::"
msgstr ""

#: ../../stdlib/profile.rst:65
msgid "Now we're ready to profile this function::"
msgstr ""

#: ../../stdlib/profile.rst:69
msgid ""
"To see the profiling results, there is a `graphical browser "
"<https://github.com/timholy/ProfileView.jl>`_ available, but here we'll use "
"the text-based display that comes with the standard library::"
msgstr ""

#: ../../stdlib/profile.rst:85
msgid ""
"Each line of this display represents a particular spot (line number) in the "
"code.  Indentation is used to indicate the nested sequence of function "
"calls, with more-indented lines being deeper in the sequence of calls.  In "
"each line, the first \"field\" indicates the number of backtraces (samples) "
"taken *at this line or in any functions executed by this line*. The second "
"field is the file name, followed by a semicolon; the third is the function "
"name followed by a semicolon, and the fourth is the line number.  Note that "
"the specific line numbers may change as Julia's code changes; if you want to"
" follow along, it's best to run this example yourself."
msgstr ""

#: ../../stdlib/profile.rst:96
msgid ""
"In this example, we can see that the top level is ``client.jl``'s ``_start``"
" function. This is the first Julia function that gets called when you launch"
" julia.  If you examine line 373 of ``client.jl``, you'll see that (at the "
"time of this writing) it calls ``run_repl``, mentioned on the second line. "
"This in turn calls ``eval_user_input``. These are the functions in "
"``client.jl`` that interpret what you type at the REPL, and since we're "
"working interactively these functions were invoked when we entered "
"``@profile myfunc()``.  The next line reflects actions taken in the "
"``@profile`` macro."
msgstr ""

#: ../../stdlib/profile.rst:106
msgid ""
"The first line shows that 23 backtraces were taken at line 373 of "
"``client.jl``, but it's not that this line was \"expensive\" on its own: the"
" second line reveals that all 23 of these backtraces were actually triggered"
" inside its call to ``run_repl``, and so on. To find out which operations "
"are actually taking the time, we need to look deeper in the call chain."
msgstr ""

#: ../../stdlib/profile.rst:113
msgid "The first \"important\" line in this output is this one::"
msgstr ""

#: ../../stdlib/profile.rst:117
msgid ""
"``none`` refers to the fact that we defined ``myfunc`` in the REPL, rather "
"than putting it in a file; if we had used a file, this would show the file "
"name. Line 2 of ``myfunc()`` contains the call to ``rand``, and there were 8"
" (out of 23) backtraces that occurred at this line. Below that, you can see "
"a call to ``dsfmt_gv_fill_array_close_open!`` inside ``dSFMT.jl``. You might"
" be surprised not to see the ``rand`` function listed explicitly: that's "
"because ``rand`` is *inlined*, and hence doesn't appear in the backtraces."
msgstr ""

#: ../../stdlib/profile.rst:126
msgid "A little further down, you see::"
msgstr ""

#: ../../stdlib/profile.rst:130
msgid ""
"Line 3 of ``myfunc`` contains the call to ``max``, and there were 15 (out of"
" 23) backtraces taken here. Below that, you can see the specific places in "
"``base/reduce.jl`` that carry out the time-consuming operations in the "
"``max`` function for this type of input data."
msgstr ""

#: ../../stdlib/profile.rst:136
msgid ""
"Overall, we can tentatively conclude that finding the maximum element is "
"approximately twice as expensive as generating the random numbers. We could "
"increase our confidence in this result by collecting more samples::"
msgstr ""

#: ../../stdlib/profile.rst:155
msgid ""
"In general, if you have ``N`` samples collected at a line, you can expect an"
" uncertainty on the order of ``sqrt(N)`` (barring other sources of noise, "
"like how busy the computer is with other tasks). The major exception to this"
" rule is garbage-collection, which runs infrequently but tends to be quite "
"expensive. (Since julia's garbage collector is written in C, such events can"
" be detected using the ``C=true`` output mode described below, or by using "
"`ProfileView <https://github.com/timholy/ProfileView.jl>`_.)"
msgstr ""

#: ../../stdlib/profile.rst:164
msgid ""
"This illustrates the default \"tree\" dump; an alternative is the \"flat\" "
"dump, which accumulates counts independent of their nesting::"
msgstr ""

#: ../../stdlib/profile.rst:180
msgid ""
"If your code has recursion, one potentially-confusing point is that a line "
"in a \"child\" function can accumulate more counts than there are total "
"backtraces. Consider the following function definitions::"
msgstr ""

#: ../../stdlib/profile.rst:187
msgid ""
"If you were to profile ``dumbsum3``, and a backtrace was taken while it was "
"executing ``dumbsum(1)``, the backtrace would look like this::"
msgstr ""

#: ../../stdlib/profile.rst:194
msgid ""
"Consequently, this child function gets 3 counts, even though the parent only"
" gets one.  The \"tree\" representation makes this much clearer, and for "
"this reason (among others) is probably the most useful way to view the "
"results."
msgstr ""

#: ../../stdlib/profile.rst:200
msgid "Accumulation and clearing"
msgstr ""

#: ../../stdlib/profile.rst:202
msgid ""
"Results from ``@profile`` accumulate in a buffer; if you run multiple pieces"
" of code under ``@profile``, then ``Profile.print()`` will show you the "
"combined results. This can be very useful, but sometimes you want to start "
"fresh; you can do so with ``Profile.clear()``."
msgstr ""

#: ../../stdlib/profile.rst:209
msgid "Options for controlling the display of profile results"
msgstr ""

#: ../../stdlib/profile.rst:211
msgid ""
"``Profile.print()`` has more options than we've described so far. Let's see "
"the full declaration::"
msgstr ""

#: ../../stdlib/profile.rst:216
msgid "Let's discuss these arguments in order:"
msgstr ""

#: ../../stdlib/profile.rst:218
msgid ""
"The first argument allows you to save the results to a file, but the default"
" is to print to ``STDOUT`` (the console)."
msgstr ""

#: ../../stdlib/profile.rst:220
msgid ""
"The second argument contains the data you want to analyze; by default that "
"is obtained from ``Profile.fetch()``, which pulls out the backtraces from a "
"pre-allocated buffer. For example, if you want to profile the profiler, you "
"could say::"
msgstr ""

#: ../../stdlib/profile.rst:230
msgid ""
"The first keyword argument, ``format``, was introduced above. The possible "
"choices are ``:tree`` and ``:flat``."
msgstr ""

#: ../../stdlib/profile.rst:232
msgid ""
"``C``, if set to ``true``, allows you to see even the calls to C code.  Try "
"running the introductory example with ``Profile.print(C = true)``. This can "
"be extremely helpful in deciding whether it's Julia code or C code that is "
"causing a bottleneck; setting ``C=true`` also improves the interpretability "
"of the nesting, at the cost of longer profile dumps."
msgstr ""

#: ../../stdlib/profile.rst:238
msgid ""
"Some lines of code contain multiple operations; for example, ``s += A[i]`` "
"contains both an array reference (``A[i]``) and a sum operation.  These "
"correspond to different lines in the generated machine code, and hence there"
" may be two or more different addresses captured during backtraces on this "
"line.  ``combine=true`` lumps them together, and is probably what you "
"typically want, but you can generate an output separately for each unique "
"instruction pointer with ``combine=false``."
msgstr ""

#: ../../stdlib/profile.rst:246
msgid ""
"``cols`` allows you to control the number of columns that you are willing to"
" use for display.  When the text would be wider than the display, you might "
"see output like this::"
msgstr ""

#: ../../stdlib/profile.rst:259
msgid ""
"File/function names are sometimes truncated (with ``...``), and indentation "
"is truncated with a ``+n`` at the beginning, where ``n`` is the number of "
"extra spaces that would have been inserted, had there been room. If you want"
" a complete profile of deeply-nested code, often a good idea is to save to a"
" file and use a very wide ``cols`` setting::"
msgstr ""

#: ../../stdlib/profile.rst:272
msgid "Configuration"
msgstr ""

#: ../../stdlib/profile.rst:274
msgid ""
"``@profile`` just accumulates backtraces, and the analysis happens when you "
"call ``Profile.print()``. For a long-running computation, it's entirely "
"possible that the pre-allocated buffer for storing backtraces will be "
"filled. If that happens, the backtraces stop but your computation continues."
" As a consequence, you may miss some important profiling data (you will get "
"a warning when that happens)."
msgstr ""

#: ../../stdlib/profile.rst:281
msgid "You can obtain and configure the relevant parameters this way::"
msgstr ""

#: ../../stdlib/profile.rst:287
msgid ""
"``n`` is the total number of instruction pointers you can store, with a "
"default value of ``10^6``. If your typical backtrace is 20 instruction "
"pointers, then you can collect 50000 backtraces, which suggests a "
"statistical uncertainty of less than 1%. This may be good enough for most "
"applications."
msgstr ""

#: ../../stdlib/profile.rst:293
msgid ""
"Consequently, you are more likely to need to modify ``delay``, expressed in "
"seconds, which sets the amount of time that Julia gets between snapshots to "
"perform the requested computations. A very long-running job might not need "
"frequent backtraces. The default setting is ``delay = 0.001``.  Of course, "
"you can decrease the delay as well as increase it; however, the overhead of "
"profiling grows once the delay becomes similar to the amount of time needed "
"to take a backtrace (~30 microseconds on the author's laptop)."
msgstr ""

#: ../../stdlib/profile.rst:305
msgid "Direct analysis of memory allocation"
msgstr ""

#: ../../stdlib/profile.rst:307
msgid ""
"One of the most common techniques to improve performance is to reduce memory"
" allocation.  The total amount of allocation can be measured with ``@time`` "
"and ``@allocated``, and specific lines triggering allocation can often be "
"inferred from profiling via the cost of garbage collection that these lines "
"incur.  However, sometimes it is more efficient to directly measure the "
"amount of memory allocated by each line of code."
msgstr ""

#: ../../stdlib/profile.rst:315
msgid ""
"To measure allocation line-by-line, start julia with the ``--track-"
"allocation=<setting>`` command-line option, for which you can choose "
"``none`` (the default, do not measure allocation), ``user`` (measure memory "
"allocation everywhere except julia's core code), or ``all`` (measure memory "
"allocation at each line of julia code). Allocation gets measured for each "
"line of compiled code.  When you quit julia, the cumulative results are "
"written to text files with ``.mem`` appended after the file name, residing "
"in the same directory as the source file.  Each line lists the total number "
"of bytes allocated. The ``Coverage`` package contains some elementary "
"analysis tools, for example to sort the lines in order of number of bytes "
"allocated."
msgstr ""

#: ../../stdlib/profile.rst:327
msgid ""
"In interpreting the results, there are a few important details.  Under the "
"``user`` setting, the first line of any function directly called from the "
"REPL will exhibit allocation due to events that happen in the REPL code "
"itself.  More significantly, JIT-compilation also adds to allocation counts,"
" because much of julia's compiler is written in Julia (and compilation "
"usually requires memory allocation).  The recommended procedure it to force "
"compilation by executing all the commands you want to analyze, then call "
"``clear_malloc_data()`` to reset all allocation counters.  Finally, execute "
"the desired commands and quit julia to trigger the generation of the "
"``.mem`` files."
msgstr ""

#: ../../stdlib/profile.rst:339
msgid "Function reference"
msgstr ""

#: ../../stdlib/profile.rst:345
msgid ""
"``@profile <expression>`` runs your expression while taking periodic "
"backtraces.  These are appended to an internal buffer of backtraces."
msgstr ""

#: ../../stdlib/profile.rst:353
msgid "Clear any existing backtraces from the internal buffer."
msgstr ""

#: ../../stdlib/profile.rst:357
msgid ""
"Prints profiling results to ``io`` (by default, ``STDOUT``). If you do not "
"supply a ``data`` vector, the internal buffer of accumulated backtraces will"
" be used.  ``format`` can be ``:tree`` or ``:flat``. If ``C==true``, "
"backtraces from C and Fortran code are shown. ``combine==true`` merges "
"instruction pointers that correspond to the same line of code.  ``cols`` "
"controls the width of the display."
msgstr ""

#: ../../stdlib/profile.rst:367
msgid ""
"Prints profiling results to ``io``. This variant is used to examine results "
"exported by a previous call to ``Profile.retrieve()``. Supply the vector "
"``data`` of backtraces and a dictionary ``lidict`` of line information."
msgstr ""

#: ../../stdlib/profile.rst:374
msgid ""
"Configure the ``delay`` between backtraces (measured in seconds), and the "
"number ``n`` of instruction pointers that may be stored. Each instruction "
"pointer corresponds to a single line of code; backtraces generally consist "
"of a long list of instruction pointers. Default settings can be obtained by "
"calling this function with no arguments, and each can be set independently "
"using keywords or in the order ``(n, delay)``."
msgstr ""

#: ../../stdlib/profile.rst:384
msgid ""
"Returns a reference to the internal buffer of backtraces. Note that "
"subsequent operations, like ``Profile.clear()``, can affect ``data`` unless "
"you first make a copy. Note that the values in ``data`` have meaning only on"
" this machine in the current session, because it depends on the exact memory"
" addresses used in JIT-compiling. This function is primarily for internal "
"use; ``Profile.retrieve()`` may be a better choice for most users."
msgstr ""

#: ../../stdlib/profile.rst:394
msgid ""
"\"Exports\" profiling results in a portable format, returning the set of all"
" backtraces (``data``) and a dictionary that maps the (session-specific) "
"instruction pointers in ``data`` to ``LineInfo`` values that store the file "
"name, function name, and line number. This function allows you to save "
"profiling results for future analysis."
msgstr ""

#: ../../stdlib/profile.rst:414
msgid ""
"Clears any stored memory allocation data when running julia with ``--track-"
"allocation``.  Execute the command(s) you want to test (to force JIT-"
"compilation), then call ``clear_malloc_data()``. Then execute your "
"command(s) again, quit julia, and examine the resulting ``*.mem`` files."
msgstr ""

#: ../../stdlib/punctuation.rst:2
msgid "Punctuation"
msgstr ""

#: ../../stdlib/punctuation.rst:4
msgid ""
"Extended documentation for mathematical symbols & functions is :ref:`here "
"<mathematical-operators>`."
msgstr ""

#: ../../stdlib/punctuation.rst:7
msgid "symbol"
msgstr ""

#: ../../stdlib/punctuation.rst:7
msgid "meaning"
msgstr ""

#: ../../stdlib/punctuation.rst:9
msgid "``@m``"
msgstr ""

#: ../../stdlib/punctuation.rst:9
msgid "invoke macro m; followed by space-separated expressions"
msgstr ""

#: ../../stdlib/punctuation.rst:10
msgid "``!``"
msgstr ""

#: ../../stdlib/punctuation.rst:10
msgid "prefix \"not\" operator"
msgstr ""

#: ../../stdlib/punctuation.rst:11
msgid "``a!( )``"
msgstr ""

#: ../../stdlib/punctuation.rst:11
msgid ""
"at the end of a function name, `!` indicates that a function modifies its "
"argument(s)"
msgstr ""

#: ../../stdlib/punctuation.rst:12
msgid "``#``"
msgstr ""

#: ../../stdlib/punctuation.rst:12
msgid "begin single line comment"
msgstr ""

#: ../../stdlib/punctuation.rst:13
msgid "``#=``"
msgstr ""

#: ../../stdlib/punctuation.rst:13
msgid "begin multi-line comment (these are nestable)"
msgstr ""

#: ../../stdlib/punctuation.rst:14
msgid "``=#``"
msgstr ""

#: ../../stdlib/punctuation.rst:14
msgid "end multi-line comment"
msgstr ""

#: ../../stdlib/punctuation.rst:15
msgid "``$``"
msgstr ""

#: ../../stdlib/punctuation.rst:15
msgid "xor operator, string and expression interpolation"
msgstr ""

#: ../../stdlib/punctuation.rst:16
msgid "``%``"
msgstr ""

#: ../../stdlib/punctuation.rst:16
msgid "remainder operator"
msgstr ""

#: ../../stdlib/punctuation.rst:17
msgid "``^``"
msgstr ""

#: ../../stdlib/punctuation.rst:17
msgid "exponent operator"
msgstr ""

#: ../../stdlib/punctuation.rst:18
msgid "``&``"
msgstr ""

#: ../../stdlib/punctuation.rst:18
msgid "bitwise and"
msgstr ""

#: ../../stdlib/punctuation.rst:19
msgid "``*``"
msgstr ""

#: ../../stdlib/punctuation.rst:19
msgid "multiply, or matrix multiply"
msgstr ""

#: ../../stdlib/punctuation.rst:20
msgid "``()``"
msgstr ""

#: ../../stdlib/punctuation.rst:20
msgid "the empty tuple"
msgstr ""

#: ../../stdlib/punctuation.rst:21
msgid "``~``"
msgstr ""

#: ../../stdlib/punctuation.rst:21
msgid "bitwise not operator"
msgstr ""

#: ../../stdlib/punctuation.rst:22
msgid "backslash operator"
msgstr ""

#: ../../stdlib/punctuation.rst:23
msgid "``'``"
msgstr ""

#: ../../stdlib/punctuation.rst:23
msgid "complex transpose operator A\\ :sup:`H`"
msgstr ""

#: ../../stdlib/punctuation.rst:24
msgid "``a[]``"
msgstr ""

#: ../../stdlib/punctuation.rst:24
msgid "array indexing"
msgstr ""

#: ../../stdlib/punctuation.rst:25
msgid "``[,]``"
msgstr ""

#: ../../stdlib/punctuation.rst:25
msgid "vertical concatenation"
msgstr ""

#: ../../stdlib/punctuation.rst:26
msgid "``[;]``"
msgstr ""

#: ../../stdlib/punctuation.rst:26
msgid "also vertical concatenation"
msgstr ""

#: ../../stdlib/punctuation.rst:27
msgid "``[  ]``"
msgstr ""

#: ../../stdlib/punctuation.rst:27
msgid "with space-separated expressions, horizontal concatenation"
msgstr ""

#: ../../stdlib/punctuation.rst:28
msgid "``T{ }``"
msgstr ""

#: ../../stdlib/punctuation.rst:28
msgid "parametric type instantiation"
msgstr ""

#: ../../stdlib/punctuation.rst:29
msgid "``{  }``"
msgstr ""

#: ../../stdlib/punctuation.rst:29
msgid "construct a cell array"
msgstr ""

#: ../../stdlib/punctuation.rst:30
msgid "``;``"
msgstr ""

#: ../../stdlib/punctuation.rst:30
msgid "statement separator"
msgstr ""

#: ../../stdlib/punctuation.rst:31
msgid "``,``"
msgstr ""

#: ../../stdlib/punctuation.rst:31
msgid "separate function arguments or tuple components"
msgstr ""

#: ../../stdlib/punctuation.rst:32
msgid "``?``"
msgstr ""

#: ../../stdlib/punctuation.rst:32
msgid "3-argument conditional operator (conditional ? if_true : if_false)"
msgstr ""

#: ../../stdlib/punctuation.rst:33
msgid "``\"\"``"
msgstr ""

#: ../../stdlib/punctuation.rst:33
msgid "delimit string literals"
msgstr ""

#: ../../stdlib/punctuation.rst:34
msgid "``''``"
msgstr ""

#: ../../stdlib/punctuation.rst:34
msgid "delimit character literals"
msgstr ""

#: ../../stdlib/punctuation.rst:35
msgid "`\\`\\``"
msgstr ""

#: ../../stdlib/punctuation.rst:35
msgid "delimit external process (command) specifications"
msgstr ""

#: ../../stdlib/punctuation.rst:36
msgid "``...``"
msgstr ""

#: ../../stdlib/punctuation.rst:36
msgid ""
"splice arguments into a function call or declare a varargs function or type"
msgstr ""

#: ../../stdlib/punctuation.rst:37
msgid "``.``"
msgstr ""

#: ../../stdlib/punctuation.rst:37
msgid ""
"access named fields in objects or names inside modules, also prefixes "
"elementwise operators"
msgstr ""

#: ../../stdlib/punctuation.rst:38
msgid "``a:b``"
msgstr ""

#: ../../stdlib/punctuation.rst:38
msgid "range a, a+1, a+2, ..., b"
msgstr ""

#: ../../stdlib/punctuation.rst:39
msgid "``a:s:b``"
msgstr ""

#: ../../stdlib/punctuation.rst:39
msgid "range a, a+s, a+2s, ..., b"
msgstr ""

#: ../../stdlib/punctuation.rst:40
msgid "``:``"
msgstr ""

#: ../../stdlib/punctuation.rst:40
msgid "index an entire dimension (1:end)"
msgstr ""

#: ../../stdlib/punctuation.rst:41
msgid "``::``"
msgstr ""

#: ../../stdlib/punctuation.rst:41
msgid "type annotation, depending on context"
msgstr ""

#: ../../stdlib/punctuation.rst:42
msgid "``:( )``"
msgstr ""

#: ../../stdlib/punctuation.rst:42
msgid "quoted expression"
msgstr ""

#: ../../stdlib/punctuation.rst:43
msgid "``:a``"
msgstr ""

#: ../../stdlib/punctuation.rst:43
msgid "symbol a"
msgstr ""

#: ../../stdlib/sort.rst:5
msgid "Sorting and Related Functions"
msgstr ""

#: ../../stdlib/sort.rst:7
msgid ""
"Julia has an extensive, flexible API for sorting and interacting with "
"already-sorted arrays of values. By default, Julia picks reasonable "
"algorithms and sorts in standard ascending order:"
msgstr ""

#: ../../stdlib/sort.rst:19
msgid "You can easily sort in reverse order as well:"
msgstr ""

#: ../../stdlib/sort.rst:29
msgid "To sort an array in-place, use the \"bang\" version of the sort function:"
msgstr ""

#: ../../stdlib/sort.rst:43
msgid ""
"Instead of directly sorting an array, you can compute a permutation of the "
"array's indices that puts the array into sorted order:"
msgstr ""

#: ../../stdlib/sort.rst:75
msgid ""
"Arrays can easily be sorted according to an arbitrary transformation of "
"their values:"
msgstr ""

#: ../../stdlib/sort.rst:87
msgid "Or in reverse order by a transformation:"
msgstr ""

#: ../../stdlib/sort.rst:99
msgid "If needed, the sorting algorithm can be chosen:"
msgstr ""

#: ../../stdlib/sort.rst:111
msgid ""
"All the sorting and order related functions rely on a \"less than\" relation"
" defining a total order on the values to be manipulated. The ``isless`` "
"function is invoked by default, but the relation can be specified via the "
"``lt`` keyword."
msgstr ""

#: ../../stdlib/sort.rst:117
msgid "Sorting Functions"
msgstr ""

#: ../../stdlib/sort.rst:121
msgid ""
"Sort the vector ``v`` in place. ``QuickSort`` is used by default for numeric"
" arrays while ``MergeSort`` is used for other arrays. You can specify an "
"algorithm to use via the ``alg`` keyword (see `Sorting Algorithms`_ for "
"available algorithms). The ``by`` keyword lets you provide a function that "
"will be applied to each element before comparison; the ``lt`` keyword allows"
" providing a custom \"less than\" function; use ``rev=true`` to reverse the "
"sorting order. These options are independent and can be used together in all"
" possible combinations: if both ``by`` and ``lt`` are specified, the ``lt`` "
"function is applied to the result of the ``by`` function; ``rev=true`` "
"reverses whatever ordering specified via the ``by`` and ``lt`` keywords."
msgstr ""

#: ../../stdlib/sort.rst:133
msgid ""
"Variant of ``sort!`` that returns a sorted copy of ``v`` leaving ``v`` "
"itself unmodified."
msgstr ""

#: ../../stdlib/sort.rst:137
msgid "Sort a multidimensional array ``A`` along the given dimension."
msgstr ""

#: ../../stdlib/sort.rst:141
msgid ""
"Return a permutation vector of indices of ``v`` that puts it in sorted "
"order. Specify ``alg`` to choose a particular sorting algorithm (see "
"`Sorting Algorithms`_). ``MergeSort`` is used by default, and since it is "
"stable, the resulting permutation will be the lexicographically first one "
"that puts the input array into sorted order – i.e. indices of equal elements"
" appear in ascending order. If you choose a non-stable sorting algorithm "
"such as ``QuickSort``, a different permutation that puts the array into "
"order may be returned. The order is specified using the same keywords as "
"``sort!``."
msgstr ""

#: ../../stdlib/sort.rst:149
msgid "See also :func:`sortperm!`"
msgstr ""

#: ../../stdlib/sort.rst:153
msgid ""
"Like ``sortperm``, but accepts a preallocated index vector ``ix``.  If "
"``initialized`` is ``false`` (the default), ix is initialized to contain the"
" values ``1:length(v)``."
msgstr ""

#: ../../stdlib/sort.rst:156
msgid "See also :func:`sortperm`"
msgstr ""

#: ../../stdlib/sort.rst:160
msgid "Sort the rows of matrix ``A`` lexicographically."
msgstr ""

#: ../../stdlib/sort.rst:164
msgid "Sort the columns of matrix ``A`` lexicographically."
msgstr ""

#: ../../stdlib/sort.rst:168
msgid "Order-Related Functions"
msgstr ""

#: ../../stdlib/sort.rst:172
msgid ""
"Test whether a vector is in sorted order. The ``by``, ``lt`` and ``rev`` "
"keywords modify what order is considered to be sorted just as they do for "
"``sort``."
msgstr ""

#: ../../stdlib/sort.rst:177
msgid ""
"Returns the range of indices of ``a`` which compare as equal to ``x`` "
"according to the order specified by the ``by``, ``lt`` and ``rev`` keywords,"
" assuming that ``a`` is already sorted in that order. Returns an empty range"
" located at the insertion point if ``a`` does not contain values equal to "
"``x``."
msgstr ""

#: ../../stdlib/sort.rst:184
msgid ""
"Returns the index of the first value in ``a`` greater than or equal to "
"``x``, according to the specified order. Returns ``length(a)+1`` if ``x`` is"
" greater than all values in ``a``."
msgstr ""

#: ../../stdlib/sort.rst:190
msgid ""
"Returns the index of the last value in ``a`` less than or equal to ``x``, "
"according to the specified order. Returns ``0`` if ``x`` is less than all "
"values in ``a``."
msgstr ""

#: ../../stdlib/sort.rst:196
msgid ""
"Partially sort the vector ``v`` in place, according to the order specified "
"by ``by``, ``lt`` and ``rev`` so that the value at index ``k`` (or range of "
"adjacent values if ``k`` is a range) occurs at the position where it would "
"appear if the array were fully sorted via a non-stable algorithm. If ``k`` "
"is a single index, that value is returned; if ``k`` is a range, an array of "
"values at those indices is returned. Note that ``select!`` does not fully "
"sort the input array."
msgstr ""

#: ../../stdlib/sort.rst:205
msgid ""
"Variant of ``select!`` which copies ``v`` before partially sorting it, "
"thereby returning the same thing as ``select!`` but leaving ``v`` "
"unmodified."
msgstr ""

#: ../../stdlib/sort.rst:210
msgid "Sorting Algorithms"
msgstr ""

#: ../../stdlib/sort.rst:212
msgid "There are currently three sorting algorithms available in base Julia:"
msgstr ""

#: ../../stdlib/sort.rst:214
msgid "``InsertionSort``"
msgstr ""

#: ../../stdlib/sort.rst:215
msgid "``QuickSort``"
msgstr ""

#: ../../stdlib/sort.rst:216
msgid "``MergeSort``"
msgstr ""

#: ../../stdlib/sort.rst:218
msgid ""
"``InsertionSort`` is an O(n^2) stable sorting algorithm. It is efficient for"
" very small ``n``, and is used internally by ``QuickSort``."
msgstr ""

#: ../../stdlib/sort.rst:221
msgid ""
"``QuickSort`` is an O(n log n) sorting algorithm which is in-place, very "
"fast, but not stable – i.e. elements which are considered equal will not "
"remain in the same order in which they originally appeared in the array to "
"be sorted. ``QuickSort`` is the default algorithm for numeric values, "
"including integers and floats."
msgstr ""

#: ../../stdlib/sort.rst:227
msgid ""
"``MergeSort`` is an O(n log n) stable sorting algorithm but is not in-place "
"– it requires a temporary array of half the size of the input array – and is"
" typically not quite as fast as ``QuickSort``. It is the default algorithm "
"for non-numeric data."
msgstr ""

#: ../../stdlib/sort.rst:232
msgid ""
"The default sorting algorithms are chosen on the basis that they are fast "
"and stable, or *appear* to be so. For numeric types indeed, ``QuickSort`` is"
" selected as it is faster and indistinguishable in this case from a stable "
"sort (unless the array records its mutations in some way). The stability "
"property comes at a non-negligible cost, so if you don't need it, you may "
"want to explicitly specify your preferred algorithm, e.g. ``sort!(v, "
"alg=QuickSort)``."
msgstr ""

#: ../../stdlib/sort.rst:240
msgid ""
"The mechanism by which Julia picks default sorting algorithms is implemented"
" via the ``Base.Sort.defalg`` function. It allows a particular algorithm to "
"be registered as the default in all sorting functions for specific arrays. "
"For example, here are the two default methods from `sort.jl "
"<https://github.com/JuliaLang/julia/blob/master/base/sort.jl>`_::"
msgstr ""

#: ../../stdlib/sort.rst:250
msgid ""
"As for numeric arrays, choosing a non-stable default algorithm for array "
"types for which the notion of a stable sort is meaningless (i.e. when two "
"values comparing equal can not be distinguished) may make sense."
msgstr ""

#: ../../stdlib/sparse.rst:6
msgid "Sparse Matrices"
msgstr ""

#: ../../stdlib/sparse.rst:8
msgid ""
"Sparse matrices support much of the same set of operations as dense "
"matrices. The following functions are specific to sparse matrices."
msgstr ""

#: ../../stdlib/sparse.rst:12
msgid ""
"Create a sparse matrix ``S`` of dimensions ``m x n`` such that ``S[I[k], "
"J[k]] = V[k]``. The ``combine`` function is used to combine duplicates. If "
"``m`` and ``n`` are not specified, they are set to ``max(I)`` and ``max(J)``"
" respectively. If the ``combine`` function is not supplied, duplicates are "
"added by default."
msgstr ""

#: ../../stdlib/sparse.rst:16
msgid ""
"Create a sparse matrix ``S`` of size ``m x 1`` such that ``S[I[k]] = V[k]``."
" Duplicates are combined using the ``combine`` function, which defaults to "
"``+`` if it is not provided. In julia, sparse vectors are really just sparse"
" matrices with one column. Given Julia's Compressed Sparse Columns (CSC) "
"storage format, a sparse column matrix with one column is sparse, whereas a "
"sparse row matrix with one row ends up being dense."
msgstr ""

#: ../../stdlib/sparse.rst:20
msgid ""
"Create a sparse matrix of size ``m x 1`` where the row values are keys from "
"the dictionary, and the nonzero values are the values from the dictionary."
msgstr ""

#: ../../stdlib/sparse.rst:24
msgid "Returns ``true`` if ``S`` is sparse, and ``false`` otherwise."
msgstr ""

#: ../../stdlib/sparse.rst:28
msgid "Convert a dense matrix ``A`` into a sparse matrix."
msgstr ""

#: ../../stdlib/sparse.rst:32
msgid ""
"Convert a dense vector ``A`` into a sparse matrix of size ``m x 1``. In "
"julia, sparse vectors are really just sparse matrices with one column."
msgstr ""

#: ../../stdlib/sparse.rst:36
msgid "Convert a sparse matrix ``S`` into a dense matrix."
msgstr ""

#: ../../stdlib/sparse.rst:40
msgid "Returns the number of stored (filled) elements in a sparse matrix."
msgstr ""

#: ../../stdlib/sparse.rst:44
msgid "Create an empty sparse matrix of size ``m x n``."
msgstr ""

#: ../../stdlib/sparse.rst:48
msgid ""
"Create a sparse matrix with the same structure as that of ``S``, but with "
"every nonzero element having the value ``1.0``."
msgstr ""

#: ../../stdlib/sparse.rst:52
msgid ""
"Create a sparse identity matrix of specified type of size ``m x m``. In case"
" ``n`` is supplied, create a sparse identity matrix of size ``m x n``."
msgstr ""

#: ../../stdlib/sparse.rst:56
msgid ""
"Construct a sparse diagonal matrix. ``B`` is a tuple of vectors containing "
"the diagonals and ``d`` is a tuple containing the positions of the "
"diagonals. In the case the input contains only one diagonaly, ``B`` can be a"
" vector (instead of a tuple) and ``d`` can be the diagonal position (instead"
" of a tuple), defaulting to 0 (diagonal). Optionally, ``m`` and ``n`` "
"specify the size of the resulting sparse matrix."
msgstr ""

#: ../../stdlib/sparse.rst:60
msgid ""
"Create a random ``m`` by ``n`` sparse matrix, in which the probability of "
"any element being nonzero is independently given by ``p`` (and hence the "
"mean density of nonzeros is also exactly ``p``). Nonzero values are sampled "
"from the distribution specified by ``rng``. The uniform distribution is used"
" in case ``rng`` is not specified."
msgstr ""

#: ../../stdlib/sparse.rst:64
msgid ""
"Create a random ``m`` by ``n`` sparse matrix with the specified "
"(independent) probability ``p`` of any entry being nonzero, where nonzero "
"values are sampled from the normal distribution."
msgstr ""

#: ../../stdlib/sparse.rst:68
msgid ""
"Create a random ``m`` by ``n`` sparse boolean matrix with the specified "
"(independent) probability ``p`` of any entry being ``true``."
msgstr ""

#: ../../stdlib/sparse.rst:72
msgid ""
"Compute the elimination tree of a symmetric sparse matrix ``A`` from "
"``triu(A)`` and, optionally, its post-ordering permutation."
msgstr ""

#: ../../stdlib/sparse.rst:76
msgid ""
"Return the symmetric permutation of A, which is ``A[p,p]``. A should be "
"symmetric and sparse, where only the upper triangular part of the matrix is "
"stored. This algorithm ignores the lower triangular part of the matrix. Only"
" the upper triangular part of the result is returned as well."
msgstr ""

#: ../../stdlib/sparse.rst:80
msgid ""
"Return a vector of the structural nonzero values in sparse matrix ``A``. "
"This includes zeros that are explicitly stored in the sparse matrix. The "
"returned vector points directly to the internal nonzero storage of ``A``, "
"and any modifications to the returned vector will mutate ``A`` as well. See "
"``rowvals(A)`` and ``nzrange(A, col)``."
msgstr ""

#: ../../stdlib/sparse.rst:84
msgid ""
"Return a vector of the row indices of ``A``, and any modifications to the "
"returned vector will mutate ``A`` as well. Given the internal storage format"
" of sparse matrices, providing access to how the row indices are stored "
"internally can be useful in conjuction with iterating over structural "
"nonzero values. See ``nonzeros(A)`` and ``nzrange(A, col)``."
msgstr ""

#: ../../stdlib/sparse.rst:88
msgid ""
"Return the range of indices to the structural nonzero values of a sparse "
"matrix column. In conjunction with ``nonzeros(A)`` and ``rowvals(A)``, this "
"allows for convenient iterating over a sparse matrix ::"
msgstr ""

#: ../../stdlib/test.rst:4
msgid "Unit and Functional Testing"
msgstr ""

#: ../../stdlib/test.rst:6
msgid ""
"The ``Test`` module contains macros and functions related to testing. A "
"default handler is provided to run the tests, and a custom one can be "
"provided by the user by using the :func:`registerhandler` function."
msgstr ""

#: ../../stdlib/test.rst:12
msgid "Overview"
msgstr ""

#: ../../stdlib/test.rst:14
msgid ""
"To use the default handler, the macro :func:`@test` can be used directly::"
msgstr ""

#: ../../stdlib/test.rst:33
msgid ""
"As seen in the examples above, failures or errors will print the abstract "
"syntax tree of the expression in question."
msgstr ""

#: ../../stdlib/test.rst:36
msgid ""
"Another macro is provided to check if the given expression throws an "
"exception of type ``extype``, :func:`@test_throws`::"
msgstr ""

#: ../../stdlib/test.rst:56
msgid ""
"As floating point comparisons can be imprecise, two additional macros exist "
"taking in account small numerical errors::"
msgstr ""

#: ../../stdlib/test.rst:78
msgid "Handlers"
msgstr ""

#: ../../stdlib/test.rst:80
msgid ""
"A handler is a function defined for three kinds of arguments: ``Success``, "
"``Failure``, ``Error``::"
msgstr ""

#: ../../stdlib/test.rst:87
msgid ""
"A different handler can be used for a block (with :func:`with_handler`)::"
msgstr ""

#: ../../stdlib/test.rst:113
msgid ""
"The ``Success`` and ``Failure`` types include an additonal field, "
"``resultexpr``, which is a partially evaluated expression. For example, in a"
" comparison it will contain an expression with the left and right sides "
"evaluated."
msgstr ""

#: ../../stdlib/test.rst:116
msgid "Macros"
msgstr ""

#: ../../stdlib/test.rst:120
msgid ""
"Test the expression ``ex`` and calls the current handler to handle the "
"result."
msgstr ""

#: ../../stdlib/test.rst:124
msgid ""
"Test that the expression ``ex`` throws an exception of type ``extype`` and "
"calls the current handler to handle the result."
msgstr ""

#: ../../stdlib/test.rst:128
msgid ""
"Test two floating point numbers ``a`` and ``b`` for equality taking in "
"account small numerical errors."
msgstr ""

#: ../../stdlib/test.rst:133
msgid ""
"Test two floating point numbers ``a`` and ``b`` for equality taking in "
"account a margin of tolerance given by ``tol``."
msgstr ""

#: ../../stdlib/test.rst:137
msgid "Functions"
msgstr ""

#: ../../stdlib/test.rst:141
msgid "Run the function ``f`` using the ``handler`` as the handler."
msgstr ""

#: ../../stdlib/test.rst:145
msgid "Testing Base Julia"
msgstr ""

#: ../../stdlib/test.rst:147
msgid ""
"Julia is under rapid development and has an extensive test suite to verify "
"functionality across multiple platforms. If you build Julia from source, you"
" can run this test suite with ``make test``. In a binary install, you can "
"run the test suite using ``Base.runtests()``."
msgstr ""

#: ../../stdlib/test.rst:156
msgid ""
"Run the Julia unit tests listed in ``tests``, which can be either a string "
"or an array of strings, using ``numcores`` processors."
msgstr ""
